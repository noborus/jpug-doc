<!--
doc/src/sgml/ref/create_function.sgml
PostgreSQL documentation
-->

<refentry id="sql-createfunction">
 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
<!--
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 言語</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
<!--
  <refpurpose>define a new function</refpurpose>
-->
<refpurpose>新しい関数を定義する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">argtype</replaceable> [ { DEFAULT | = } <replaceable class="parameter">default_expr</replaceable> ] [, ...] ] )
    [ RETURNS <replaceable class="parameter">rettype</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">column_type</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">lang_name</replaceable>
    | TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <replaceable class="parameter">execution_cost</replaceable>
    | ROWS <replaceable class="parameter">result_rows</replaceable>
    | SUPPORT <replaceable class="parameter">support_function</replaceable>
    | SET <replaceable class="parameter">configuration_parameter</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">obj_file</replaceable>', '<replaceable class="parameter">link_symbol</replaceable>'
    | <replaceable class="parameter">sql_body</replaceable>
  } ...
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createfunction-description">
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <command>CREATE FUNCTION</command> defines a new function.
   <command>CREATE OR REPLACE FUNCTION</command> will either create a
   new function, or replace an existing definition.
   To be able to define a function, the user must have the
   <literal>USAGE</literal> privilege on the language.
-->
<command>CREATE FUNCTION</command>は新しい関数を定義します。
<command>CREATE OR REPLACE FUNCTION</command>は、新しい関数の作成、または、既存定義の置換のどちらかを行います。
関数を定義するには、ユーザはその言語の<literal>USAGE</literal>権限が必要です。
  </para>

  <para>
<!--
   If a schema name is included, then the function is created in the
   specified schema.  Otherwise it is created in the current schema.
   The name of the new function must not match any existing function or procedure
   with the same input argument types in the same schema.  However,
   functions and procedures of different argument types can share a name (this is
   called <firstterm>overloading</firstterm>).
-->
スキーマ名が含まれている場合、関数は指定されたスキーマに作成されます。
スキーマ名がなければ、関数は現在のスキーマに作成されます。
同じスキーマ内の同じ入力引数データ型を持つ既存の関数またはプロシージャの名前は、新しい関数の名前として使用できません。
しかし、異なる引数データ型を持つ関数やプロシージャであれば、名前が重複しても構いません
（これを、<firstterm>オーバーロード</firstterm>と言います）。
  </para>

  <para>
<!--
   To replace the current definition of an existing function, use
   <command>CREATE OR REPLACE FUNCTION</command>.  It is not possible
   to change the name or argument types of a function this way (if you
   tried, you would actually be creating a new, distinct function).
   Also, <command>CREATE OR REPLACE FUNCTION</command> will not let
   you change the return type of an existing function.  To do that,
   you must drop and recreate the function.  (When using <literal>OUT</literal>
   parameters, that means you cannot change the types of any
   <literal>OUT</literal> parameters except by dropping the function.)
-->
既存の関数定義を入れ替えるには、<command>CREATE OR REPLACE FUNCTION</command>を使用してください。
この方法では関数の名前や引数の型を変更することはできません
（これを行った場合、新しく別の関数が作成されます）。
また、<command>CREATE OR REPLACE FUNCTION</command>では、既存の関数の戻り値の型を変更することはできません。
戻り値の型を変更したい場合は、その関数を削除し、再度作成してください。
（これは、<literal>OUT</literal>パラメータを使用している場合、関数を削除しない限り<literal>OUT</literal>パラメータの型を変更できないことを意味します。）
  </para>

  <para>
<!--
   When <command>CREATE OR REPLACE FUNCTION</command> is used to replace an
   existing function, the ownership and permissions of the function
   do not change.  All other function properties are assigned the
   values specified or implied in the command.  You must own the function
   to replace it (this includes being a member of the owning role).
-->
<command>CREATE OR REPLACE FUNCTION</command>を使用して既存の関数を置き換える場合、関数の所有者と権限は変わりません。
他の関数に関するすべての属性には、そのコマンドで指定された値、または暗黙的な値が設定されます。
関数を置き換えるためにはその関数を所有していなければなりません。
（これには所有するロールのメンバであることが含まれています。）
  </para>

  <para>
<!--
   If you drop and then recreate a function, the new function is not
   the same entity as the old; you will have to drop existing rules, views,
   triggers, etc. that refer to the old function.  Use
   <command>CREATE OR REPLACE FUNCTION</command> to change a function
   definition without breaking objects that refer to the function.
   Also, <command>ALTER FUNCTION</command> can be used to change most of the
   auxiliary properties of an existing function.
-->
関数を削除し再作成した場合、新しい関数は古いものと同じ実体にはなりません。
古い関数を参照する、既存のルール、ビュー、トリガなどを削除しなければならないでしょう。
関数を参照するオブジェクトを破壊せずに関数定義を変更するには、<command>CREATE OR REPLACE FUNCTION</command>を使用してください。
また、<command>ALTER FUNCTION</command>を使用して、既存の関数の補助属性のほとんどを変更することができます。
  </para>

  <para>
<!--
   The user that creates the function becomes the owner of the function.
-->
関数を作成したユーザが、その関数の所有者となります。
  </para>

  <para>
<!--
   To be able to create a function, you must have <literal>USAGE</literal>
   privilege on the argument types and the return type.
-->
関数を作成するためには、引数の型および戻り値の型に対する<literal>USAGE</literal>権限を持たなければなりません。
  </para>

  <para>
<!--
   Refer to <xref linkend="xfunc"/> for further information on writing
   functions.
-->
さらに詳しい関数の作成方法については<xref linkend="xfunc"/>を参照してください。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Parameters</title>
-->
  <title>パラメータ</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">name</replaceable></term>

     <listitem>
      <para>
<!--
       The name (optionally schema-qualified) of the function to create.
-->
作成する関数の名前です（スキーマ修飾名も可）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argmode</replaceable></term>

     <listitem>
      <para>
<!--
       The mode of an argument: <literal>IN</literal>, <literal>OUT</literal>,
       <literal>INOUT</literal>, or <literal>VARIADIC</literal>.
       If omitted, the default is <literal>IN</literal>.
       Only <literal>OUT</literal> arguments can follow a <literal>VARIADIC</literal> one.
       Also, <literal>OUT</literal> and <literal>INOUT</literal> arguments cannot be used
       together with the <literal>RETURNS TABLE</literal> notation.
-->
引数のモードで、<literal>IN</literal>、<literal>OUT</literal>、<literal>INOUT</literal>、<literal>VARIADIC</literal>のいずれかです。
省略時のデフォルトは<literal>IN</literal>です。
<literal>OUT</literal>引数のみが<literal>VARIADIC</literal>の後に続けることができます。
また、<literal>RETURNS TABLE</literal>記法では、<literal>OUT</literal>と<literal>INOUT</literal>引数の両方を使用することはできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argname</replaceable></term>

     <listitem>
      <para>
<!--
       The name of an argument. Some languages (including SQL and PL/pgSQL)
       let you use the name in the function body.  For other languages the
       name of an input argument is just extra documentation, so far as
       the function itself is concerned; but you can use input argument names
       when calling a function to improve readability (see <xref
       linkend="sql-syntax-calling-funcs"/>).  In any case, the name
       of an output argument is significant, because it defines the column
       name in the result row type.  (If you omit the name for an output
       argument, the system will choose a default column name.)
-->
引数の名前です。
（SQLおよびPL/pgSQLを含む）言語の中にはこの名前を関数本体で使用できるものもあります。
他の言語では、関数そのものに注目する限り、入力引数の名前は単なる追加ドキュメントとして扱われます。
しかし関数呼び出し時に入力引数の名前を使用することで可読性を高めることができます。
（<xref linkend="sql-syntax-calling-funcs"/>参照）
どのような場合であっても、出力引数の名前は、結果の行型の列名となりますので重要です。
（出力引数の名前を省略した場合、システムはデフォルトの列名を付与します。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
<!--
       The data type(s) of the function's arguments (optionally
       schema-qualified), if any. The argument types can be base, composite,
       or domain types, or can reference the type of a table column.
-->
関数の引数のデータ型です（スキーマ修飾名も可）。
基本データ型、複合データ型、ドメイン型、または、テーブル列の型の参照を使用することができます。
      </para>
      <para>
<!--
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudo-types</quote> such as <type>cstring</type>.
       Pseudo-types indicate that the actual argument type is either
       incompletely specified, or outside the set of ordinary SQL data types.
-->
また、実装する言語に依存しますが、<type>cstring</type>といった<quote>疑似型</quote>を指定できる場合もあります。
疑似型は、実引数の型の指定が不完全である、もしくは、通常のSQLデータ型の集合を越えていることを示します。
      </para>
      <para>
<!--
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
       Using this feature can sometimes help make a function independent of
       changes to the definition of a table.
-->
列の型を参照するには、<literal><replaceable class="parameter">table_name</replaceable>.<replaceable class="parameter">column_name</replaceable>%TYPE</literal>と記述します。
これを使用すると、テーブル定義が変更されても関数が影響を受けないようにするのに役に立つことがあります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">default_expr</replaceable></term>

     <listitem>
      <para>
<!--
       An expression to be used as default value if the parameter is
       not specified.  The expression has to be coercible to the
       argument type of the parameter.
       Only input (including <literal>INOUT</literal>) parameters can have a default
        value.  All input parameters following a
       parameter with a default value must have default values as well.
-->
パラメータが指定されなかった場合のデフォルト値として使用される式です。
この式はパラメータの引数型と変換可能でなければなりません。
入力パラメータ（<literal>INOUT</literal>を含みます）のみがデフォルト値を持つことができます。
デフォルト値を持つパラメータの後ろにあるパラメータはすべて、同様にデフォルト値を持たなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">rettype</replaceable></term>

     <listitem>
      <para>
<!--
       The return data type (optionally schema-qualified). The return type
       can be a base, composite, or domain type,
       or can reference the type of a table column.
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudo-types</quote> such as <type>cstring</type>.
       If the function is not supposed to return a value, specify
       <type>void</type> as the return type.
-->
関数が返すデータの型です（スキーマ修飾名も可）。
基本型、複合型、ドメイン型、または、テーブル列の型の参照を設定することができます。
また、実装している言語によりますが、<type>cstring</type>のような<quote>疑似型</quote>も指定することが可能です。
その関数が値を返すことを想定していない場合は、戻り値として<type>void</type>を指定してください。
      </para>
      <para>
<!--
       When there are <literal>OUT</literal> or <literal>INOUT</literal> parameters,
       the <literal>RETURNS</literal> clause can be omitted.  If present, it
       must agree with the result type implied by the output parameters:
       <literal>RECORD</literal> if there are multiple output parameters, or
       the same type as the single output parameter.
-->
<literal>OUT</literal>もしくは<literal>INOUT</literal>パラメータが存在する場合、<literal>RETURNS</literal>句を省略することができます。
省略しない場合は、出力用パラメータが意味する結果型に従ったもの、つまり、複数の出力用パラメータがあれば<literal>RECORD</literal>、単一の出力用パラメータであればそれと同じ型、でなければなりません。
      </para>
      <para>
<!--
       The <literal>SETOF</literal>
       modifier indicates that the function will return a set of
       items, rather than a single item.
-->
<literal>SETOF</literal>修飾子は、その関数が、1つではなく複数のアイテムの集合を返すことを示します。
      </para>
      <para>
<!--
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
-->
列の型は、<literal><replaceable class="parameter">table_name</replaceable>.<replaceable class="parameter">column_name</replaceable>%TYPE</literal>と記述することで参照されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_name</replaceable></term>

     <listitem>
      <para>
<!--
       The name of an output column in the <literal>RETURNS TABLE</literal>
       syntax.  This is effectively another way of declaring a named
       <literal>OUT</literal> parameter, except that <literal>RETURNS TABLE</literal>
       also implies <literal>RETURNS SETOF</literal>.
-->
<literal>RETURNS TABLE</literal>構文における出力列の名前です。
これは実際名前付けされた<literal>OUT</literal>パラメータを宣言する別の方法ですが、<literal>RETURNS TABLE</literal>が<literal>RETURNS SETOF</literal>をも意味する点が異なります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_type</replaceable></term>

     <listitem>
      <para>
<!--
       The data type of an output column in the <literal>RETURNS TABLE</literal>
       syntax.
-->
<literal>RETURNS TABLE</literal>構文における出力列のデータ型です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">lang_name</replaceable></term>

     <listitem>
      <para>
<!--
       The name of the language that the function is implemented in.
       It can be <literal>sql</literal>, <literal>c</literal>,
       <literal>internal</literal>, or the name of a user-defined
       procedural language, e.g., <literal>plpgsql</literal>.  The default is
       <literal>sql</literal> if <replaceable
       class="parameter">sql_body</replaceable> is specified.  Enclosing the
       name in single quotes is deprecated and requires matching case.
-->
関数を実装している言語の名前です。
このパラメータには、<literal>sql</literal>、<literal>c</literal>、<literal>internal</literal>、もしくはユーザ定義手続き言語(例：<literal>plpgsql</literal>)の名前を指定可能です。
<replaceable class="parameter">sql_body</replaceable>が指定されていれば、デフォルトは<literal>sql</literal>です。
名前を単一引用符で囲むのは廃止予定で、大文字小文字の一致が必要になります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ] }</literal></term>

     <listitem>
      <para>
<!--
       Lists which transforms a call to the function should apply.  Transforms
       convert between SQL types and language-specific data types;
       see <xref linkend="sql-createtransform"/>.  Procedural language
       implementations usually have hardcoded knowledge of the built-in types,
       so those don't need to be listed here.  If a procedural language
       implementation does not know how to handle a type and no transform is
       supplied, it will fall back to a default behavior for converting data
       types, but this depends on the implementation.
-->
関数呼び出しにどの変換を適用すべきかのリストです。
変換はSQLの型と言語独自のデータ型の間の変換を行います（<xref linkend="sql-createtransform"/>を参照）。
手続言語の実装では、通常、ビルトインの型についてハードコードされた知識があるので、それらをこのリストに含める必要はありません。
手続言語の実装が型の処理について定めておらず、変換が提供されない場合は、データ型変換のデフォルトの動作によることになりますが、これは実装に依存します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WINDOW</literal></term>

     <listitem>
<!--
      <para><literal>WINDOW</literal> indicates that the function is a
       <firstterm>window function</firstterm> rather than a plain function.
       This is currently only useful for functions written in C.
       The <literal>WINDOW</literal> attribute cannot be changed when
       replacing an existing function definition.
-->
<para><literal>WINDOW</literal>は、この関数が普通の関数ではなく<firstterm>ウィンドウ関数</firstterm>であることを示します。
現在これはC言語で作成した関数のみに使用することができます。
既存の関数定義を置き換える場合、<literal>WINDOW</literal>属性を変更することはできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
<!--
       These attributes inform the query optimizer about the behavior
       of the function.  At most one choice
       can be specified.  If none of these appear,
       <literal>VOLATILE</literal> is the default assumption.
-->
これらの属性は、関数の動作に関する情報を問い合わせオプティマイザに提供します。
いずれか1つのキーワードのみ指定できます。
指定がない場合は、デフォルトで<literal>VOLATILE</literal>と解釈されます。
      </para>

<!--
      <para><literal>IMMUTABLE</literal> indicates that the function
       cannot modify the database and always
       returns the same result when given the same argument values; that
       is, it does not do database lookups or otherwise use information not
       directly present in its argument list.  If this option is given,
       any call of the function with all-constant arguments can be
       immediately replaced with the function value.
-->
<para><literal>IMMUTABLE</literal>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合に常に同じ結果を返すことを示します。
つまり、データベースを検索したり、引数リスト中に直接存在しない情報を使用したりしないということです。
このオプションが指定された場合、引数が全て定数である関数呼び出しは、即座に関数値と置き換えることができます。
      </para>

<!--
      <para><literal>STABLE</literal> indicates that the function
       cannot modify the database,
       and that within a single table scan it will consistently
       return the same result for the same argument values, but that its
       result could change across SQL statements.  This is the appropriate
       selection for functions whose results depend on database lookups,
       parameter variables (such as the current time zone), etc.  (It is
       inappropriate for <literal>AFTER</literal> triggers that wish to
       query rows modified by the current command.)  Also note
       that the <function>current_timestamp</function> family of functions qualify
       as stable, since their values do not change within a transaction.
-->
<para><literal>STABLE</literal>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合、常に同じ結果を返すが、SQL文が異なると結果が変わってしまう可能性があることを示します。
これは、データベース検索や（現在の時間帯のような）パラメータ変数などに結果が依存する関数に適します。
(これは現在のコマンドで変更された行を問い合わせたい<literal>AFTER</literal>トリガには不適切です。)
また、<function>current_timestamp</function>系の関数は、1つのトランザクション内では値が変化しないため、STABLEであることに注意してください。
      </para>

<!--
      <para><literal>VOLATILE</literal> indicates that the function value can
       change even within a single table scan, so no optimizations can be
       made.  Relatively few database functions are volatile in this sense;
       some examples are <literal>random()</literal>, <literal>currval()</literal>,
       <literal>timeofday()</literal>.  But note that any function that has
       side-effects must be classified volatile, even if its result is quite
       predictable, to prevent calls from being optimized away; an example is
       <literal>setval()</literal>.
-->
<para><literal>VOLATILE</literal>は、1つのテーブルスキャン内でも関数の値が変化する可能性があるため、最適化できないことを示します。
このような意味で変動的（volatile）なデータベース関数は、比較的少数です。
例えば、<literal>random()</literal>、<literal>currval()</literal>、<literal>timeofday()</literal>などは変動的な関数です。
しかし、例えば<literal>setval()</literal>などの副作用がある関数は、その結果を完全に予測できるとしても、呼び出しを最適化しないよう、<literal>VOLATILE</literal>（変動的）に分類する必要があることに注意してください。
      </para>

      <para>
<!--
       For additional details see <xref linkend="xfunc-volatility"/>.
-->
詳細は<xref linkend="xfunc-volatility"/>を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LEAKPROOF</literal></term>
     <listitem>
      <para>
<!--
       <literal>LEAKPROOF</literal> indicates that the function has no side
       effects.  It reveals no information about its arguments other than by
       its return value.  For example, a function which throws an error message
       for some argument values but not others, or which includes the argument
       values in any error message, is not leakproof.  This affects how the
       system executes queries against views created with the
       <literal>security_barrier</literal> option or tables with row level
       security enabled.  The system will enforce conditions from security
       policies and security barrier views before any user-supplied conditions
       from the query itself that contain non-leakproof functions, in order to
       prevent the inadvertent exposure of data.  Functions and operators
       marked as leakproof are assumed to be trustworthy, and may be executed
       before conditions from security policies and security barrier views.
       In addition, functions which do not take arguments or which are not
       passed any arguments from the security barrier view or table do not have
       to be marked as leakproof to be executed before security conditions.  See
       <xref linkend="sql-createview"/> and <xref linkend="rules-privileges"/>.
       This option can only be set by the superuser.
-->
<literal>LEAKPROOF</literal>は、関数が副作用を持たないことを示します。
その引数に関する情報を戻り値以外で漏らしません。
例えば、一部の引数値に対してのみエラーメッセージを返す関数や何らかのエラーメッセージの中に引数の値を含める関数は漏洩防止(leakproof)とはいえません。
これは<literal>security_barrier</literal>オプション付きで作成されたビュー、あるいは行単位セキュリティが有効にされたテーブルに対して、システムが問い合わせを実行する方法に影響します。
データが偶然に露見することを防ぐため、システムは、漏洩防止でない関数を含む問い合わせのユーザが提供した条件より前に、セキュリティポリシーおよびセキュリティバリアビューの条件を強制します。
漏洩防止であるとされた関数および演算子は信頼できると見なされ、セキュリティポリシーおよびセキュリティバリアビューによる条件より先に実行されることがあります。
なお、引数を取らない、あるいはセキュリティバリアビューやテーブルから引数を渡されない関数は、セキュリティ条件より前に実行するために漏洩防止とする必要はありません。
<xref linkend="sql-createview"/>および<xref linkend="rules-privileges"/>を参照してください。
このオプションはスーパーユーザによってのみ設定することができます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
<!--
      <para><literal>CALLED ON NULL INPUT</literal> (the default) indicates
       that the function will be called normally when some of its
       arguments are null.  It is then the function author's
       responsibility to check for null values if necessary and respond
       appropriately.
-->
<para><literal>CALLED ON NULL INPUT</literal>（デフォルト）を指定すると、引数にNULLが含まれていても、関数が通常通り呼び出されます。
その場合は、必要に応じてNULL値を確認し、適切な対応をすることは関数作成者の責任です。
      </para>

<!--
      <para><literal>RETURNS NULL ON NULL INPUT</literal> or
       <literal>STRICT</literal> indicates that the function always
       returns null whenever any of its arguments are null.  If this
       parameter is specified, the function is not executed when there
       are null arguments; instead a null result is assumed
       automatically.
-->
<para><literal>RETURNS NULL ON NULL INPUT</literal>もしくは<literal>STRICT</literal>を指定すると、関数の引数に1つでもNULLがある場合、常にNULLを返します。
このパラメータが指定されると、NULL引数がある場合、関数は実行されません。
代わりに、NULLという結果が自動的に与えられます。
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
<!--
     <para><literal>SECURITY INVOKER</literal> indicates that the function
      is to be executed with the privileges of the user that calls it.
      That is the default.  <literal>SECURITY DEFINER</literal>
      specifies that the function is to be executed with the
      privileges of the user that owns it.
-->
<para><literal>SECURITY INVOKER</literal>を指定すると、関数を呼び出したユーザの権限で、その関数が実行されます。
これがデフォルトです。
<literal>SECURITY DEFINER</literal>を指定すると、関数を所有するユーザの権限で、その関数が実行されます。
     </para>

     <para>
<!--
      The key word <literal>EXTERNAL</literal> is allowed for SQL
      conformance, but it is optional since, unlike in SQL, this feature
      applies to all functions not only external ones.
-->
<literal>EXTERNAL</literal>キーワードは、SQLとの互換性を保つために許されています。
しかし、SQLとは異なり、この機能は外部関数だけではなくすべての関数に適用されるため、このキーワードは省略可能です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARALLEL</literal></term>

    <listitem>
<!--
     <para><literal>PARALLEL UNSAFE</literal> indicates that the function
      can't be executed in parallel mode and the presence of such a
      function in an SQL statement forces a serial execution plan.  This is
      the default.  <literal>PARALLEL RESTRICTED</literal> indicates that
      the function can be executed in parallel mode, but the execution is
      restricted to parallel group leader.  <literal>PARALLEL SAFE</literal>
      indicates that the function is safe to run in parallel mode without
      restriction.
-->
     <para>
<literal>PARALLEL UNSAFE</literal>は、その関数が並列モードでは実行できないこと、そしてそのような関数がSQL文の中にある場合は順次の実行プランが強制されることを意味します。
これがデフォルトです。
<literal>PARALLEL RESTRICTED</literal>はその関数が並列モードで実行できますが、その実行は並列グループのリーダーに制限されることを意味します。
<literal>PARALLEL SAFE</literal>はその関数が並列モードで制限なく実行することについて安全であることを意味します。
     </para>

     <para>
<!--
      Functions should be labeled parallel unsafe if they modify any database
      state, or if they make changes to the transaction such as using
      sub-transactions, or if they access sequences or attempt to make
      persistent changes to settings (e.g., <literal>setval</literal>).  They should
      be labeled as parallel restricted if they access temporary tables,
      client connection state, cursors, prepared statements, or miscellaneous
      backend-local state which the system cannot synchronize in parallel mode
      (e.g.,  <literal>setseed</literal> cannot be executed other than by the group
      leader because a change made by another process would not be reflected
      in the leader).  In general, if a function is labeled as being safe when
      it is restricted or unsafe, or if it is labeled as being restricted when
      it is in fact unsafe, it may throw errors or produce wrong answers
      when used in a parallel query.  C-language functions could in theory
      exhibit totally undefined behavior if mislabeled, since there is no way
      for the system to protect itself against arbitrary C code, but in most
      likely cases the result will be no worse than for any other function.
      If in doubt, functions should be labeled as <literal>UNSAFE</literal>, which is
      the default.
-->
関数がデータベースの状態に何らかの変更を行う、サブトランザクションを使うなどトランザクションを変更する、シーケンスにアクセスするか設定に恒久的な変更をする（例えば<literal>setval</literal>）という場合はparallel unsafe（並列は安全でない）という印をつけるべきです。
一時テーブル、クライアントの接続状態、カーソル、プリペアド文、その他並列モードでシステムが同期できない様々なバックエンド独自の状態に関数がアクセスする場合、parallel restricted（並列は制限される）という印をつけるべきです（例えば、<literal>setseed</literal>はグループのリーダー以外では実行できません。なぜなら他のプロセスでなされた変更がリーダーに反映されないからです）。
一般的に、restrictedあるいはunsafeな関数がsafeとラベル付けされた場合、あるいはunsafeな関数がrestrictedとラベル付けされた場合、それがパラレルクエリ内で使用されると、エラーが発生したり、誤った結果が生成されたりします。
C言語の関数は、ラベルが間違っていると、理論的には全く予想できない動作をすることがあります。
これは任意のCプログラムに対してシステムが自分を保護する手段がないからですが、多くの場合、その結果は他の関数と同程度の悪さでしょう。
よくわからない場合は、デフォルトの<literal>UNSAFE</literal>で関数にラベル付けしてください。
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><literal>COST</literal> <replaceable class="parameter">execution_cost</replaceable></term>

     <listitem>
      <para>
<!--
       A positive number giving the estimated execution cost for the function,
       in units of <xref linkend="guc-cpu-operator-cost"/>.  If the function
       returns a set, this is the cost per returned row.  If the cost is
       not specified, 1 unit is assumed for C-language and internal functions,
       and 100 units for functions in all other languages.  Larger values
       cause the planner to try to avoid evaluating the function more often
       than necessary.
-->
この関数の推定実行コストを表す正数で、単位は<xref linkend="guc-cpu-operator-cost"/>です。
関数が集合を返す場合、これは1行当たりのコストとなります。
このコストが指定されない場合、C言語および内部関数では1、他のすべての言語では100となります。
値をより大きくすると、プランナは必要以上に頻繁に関数を評価しないようになります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ROWS</literal> <replaceable class="parameter">result_rows</replaceable></term>

     <listitem>
      <para>
<!--
       A positive number giving the estimated number of rows that the planner
       should expect the function to return.  This is only allowed when the
       function is declared to return a set.  The default assumption is
       1000 rows.
-->
プランナが想定する、この関数が返す行数の推定値を表す正数です。
これは、関数が集合を返すものと宣言された場合のみ使用可能です。
デフォルト推定値は1000行です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SUPPORT</literal> <replaceable class="parameter">support_function</replaceable></term>

     <listitem>
      <para>
<!--
       The name (optionally schema-qualified) of a <firstterm>planner support
       function</firstterm> to use for this function.  See
       <xref linkend="xfunc-optimization"/> for details.
       You must be superuser to use this option.
-->
この関数のために使う<firstterm>プランナサポート関数</firstterm>の名前です(スキーマ修飾名も可)。
詳細は<xref linkend="xfunc-optimization"/>を参照してください。
このオプションを使うにはスーパーユーザでなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>configuration_parameter</replaceable></term>
     <term><replaceable>value</replaceable></term>
     <listitem>
      <para>
<!--
       The <literal>SET</literal> clause causes the specified configuration
       parameter to be set to the specified value when the function is
       entered, and then restored to its prior value when the function exits.
       <literal>SET FROM CURRENT</literal> saves the value of the parameter that
       is current when <command>CREATE FUNCTION</command> is executed as the value
       to be applied when the function is entered.
-->
<literal>SET</literal>句により、関数が始まった時に指定した設定パラメータを指定した値に設定し、関数の終了時にそれを以前の値に戻すことができます。
<literal>SET FROM CURRENT</literal>は、<command>CREATE FUNCTION</command>の実行時点でのパラメータ値を、関数に入る時に適用する値として保管します。
      </para>

      <para>
<!--
       If a <literal>SET</literal> clause is attached to a function, then
       the effects of a <command>SET LOCAL</command> command executed inside the
       function for the same variable are restricted to the function: the
       configuration parameter's prior value is still restored at function exit.
       However, an ordinary
       <command>SET</command> command (without <literal>LOCAL</literal>) overrides the
       <literal>SET</literal> clause, much as it would do for a previous <command>SET
       LOCAL</command> command: the effects of such a command will persist after
       function exit, unless the current transaction is rolled back.
-->
関数に<literal>SET</literal>句が付いている場合、関数内部で実行される<command>SET LOCAL</command>コマンドの同一変数に対する効果はその関数に制限されます。
つまり、設定パラメータの前の値は関数が終了する時に元に戻ります。
しかし、通常の（<literal>LOCAL</literal>がない）<command>SET</command>コマンドは<literal>SET</literal>句を上書きします。
これは過去に行われた<command>SET LOCAL</command>コマンドに対してもほぼ同じです。
つまり、このコマンドの効果は、現在のトランザクションがロールバックされない限り、関数が終了した後も永続化されます。
      </para>

      <para>
<!--
       See <xref linkend="sql-set"/> and
       <xref linkend="runtime-config"/>
       for more information about allowed parameter names and values.
-->
使用可能なパラメータと値については、<xref linkend="sql-set"/>および<xref linkend="runtime-config"/>を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
<!--
       A string constant defining the function; the meaning depends on the
       language.  It can be an internal function name, the path to an
       object file, an SQL command, or text in a procedural language.
-->
関数を定義する文字列定数です。
このパラメータの意味は言語に依存します。
内部的な関数名、オブジェクトファイルへのパス、SQLコマンド、手続き言語で記述されたテキストなどを指定できます。
      </para>

      <para>
<!--
       It is often helpful to use dollar quoting (see <xref
       linkend="sql-syntax-dollar-quoting"/>) to write the function definition
       string, rather than the normal single quote syntax.  Without dollar
       quoting, any single quotes or backslashes in the function definition must
       be escaped by doubling them.
-->
関数を定義する文字列を記述する際に、通常の単一引用符ではなく、ドル引用符（<xref linkend="sql-syntax-dollar-quoting"/>参照）を使用すると便利なことが多くあります。
ドル引用符を使用しなければ、関数定義内の単一引用符やバックスラッシュは必ず二重にしてエスケープしなければなりません。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">obj_file</replaceable>, <replaceable class="parameter">link_symbol</replaceable></literal></term>

     <listitem>
      <para>
<!--
       This form of the <literal>AS</literal> clause is used for
       dynamically loadable C language functions when the function name
       in the C language source code is not the same as the name of
       the SQL function. The string <replaceable
       class="parameter">obj_file</replaceable> is the name of the shared
       library file containing the compiled C function, and is interpreted
       as for the <link linkend="sql-load"><command>LOAD</command></link> command.  The string
       <replaceable class="parameter">link_symbol</replaceable> is the
       function's link symbol, that is, the name of the function in the C
       language source code.  If the link symbol is omitted, it is assumed to
       be the same as the name of the SQL function being defined.  The C names
       of all functions must be different, so you must give overloaded C
       functions different C names (for example, use the argument types as
       part of the C names).
-->
この構文の<literal>AS</literal>句は、動的にロードされるC言語関数において、C言語のソースコード中の関数名がSQL関数の名前と同じでない場合に使われます。
<replaceable class="parameter">obj_file</replaceable>という文字列はコンパイルされたC関数を含む共有ライブラリファイルの名前で、<link linkend="sql-load"><command>LOAD</command></link>コマンドの場合と同じように解釈されます。
文字列<replaceable class="parameter">link_symbol</replaceable>はその関数のリンクシンボル、つまり、C言語ソースコード中の関数の名前です。
リンクシンボルが省略された場合、定義されるSQL関数の名前と同じものであるとみなされます。
全ての関数について、C言語における名前は、重複してはいけません。したがって、オーバーロードするC言語関数には、異なるC言語の名前を与える必要があります(例えば、C言語における名前の一部に引数の型を使用してください)。
      </para>

      <para>
<!--
       When repeated <command>CREATE FUNCTION</command> calls refer to
       the same object file, the file is only loaded once per session.
       To unload and
       reload the file (perhaps during development), start a new session.
-->
同一オブジェクトファイルを参照する、<command>CREATE FUNCTION</command>呼び出しが繰り返された場合、そのファイルはセッション毎に一度だけロードされます。
（おそらく開発段階で）ファイルをアンロードし再ロードするには、新しいセッションを開始してください。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">sql_body</replaceable></term>

     <listitem>
      <para>
<!--
       The body of a <literal>LANGUAGE SQL</literal> function.  This can
       either be a single statement
-->
<literal>LANGUAGE SQL</literal>関数の本体です。
これは以下のような単一の文
<programlisting>
RETURN <replaceable>expression</replaceable>
</programlisting>
<!--
       or a block
-->
またはブロックです。
<programlisting>
BEGIN ATOMIC
  <replaceable>statement</replaceable>;
  <replaceable>statement</replaceable>;
  ...
  <replaceable>statement</replaceable>;
END
</programlisting>
      </para>

      <para>
<!--
       This is similar to writing the text of the function body as a string
       constant (see <replaceable>definition</replaceable> above), but there
       are some differences: This form only works for <literal>LANGUAGE
       SQL</literal>, the string constant form works for all languages.  This
       form is parsed at function definition time, the string constant form is
       parsed at execution time; therefore this form cannot support
       polymorphic argument types and other constructs that are not resolvable
       at function definition time.  This form tracks dependencies between the
       function and objects used in the function body, so <literal>DROP
       ... CASCADE</literal> will work correctly, whereas the form using
       string literals may leave dangling functions.  Finally, this form is
       more compatible with the SQL standard and other SQL implementations.
-->
これは文字列定数として関数本体を書くのと似ていますが(上記の<replaceable>definition</replaceable>を参照してください)、いくつか違いがあります。
この形式は<literal>LANGUAGE SQL</literal>に対してのみ機能し、文字列定数の形式はすべての言語に対して機能します。
この形式はプロシージャ定義時に解析され、文字列定数の形式は実行時に解析されます。
そのため、この形式は多様引数型や関数定義時に解決できないその他の構文をサポートできません。
この形式は関数と関数本体の中で使われているオブジェクトの間の依存関係を追跡しますので、<literal>DROP ... CASCADE</literal>は正しく動作しますが、一方、文字列定数を使う形式は宙に浮いた関数を放置するかもしれません。
最後に、この形式は標準SQLや他のSQL実装とより互換性があります。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
<!--
  <title>Overloading</title>
-->
  <title>オーバーロード</title>

   <para>
<!--
    <productname>PostgreSQL</productname> allows function
    <firstterm>overloading</firstterm>; that is, the same name can be
    used for several different functions so long as they have distinct
    input argument types.  Whether or not you use it, this capability entails
    security precautions when calling functions in databases where some users
    mistrust other users; see <xref linkend="typeconv-func"/>.
-->
<productname>PostgreSQL</productname>では関数の<firstterm>オーバーロード</firstterm>が可能です。
つまり、入力引数の型が異なっていれば、複数の関数に同じ名前を使用することができます。
使うかどうかに関わりなく、この能力は、あるユーザが他のユーザを信用しないデータベースで関数を呼び出す時に、セキュリティの事前の対策を必要とします。<xref linkend="typeconv-func"/>を参照してください。
   </para>

   <para>
<!--
    Two functions are considered the same if they have the same names and
    <emphasis>input</emphasis> argument types, ignoring any <literal>OUT</literal>
    parameters.  Thus for example these declarations conflict:
-->
同じ名前、同じ<emphasis>入力用</emphasis>パラメータ型を持つ場合、2つの関数は同一であるとみなされます。
<literal>OUT</literal>パラメータは無視されます。
したがって、例えば以下の宣言は競合しています。
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

   <para>
<!--
    Functions that have different argument type lists will not be considered
    to conflict at creation time, but if defaults are provided they might
    conflict in use.  For example, consider
-->
異なる引数型のリストを持つ関数は、作成時に競合するとはみなされませんが、デフォルト値が指定された場合使用時に競合する可能性があります。
例えば以下を考えてみましょう。
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</programlisting>
<!--
    A call <literal>foo(10)</literal> will fail due to the ambiguity about which
    function should be called.
-->
<literal>foo(10)</literal>という呼び出しは、どちらの関数を呼び出すべきかに関して曖昧さがあるために失敗します。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

   <para>
<!--
    The full <acronym>SQL</acronym> type syntax is allowed for
    declaring a function's arguments and return value.  However,
    parenthesized type modifiers (e.g., the precision field for
    type <type>numeric</type>) are discarded by <command>CREATE FUNCTION</command>.
    Thus for example
    <literal>CREATE FUNCTION foo (varchar(10)) ...</literal>
    is exactly the same as
    <literal>CREATE FUNCTION foo (varchar) ...</literal>.
-->
関数の引数と戻り値の宣言において、完全な<acronym>SQL</acronym>型の構文が使用できます。
しかし、括弧付けされた型修飾子（例えば<type>numeric</type>型の精度フィールド）は、<command>CREATE FUNCTION</command>により破棄されます。
従って、<literal>CREATE FUNCTION foo (varchar(10)) ...</literal>は<literal>CREATE FUNCTION foo (varchar) ...</literal>とまったく同じになります。
   </para>

   <para>
<!--
    When replacing an existing function with <command>CREATE OR REPLACE
    FUNCTION</command>, there are restrictions on changing parameter names.
    You cannot change the name already assigned to any input parameter
    (although you can add names to parameters that had none before).
    If there is more than one output parameter, you cannot change the
    names of the output parameters, because that would change the
    column names of the anonymous composite type that describes the
    function's result.  These restrictions are made to ensure that
    existing calls of the function do not stop working when it is replaced.
-->
既存の関数を<command>CREATE OR REPLACE FUNCTION</command>を使って置き換える場合、パラメータ名の変更に関して制限があります。
すでに何らかの入力パラメータに割り当てられた名前を変更することはできません。
（しかし、これまで名前を持たなかったパラメータに名前を追加することは可能です。）
複数の出力パラメータが存在する場合、関数の結果を表わす無名複合型の列名を変更することになるため、出力パラメータの名前を変更することはできません。
既存の関数呼び出しが置き換わった時に動作しなくなることを確実に防ぐために、これらの制限がなされています。
   </para>

   <para>
<!--
    If a function is declared <literal>STRICT</literal> with a <literal>VARIADIC</literal>
    argument, the strictness check tests that the variadic array <emphasis>as
    a whole</emphasis> is non-null.  The function will still be called if the
    array has null elements.
-->
関数が<literal>VARIADIC</literal>引数を持つ<literal>STRICT</literal>と宣言された場合、その厳密性検査では、variadic配列<emphasis>全体</emphasis>が非NULLかどうかを検査します。
配列がNULL要素を持っていたとしても関数は呼び出されます。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   Add two integers using an SQL function:
-->
SQL関数を使って2つの整数を足す。
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
<!--
   The same function written in a more SQL-conforming style, using argument
   names and an unquoted body:
-->
引数名と引用されていない本体を使って、よりSQLに準拠した形で書かれた同じ関数。
<programlisting>
CREATE FUNCTION add(a integer, b integer) RETURNS integer
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT
    RETURN a + b;
</programlisting>
  </para>

  <para>
<!--
   Increment an integer, making use of an argument name, in
   <application>PL/pgSQL</application>:
-->
<application>PL/pgSQL</application>で、引数名を使用して、整数を1増やします。
<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
<!--
   Return a record containing multiple output parameters:
-->
複数の出力用パラメータを持つレコードを返します。
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!--
   You can do the same thing more verbosely with an explicitly named
   composite type:
-->
上と同じことを、明示的な名前が付いた複合型を使用して、より冗長に行うことができます。
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!--
   Another way to return multiple columns is to use a <literal>TABLE</literal>
   function:
-->
複数列を返す別の方法は、<literal>TABLE</literal>関数を使用することです。
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!--
   However, a <literal>TABLE</literal> function is different from the
   preceding examples, because it actually returns a <emphasis>set</emphasis>
   of records, not just one record.
-->
しかし、これは実際には、1つのレコードではなく、レコードの<emphasis>集合</emphasis>を返しますので、<literal>TABLE</literal>関数は上の例とは異なります。
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-security">
<!--
  <title>Writing <literal>SECURITY DEFINER</literal> Functions Safely</title>
-->
  <title><literal>SECURITY DEFINER</literal>関数の安全な作成</title>

  <indexterm>
   <primary><varname>search_path</varname> configuration parameter</primary>
   <secondary>use in securing functions</secondary>
  </indexterm>
  <indexterm>
   <primary><varname>search_path</varname>設定パラメータ</primary>
   <secondary>関数の安全化における使用</secondary>
  </indexterm>

   <para>
<!--
    Because a <literal>SECURITY DEFINER</literal> function is executed
    with the privileges of the user that owns it, care is needed to
    ensure that the function cannot be misused.  For security,
    <xref linkend="guc-search-path"/> should be set to exclude any schemas
    writable by untrusted users.  This prevents
    malicious users from creating objects (e.g., tables, functions, and
    operators) that mask objects intended to be used by the function.
    Particularly important in this regard is the
    temporary-table schema, which is searched first by default, and
    is normally writable by anyone.  A secure arrangement can be obtained
    by forcing the temporary schema to be searched last.  To do this,
    write <literal>pg_temp</literal><indexterm><primary>pg_temp</primary><secondary>securing functions</secondary></indexterm> as the last entry in <varname>search_path</varname>.
    This function illustrates safe usage:
-->
<literal>SECURITY DEFINER</literal>関数は関数を所有するユーザの権限で実行されますので、その関数を間違って使用できないことを確実にしなければなりません。
安全上、<xref linkend="guc-search-path"/>は、信頼できないユーザが書き込み可能なスキーマを除去した形で設定すべきです。
これは、悪意のあるユーザがその関数で使用されるオブジェクトを隠すようなオブジェクト（例えば、テーブル、関数、演算子など）を作成することを防ぎます。
ここで特に重要なことは、一時テーブルスキーマです。
このスキーマはデフォルトで最初に検索され、そして、通常誰でも書き込み可能です。
一時スキーマの検索を強制的に最後にすることで、セキュリティを調整できます。
このためには、<literal>pg_temp</literal>を<varname>search_path</varname>の最後の項目として記載してください。
<indexterm><primary>pg_temp</primary><secondary>関数の安全化</secondary></indexterm>
安全な使用方法を以下の関数で示します。

<programlisting>
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
<!--
    &#045;&#045; Set a secure search_path: trusted schema(s), then 'pg_temp'.
-->
    -- 信頼できるスキーマ、その後にpg_tempという順でsearch_pathを安全に設定します。
    SET search_path = admin, pg_temp;
</programlisting>

<!--
    This function's intention is to access a table <literal>admin.pwds</literal>.
    But without the <literal>SET</literal> clause, or with a <literal>SET</literal> clause
    mentioning only <literal>admin</literal>, the function could be subverted by
    creating a temporary table named <literal>pwds</literal>.
-->
この関数の意図は、テーブル<literal>admin.pwds</literal>にアクセスすることです。
しかし<literal>SET</literal>句がなければ、あるいは<literal>SET</literal>句が<literal>admin</literal>だけしか記述していなければ、<literal>pwds</literal>という名前の一時テーブルを作成することで、この関数は無意味になってしまいます。
   </para>

   <para>
<!--
    Before <productname>PostgreSQL</productname> version 8.3, the
    <literal>SET</literal> clause was not available, and so older functions may
    contain rather complicated logic to save, set, and restore
    <varname>search_path</varname>.  The <literal>SET</literal> clause is far easier
    to use for this purpose.
-->
<productname>PostgreSQL</productname>バージョン8.3より前では、<literal>SET</literal>句は利用できません。
このため古い関数には、<varname>search_path</varname>を保管し、設定、そして元に戻すという、多少複雑なロジックが含まれているかもしれません。
こうした目的に<literal>SET</literal>句を使用すると、かなり簡単になります。
   </para>

   <para>
<!--
    Another point to keep in mind is that by default, execute privilege
    is granted to <literal>PUBLIC</literal> for newly created functions
    (see <xref linkend="ddl-priv"/> for more
    information).  Frequently you will wish to restrict use of a security
    definer function to only some users.  To do that, you must revoke
    the default <literal>PUBLIC</literal> privileges and then grant execute
    privilege selectively.  To avoid having a window where the new function
    is accessible to all, create it and set the privileges within a single
    transaction.  For example:
-->
この他に注意すべき点として、新しく作成された関数ではデフォルトで実行権限が<literal>PUBLIC</literal>に付与されていることがあります。
（詳細は<xref linkend="ddl-priv"/>を参照してください。）
SECURITY DEFINER関数の使用を一部のユーザのみに制限したいことはよくあります。
このためには、デフォルトの<literal>PUBLIC</literal>権限を取り消し、そして、実行権限の付与を選択して行ってください。
新しい関数がすべてのユーザに実行可能となる隙間が存在することを防ぐためには、単一トランザクション内で作成と権限設定を行ってください。
以下に例を示します。
   </para>

<programlisting>
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
<!--
  <title>Compatibility</title>
-->
  <title>互換性</title>

  <para>
<!--
   A <command>CREATE FUNCTION</command> command is defined in the SQL
   standard.  The <productname>PostgreSQL</productname> implementation can be
   used in a compatible way but has many extensions.  Conversely, the SQL
   standard specifies a number of optional features that are not implemented
   in <productname>PostgreSQL</productname>.
-->
<command>CREATE FUNCTION</command>コマンドは標準SQLで定義されています。
<productname>PostgreSQL</productname>の実装は互換性のある方法で使うことはできますが、多くの拡張があります。
逆に、標準SQLには<productname>PostgreSQL</productname>では実装されていない多くの省略可能な機能が定義されています。
  </para>

  <para>
<!--
   The following are important compatibility issues:
-->
以下が重要な互換性の問題です。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>OR REPLACE</literal> is a PostgreSQL extension.
-->
<literal>OR REPLACE</literal>はPostgreSQLの拡張です。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      For compatibility with some other database systems, <replaceable
      class="parameter">argmode</replaceable> can be written either before or
      after <replaceable class="parameter">argname</replaceable>.  But only
      the first way is standard-compliant.
-->
他のデータベースシステムとの互換性のために、<replaceable class="parameter">argmode</replaceable>は<replaceable class="parameter">argname</replaceable>の前に書くことも後に書くこともできます。
しかし、1つ目の方法が標準に従っています。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      For parameter defaults, the SQL standard specifies only the syntax with
      the <literal>DEFAULT</literal> key word.  The syntax with
      <literal>=</literal> is used in T-SQL and Firebird.
-->
パラメータのデフォルトに関しては、標準SQLでは<literal>DEFAULT</literal>キーワードの構文のみを規定します。
<literal>=</literal>を持つ構文はT-SQLおよびFirebirdで使用されています。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The <literal>SETOF</literal> modifier is a PostgreSQL extension.
-->
<literal>SETOF</literal>修飾子はPostgreSQLの拡張です。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Only <literal>SQL</literal> is standardized as a language.
-->
<literal>SQL</literal>のみが言語として標準化されています。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      All other attributes except <literal>CALLED ON NULL INPUT</literal> and
      <literal>RETURNS NULL ON NULL INPUT</literal> are not standardized.
-->
<literal>CALLED ON NULL INPUT</literal>と<literal>RETURNS NULL ON NULL INPUT</literal>以外の属性はすべて標準化されていません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      For the body of <literal>LANGUAGE SQL</literal> functions, the SQL
      standard only specifies the <replaceable>sql_body</replaceable> form.
-->
<literal>LANGUAGE SQL</literal>関数の本体に対して、標準SQLは<replaceable>sql_body</replaceable>形式のみを定義しています。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   Simple <literal>LANGUAGE SQL</literal> functions can be written in a way
   that is both standard-conforming and portable to other implementations.
   More complex functions using advanced features, optimization attributes, or
   other languages will necessarily be specific to PostgreSQL in a significant
   way.
-->
単純な<literal>LANGUAGE SQL</literal>関数は、標準に準拠して、なおかつ他の実装に移植性のある方法で書くことができます。
高度な機能、最適化属性、他の言語を使ったより複雑な関数は、必ず重要なところでPostgreSQLに固有のものになるでしょう。
  </para>
 </refsect1>


 <refsect1>
<!--
  <title>See Also</title>
-->
  <title>関連項目</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"/></member>
   <member><xref linkend="sql-dropfunction"/></member>
   <member><xref linkend="sql-grant"/></member>
   <member><xref linkend="sql-load"/></member>
   <member><xref linkend="sql-revoke"/></member>
  </simplelist>
 </refsect1>

</refentry>
