<!-- doc/src/sgml/user-manag.sgml -->

<chapter id="user-manag">
<!--
 <title>Database Roles</title>
-->
 <title>データベースロール</title>

 <para>
<!--
  <productname>PostgreSQL</productname> manages database access permissions
  using the concept of <firstterm>roles</firstterm>.  A role can be thought of as
  either a database user, or a group of database users, depending on how
  the role is set up.  Roles can own database objects (for example, tables
  and functions) and can assign privileges on those objects to other roles to
  control who has access to which objects.  Furthermore, it is possible
  to grant <firstterm>membership</firstterm> in a role to another role, thus
  allowing the member role to use privileges assigned to another role.
-->
<productname>PostgreSQL</productname>は、<firstterm>ロール</firstterm>という概念を使用してデータベースへの接続承認を管理します。
ロールは、その設定方法に応じて、データベースユーザ、またはデータベースユーザのグループとみなすことができます。
ロールはデータベースオブジェクト（例えばテーブルや関数）を所有することができます。
またロールは、どのオブジェクトに誰がアクセスできるかを制御するために、それらのオブジェクトに対しての権限を他のロールに割り当てることができます。
更に、ロールの<firstterm>メンバ資格</firstterm>を他のロールに与えることもできます。
そのため、メンバとなったロールは別のロールに割り当てられた権限を使用することができます。
 </para>

 <para>
<!--
  The concept of roles subsumes the concepts of <quote>users</quote> and
  <quote>groups</quote>.  In <productname>PostgreSQL</productname> versions
  before 8.1, users and groups were distinct kinds of entities, but now
  there are only roles.  Any role can act as a user, a group, or both.
-->
ロールの概念には、<quote>ユーザ</quote>という概念と<quote>グループ</quote>という概念が含まれます。
<productname>PostgreSQL</productname>バージョン8.1より前まででは、ユーザとグループは異なる種類の実体として扱われていました。
しかし、現在ではロールしか存在しません。
すべてのロールは、ユーザとして、グループとして、またはその両方として動作することができます。
 </para>

 <para>
<!--
  This chapter describes how to create and manage roles.
  More information about the effects of role privileges on various
  database objects can be found in <xref linkend="ddl-priv"/>.
-->
本章では、ロールの作成と管理の方法について説明します。
様々なデータベースオブジェクト上の権限の効果について、さらに詳細な情報は<xref linkend="ddl-priv"/>に記載されています。
 </para>

 <sect1 id="database-roles">
<!--
  <title>Database Roles</title>
-->
  <title>データベースロール</title>

  <indexterm zone="database-roles">
   <primary>role</primary>
  </indexterm>
  <indexterm zone="database-roles">
   <primary>ロール</primary>
  </indexterm>

  <indexterm zone="database-roles">
   <primary>user</primary>
  </indexterm>
  <indexterm zone="database-roles">
   <primary>ユーザ</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>

  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>

  <para>
<!--
   Database roles are conceptually completely separate from
   operating system users. In practice it might be convenient to
   maintain a correspondence, but this is not required. Database roles
   are global across a database cluster installation (and not
   per individual database). To create a role use the <link
   linkend="sql-createrole"><command>CREATE ROLE</command></link> SQL command:
-->
データベースロールは概念的に、オペレーティングシステムユーザとは完全に分離されています。
実行する上でユーザ名を一致させておくと便利ですが、必須ではありません。
データベースロール名はデータベースクラスタインストレーション全体で共通です
（個別のデータベースごとではありません）。
ユーザを作成するためには<link linkend="sql-createrole"><command>CREATE ROLE</command></link> SQLコマンドを使います。
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   <replaceable>name</replaceable> follows the rules for SQL
   identifiers: either unadorned without special characters, or
   double-quoted.  (In practice, you will usually want to add additional
   options, such as <literal>LOGIN</literal>, to the command.  More details appear
   below.)  To remove an existing role, use the analogous
   <link linkend="sql-droprole"><command>DROP ROLE</command></link> command:
-->
<replaceable>name</replaceable>はSQL識別子の規則に従います。
特殊な文字を持たない無装飾のものか、二重引用符に囲まれたもののどちらかです。
（現実的には、通常他のオプション、例えば<literal>LOGIN</literal>などをこのコマンドに付与することになるでしょう。
詳細は後で説明します。）
既存のユーザを削除するためには類似のコマンド<link linkend="sql-droprole"><command>DROP ROLE</command></link>を使用してください。
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
<!--
   For convenience, the programs <xref linkend="app-createuser"/>
   and <xref linkend="app-dropuser"/> are provided as wrappers
   around these SQL commands that can be called from the shell command
   line:
-->
利便性のために、これらのSQLコマンドのラッパーである、シェルのコマンドラインから呼び出し可能な<xref linkend="app-createuser"/>プログラムと<xref linkend="app-dropuser"/>プログラムが提供されています。
<synopsis>
createuser <replaceable>name</replaceable>
dropuser <replaceable>name</replaceable>
</synopsis>
  </para>

  <para>
<!--
   To determine the set of existing roles, examine the <structname>pg_roles</structname>
   system catalog, for example:
-->
既存のロール群を求めるためには、以下のように<structname>pg_roles</structname>システムカタログを確認してください。
<synopsis>
SELECT rolname FROM pg_roles;
</synopsis>
<!--
   or to see just those capable of logging in:
-->
あるいはログインできるロールだけを確認するには以下のようにします。
<synopsis>
SELECT rolname FROM pg_roles WHERE rolcanlogin;
</synopsis>
<!--
   The <xref linkend="app-psql"/> program's <literal>\du</literal> meta-command
   is also useful for listing the existing roles.
-->
また、<xref linkend="app-psql"/>プログラムの<literal>\du</literal>メタコマンドも既存のロールを列挙する際に役に立ちます。
  </para>

  <para>
<!--
   In order to bootstrap the database system, a freshly initialized
   system always contains one predefined login-capable role. This role
   is always a <quote>superuser</quote>, and it will have
   the same name as the operating system user that initialized the
   database cluster with <command>initdb</command> unless a different name
   is specified.  This role is often named
   <literal>postgres</literal>. In order to create more roles you
   first have to connect as this initial role.
-->
データベースシステム自身を起動するために、初期化されたばかりのシステムは常に定義済みでログイン可能なロールを1つ持ちます。
このロールは必ず<quote>スーパーユーザ</quote>であり、異なる名前を指定しない限り、<command>initdb</command>でそのデータベースクラスタを初期化したオペレーティングシステムユーザと同じ名前となります。
このロールはしばしば<literal>postgres</literal>と名付けられます。
ロールを追加する場合はまずこの初期ロールで接続しなければいけません。
  </para>

  <para>
<!--
   Every connection to the database server is made using the name of some
   particular role, and this role determines the initial access privileges for
   commands issued in that connection.
   The role name to use for a particular database
   connection is indicated by the client that is initiating the
   connection request in an application-specific fashion. For example,
   the <command>psql</command> program uses the
   <option>-U</option> command line option to indicate the role to
   connect as.  Many applications assume the name of the current
   operating system user by default (including
   <command>createuser</command> and <command>psql</command>).  Therefore it
   is often convenient to maintain a naming correspondence between
   roles and operating system users.
-->
すべてのデータベースサーバへの接続は、特定のロールの名前を使用して確立し、そのロールによりその接続で発行されるコマンドの初期のアクセス権限が決まります。
特定のデータベース接続に使うロールは、アプリケーション固有の方式で接続要求を開始するクライアントによって指示されます。
例えば、<command>psql</command>プログラムでは、<option>-U</option>コマンドラインオプションを使って接続するロールを指示します。
多くのアプリケーション（<command>createuser</command>および<command>psql</command>を含む）では、オペレーティングシステムの現在のユーザ名をデフォルトと想定します。
したがって、ロールとオペレーティングシステムのユーザの組み合わせ間で名前を一致させておくと便利です。
  </para>

  <para>
<!--
   The set of database roles a given client connection can connect as
   is determined by the client authentication setup, as explained in
   <xref linkend="client-authentication"/>. (Thus, a client is not
   limited to connect as the role matching
   its operating system user, just as a person's login name
   need not match his or her real name.)  Since the role
   identity determines the set of privileges available to a connected
   client, it is important to carefully configure privileges when setting up
   a multiuser environment.
-->
<xref linkend="client-authentication"/>で説明されているように、あるクライアント接続で与えられたデータベースロールの集合は、クライアント認証設定で決定された内容で接続できます。
（したがって、ユーザのログイン名が本名と一致していなくても構わないのと同様に、クライアントはオペレーティングシステムのユーザ名と同じロール名で接続しなくても構いません）。
接続したクライアントに付与される権限の内容はロールIDによって決定されるため、マルチユーザ環境を設定する際には権限を注意深く設定することが重要です。
  </para>
 </sect1>

 <sect1 id="role-attributes">
<!--
  <title>Role Attributes</title>
-->
  <title>ロールの属性</title>

   <para>
<!--
    A database role can have a number of attributes that define its
    privileges and interact with the client authentication system.
-->
データベースロールは、権限を定義し、クライアント認証システムと相互作用する数多くの属性を持つことができます。

    <variablelist>
     <varlistentry>
<!--
      <term>login privilege<indexterm><primary>login privilege</primary></indexterm></term>
-->
      <term>ログイン権限<indexterm><primary>ログイン権限</primary></indexterm></term>
      <listitem>
       <para>
<!--
        Only roles that have the <literal>LOGIN</literal> attribute can be used
        as the initial role name for a database connection.  A role with
        the <literal>LOGIN</literal> attribute can be considered the same
        as a <quote>database user</quote>.  To create a role with login privilege,
        use either:
-->
<literal>LOGIN</literal>属性を持つロールのみがデータベース接続の初期ロール名として使用できます。
<literal>LOGIN</literal> 属性を持つロールは<quote>データベースユーザ</quote>と同じであるとみなすことができます。
ログイン権限を持つロールの作成方法は、以下のいずれかです。
<programlisting>
CREATE ROLE <replaceable>name</replaceable> LOGIN;
CREATE USER <replaceable>name</replaceable>;
</programlisting>
<!--
        (<command>CREATE USER</command> is equivalent to <command>CREATE ROLE</command>
        except that <command>CREATE USER</command> includes <literal>LOGIN</literal> by
        default, while <command>CREATE ROLE</command> does not.)
-->
（<command>CREATE USER</command>はデフォルトで <literal>LOGIN</literal>を持ち、<command>CREATE ROLE</command>は持たないという点を除き、<command>CREATE USER</command>は<command>CREATE ROLE</command>と同じです。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>superuser status<indexterm><primary>superuser</primary></indexterm></term>
-->
      <term>スーパーユーザ状態<indexterm><primary>スーパーユーザ</primary></indexterm></term>
      <listitem>
       <para>
<!--
        A database superuser bypasses all permission checks, except the right
        to log in.  This is a dangerous privilege and should not be used
        carelessly; it is best to do most of your work as a role that is not a
        superuser.  To create a new database superuser, use <literal>CREATE
        ROLE <replaceable>name</replaceable> SUPERUSER</literal>.  You must do
        this as a role that is already a superuser.
-->
ログイン権限を除き、データベーススーパーユーザに対する権限検査は全て行われません。
これは危険な権限ですので、安易に使用してはいけません。
作業のほとんどを非スーパーユーザのロールで行うことが最善です。
新しいデータベーススーパーユーザを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> SUPERUSER</literal>を使用してください。
これはスーパーユーザのロールで実行しなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>database creation<indexterm><primary>database</primary><secondary>privilege to create</secondary></indexterm></term>
-->
      <term>データベース作成<indexterm><primary>データベース</primary><secondary>を作成する権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        A role must be explicitly given permission to create databases
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEDB</literal>.
-->
（全ての権限検査が行われないスーパーユーザを除き）ロールに明示的にデータベースを作成するための権限を指定しておかねばいけません。
そのようなロールを作るためには<literal>CREATE ROLE <replaceable>name</replaceable> CREATEDB</literal>を使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term id="role-creation">role creation<indexterm><primary>role</primary><secondary>privilege to create</secondary></indexterm></term>
-->
      <term id="role-creation">ロールの作成<indexterm><primary>ロール</primary><secondary>作成する権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        A role must be explicitly given permission to create more roles
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEROLE</literal>.
        A role with <literal>CREATEROLE</literal> privilege can alter and drop
        roles which have been granted to the <literal>CREATEROLE</literal>
        user with the <literal>ADMIN</literal> option. Such a grant occurs
        automatically when a <literal>CREATEROLE</literal> user that is not
        a superuser creates a new role, so that by default, a
        <literal>CREATEROLE</literal> user can alter and drop the roles
        which they have created.
        Altering a role includes most changes that can be made using
        <literal>ALTER ROLE</literal>, including, for example, changing
        passwords.  It also includes modifications to a role that can
        be made using the <literal>COMMENT</literal> and
        <literal>SECURITY LABEL</literal> commands.
-->
あるロールがロールを作成するには、明示的な権限が付与されていなければなりません。
（スーパーユーザは、すべての権限検査を迂回しますので、例外です。）
こうしたロールを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> CREATEROLE</literal>を使用してください。
<literal>CREATEROLE</literal>権限を持つロールは、<literal>ADMIN</literal>オプションを持つ<literal>CREATEROLE</literal>ユーザのロールを変更したり削除したりすることもできます。
そのような権限付与は、スーパーユーザではない<literal>CREATEROLE</literal>ユーザが新しいロールを作った時に自動的に行われ、<literal>CREATEROLE</literal>ユーザが、作成したロールを変更したり削除できるようになります。
ロールの変更には、たとえばパスワードの変更などを含む、<literal>ALTER ROLE</literal>を使って実行できるほとんどの変更が含まれます。
また、<literal>COMMENT</literal>と<literal>SECURITY LABEL</literal>コマンドを使って実行できるロールの変更も含まれます。
       </para>
       <para>
<!--
        However, <literal>CREATEROLE</literal> does not convey the ability to
        create <literal>SUPERUSER</literal> roles, nor does it convey any
        power over <literal>SUPERUSER</literal> roles that already exist.
        Furthermore, <literal>CREATEROLE</literal> does not convey the power
        to create <literal>REPLICATION</literal> users, nor the ability to
        grant or revoke the <literal>REPLICATION</literal> privilege, nor the
        ability to modify the role properties of such users.  However, it does
        allow <literal>ALTER ROLE ... SET</literal> and
        <literal>ALTER ROLE ... RENAME</literal> to be used on
        <literal>REPLICATION</literal> roles, as well as the use of
        <literal>COMMENT ON ROLE</literal>,
        <literal>SECURITY LABEL ON ROLE</literal>,
        and <literal>DROP ROLE</literal>.
        Finally, <literal>CREATEROLE</literal> does not
        confer the ability to grant or revoke the <literal>BYPASSRLS</literal>
        privilege.
-->
しかし、<literal>CREATEROLE</literal>では、<literal>SUPERUSER</literal>ロールを作成する能力は移譲されませんし、既存の<literal>SUPERUSER</literal>ロールに対する権限も移譲されません。
さらに、<literal>CREATEROLE</literal>では、<literal>REPLICATION</literal>ユーザを作成する機能も、<literal>REPLICATION</literal>権限を付与または取り消す能力も、そのようなユーザのロール属性を変更する能力も移譲されません。
ただし、<literal>REPLICATION</literal>ロールでの<literal>ALTER ROLE ... SET</literal>および<literal>ALTER ROLE ... RENAME</literal>の使用、および<literal>COMMENT ON ROLE</literal>、<literal>SECURITY LABEL ON ROLE</literal>、<literal>DROP ROLE</literal>の使用は許可されます。
最後に、<literal>CREATEROLE</literal>では、<literal>BYPASSRLS</literal>権限を付与または取り消す能力は付与されません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>initiating replication<indexterm><primary>role</primary><secondary>privilege to initiate replication</secondary></indexterm></term>
-->
      <term>レプリケーションの新規接続<indexterm><primary>ロール</primary><secondary>レプリケーションの新規接続を行う権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        A role must explicitly be given permission to initiate streaming
        replication (except for superusers, since those bypass all permission
        checks). A role used for streaming replication must
        have <literal>LOGIN</literal> permission as well. To create such a role, use
        <literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION
        LOGIN</literal>.
-->
あるロールがストリーミングレプリケーションの新規接続を実施するには、明示的な権限が付与されていなければなりません。
（スーパーユーザは、すべての権限検査を迂回しますので、例外です。）
ストリーミングレプリケーションを行うロールは、<literal>LOGIN</literal>権限も持っていることが必要です。
こうしたロールを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION LOGIN</literal>を使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>password<indexterm><primary>password</primary></indexterm></term>
-->
      <term>パスワード<indexterm><primary>パスワード</primary></indexterm></term>
      <listitem>
       <para>
<!--
        A password is only significant if the client authentication
        method requires the user to supply a password when connecting
        to the database. The <option>password</option> and
        <option>md5</option> authentication methods
        make use of passwords. Database passwords are separate from
        operating system passwords. Specify a password upon role
        creation with <literal>CREATE ROLE
        <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>.
-->
パスワードは、クライアント認証方法においてデータベースに接続する際にユーザにパスワードを要求する場合にのみ重要になります。
<option>password</option>と<option>md5</option>認証方式でパスワードが使用されます。
データベースパスワードはオペレーティングシステムのパスワードとは異なります。
ロール作成時に<literal>CREATE ROLE <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>のようにパスワードを指定します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>inheritance of privileges<indexterm><primary>role</primary><secondary>privilege to inherit</secondary></indexterm></term>
-->
      <term>権限の継承<indexterm><primary>ロール</primary><secondary>継承する権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        A role inherits the privileges of roles it is a member of, by default.
        However, to create a role which does not inherit privileges by
        default, use <literal>CREATE ROLE <replaceable>name</replaceable>
        NOINHERIT</literal>.  Alternatively, inheritance can be overridden
        for individual grants by using <literal>WITH INHERIT TRUE</literal>
        or <literal>WITH INHERIT FALSE</literal>.
-->
ロールは、デフォルトでメンバであるロールの権限を継承します。
ただし、デフォルトで権限を継承しないロールを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> NOINHERIT</literal>を使用します。
別の方法として、<literal>WITH INHERIT TRUE</literal>、あるいは<literal>WITH INHERIT FALSE</literal>を使用して個々の権限の継承を上書きすることもできます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>bypassing row-level security<indexterm><primary>role</primary><secondary>privilege to bypass</secondary></indexterm></term>
-->
      <term>行単位セキュリティのバイパス<indexterm><primary>ロール</primary><secondary>バイパスする権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        A role must be explicitly given permission to bypass every row-level security (RLS) policy
        (except for superusers, since those bypass all permission checks).
        To create such a role, use <literal>CREATE ROLE <replaceable>name</replaceable> BYPASSRLS</literal> as a superuser.
-->
（全ての権限検査が行われないスーパーユーザを除き）ロールに明示的にすべての行単位セキュリティ(RLS)ポリシーをバイパスするための権限を指定しておかねばなりません。
そのようなロールを作るためには、スーパーユーザで<literal>CREATE ROLE <replaceable>name</replaceable> BYPASSRLS</literal>を使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>connection limit<indexterm><primary>role</primary><secondary>privilege to limit connection</secondary></indexterm></term>
-->
      <term>接続制限<indexterm><primary>ロール</primary><secondary>接続を制限する権限</secondary></indexterm></term>
      <listitem>
       <para>
<!--
        Connection limit can specify how many concurrent connections a role can make.
        -1 (the default) means no limit. Specify connection limit upon role creation with
        <literal>CREATE ROLE <replaceable>name</replaceable> CONNECTION LIMIT '<replaceable>integer</replaceable>'</literal>.
-->
接続制限では、ロールが作成できる同時接続数を指定できます。
-1(デフォルト)は制限なしを意味します。
<literal>CREATE ROLE <replaceable>name</replaceable> CONNECTION LIMIT '<replaceable>integer</replaceable>'</literal>でロール作成時に接続制限を指定します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    A role's attributes can be modified after creation with
    <command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</primary></indexterm>
    See the reference pages for the <xref linkend="sql-createrole"/>
    and <xref linkend="sql-alterrole"/> commands for details.
-->
ロール属性は、ロールを作成した後でも<command>ALTER ROLE</command><indexterm><primary>ALTER ROLE</primary></indexterm>コマンドで変更できます。
詳細は<xref linkend="sql-createrole"/>と<xref linkend="sql-alterrole"/>のマニュアルページを参照してください。
   </para>

  <para>
<!--
   A role can also have role-specific defaults for many of the run-time
   configuration settings described in <xref
   linkend="runtime-config"/>.  For example, if for some reason you
   want to disable index scans (hint: not a good idea) anytime you
   connect, you can use:
-->
ロールは、<xref linkend="runtime-config"/>で説明されている実行時の設定の多くをロールごとのデフォルトに設定することもできます。
例えば何らかの理由で、自分が接続する時は常にインデックススキャンを無効にしたい場合（注:お勧めしません）、次のようにします。
<programlisting>
ALTER ROLE myname SET enable_indexscan TO off;
</programlisting>
<!--
   This will save the setting (but not set it immediately).  In
   subsequent connections by this role it will appear as though
   <literal>SET enable_indexscan TO off</literal> had been executed
   just before the session started.
   You can still alter this setting during the session; it will only
   be the default. To remove a role-specific default setting, use
   <literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>.
   Note that role-specific defaults attached to roles without
   <literal>LOGIN</literal> privilege are fairly useless, since they will never
   be invoked.
-->
このようにして設定を保存します（ただし、すぐに反映はされません）。
以降のこのロールによる接続においては、セッションの開始の直前に<literal>SET enable_indexscan TO off;</literal>が呼び出されたのと同様になります。
これはデフォルトとする設定をするだけなので、設定をセッション途中いつでも変更できます。
ロール固有のデフォルト設定を削除するには、<literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>を使用してください。
呼び出されることがありませんので、<literal>LOGIN</literal>権限を持たないロールにロール固有のデフォルトを持たせることに意味がないことに注意してください。
  </para>

  <para>
<!--
   When a non-superuser creates a role using the <literal>CREATEROLE</literal>
   privilege, the created role is automatically granted back to the creating
   user, just as if the bootstrap superuser had executed the command
   <literal>GRANT created_user TO creating_user WITH ADMIN TRUE, SET FALSE,
   INHERIT FALSE</literal>. Since a <literal>CREATEROLE</literal> user can
   only exercise special privileges with regard to an existing role if they
   have <literal>ADMIN OPTION</literal> on it, this grant is just sufficient
   to allow a <literal>CREATEROLE</literal> user to administer the roles they
   created. However, because it is created with <literal>INHERIT FALSE, SET
   FALSE</literal>, the <literal>CREATEROLE</literal> user doesn't inherit the
   privileges of the created role, nor can it access the privileges of that
   role using <literal>SET ROLE</literal>. However, since any user who has
   <literal>ADMIN OPTION</literal> on a role can grant membership in that
   role to any other user, the <literal>CREATEROLE</literal> user can gain
   access to the created role by simply granting that role back to
   themselves with the <literal>INHERIT</literal> and/or <literal>SET</literal>
   options. Thus, the fact that privileges are not inherited by default nor
   is <literal>SET ROLE</literal> granted by default is a safeguard against
   accidents, not a security feature. Also note that, because this automatic
   grant is granted by the bootstrap superuser, it cannot be removed or changed by
   the <literal>CREATEROLE</literal> user; however, any superuser could
   revoke it, modify it, and/or issue additional such grants to other
   <literal>CREATEROLE</literal> users. Whichever <literal>CREATEROLE</literal>
   users have <literal>ADMIN OPTION</literal> on a role at any given time
   can administer it.
-->
《マッチ度[95.462280]》非スーパーユーザが<literal>CREATEROLE</literal>権限を使用してロールを作成すると、作成されたロールは自動的に作成元のユーザに再度付与されます。これは、ブートストラップスーパーユーザがコマンド<literal>GRANT created_user TO creating_user WITH ADMIN OPTION, SET FALSE, INHERIT FALSE</literal>を実行した場合と同じです。
<literal>CREATEROLE</literal>ユーザが、既存のロールに関して特別な権限を行使できるのは、そのロールに対する<literal>ADMIN OPTION</literal>権限がある場合のみですので、この権限は、<literal>CREATEROLE</literal>ユーザが作成したロールを管理するのに十分なだけです。
一方、<literal>INHERIT FALSE, SET FALSE</literal>で作成されたため、この<literal>CREATEROLE</literal>ユーザは作成されたロールの権限をデフォルトで継承していませんし、<literal>SET ROLE</literal>を使ってそのロールの権限にアクセスできません。
しかし、ロールに対する<literal>ADMIN OPTION</literal>を持つユーザは、そのロールのメンバシップを他のユーザに付与できるため、<literal>CREATEROLE</literal>ユーザは、そのロールを自分自身に<literal>INHERIT</literal>または<literal>SET</literal>オプションで付与するだけで、作成したロールへのアクセス権を獲得できます。
したがって、権限がデフォルトで継承されないこと、またはデフォルトで<literal>SET ROLE</literal>が付与されないことは、事故に対する安全策であり、セキュリティ機能ではありません。
また、この自動的な付与はブートストラップユーザによって与えられるため、<literal>CREATEROLE</literal>ユーザによって削除または変更することはできないことに注意してください。しかし、スーパーユーザはそれを取り消したり、修正したり、他の<literal>CREATEROLE</literal>ユーザに対してそのようなグラントを追加したりすることができます。
どの<literal>CREATEROLE</literal>ユーザも、ある時点でロールに対して<literal>ADMIN OPTION</literal>を持っているかどうかに関係なく、それを管理できます。
  </para>
 </sect1>

 <sect1 id="role-membership">
<!--
  <title>Role Membership</title>
-->
  <title>ロールのメンバ資格</title>

  <indexterm zone="role-membership">
   <primary>role</primary><secondary>membership in</secondary>
  </indexterm>
  <indexterm zone="role-membership">
   <primary>ロール</primary><secondary>内のメンバ資格</secondary>
  </indexterm>

  <para>
<!--
   It is frequently convenient to group users together to ease
   management of privileges: that way, privileges can be granted to, or
   revoked from, a group as a whole.  In <productname>PostgreSQL</productname>
   this is done by creating a role that represents the group, and then
   granting <firstterm>membership</firstterm> in the group role to individual user
   roles.
-->
権限の管理を簡単にするために、ユーザをグループにまとめることはしばしば便利です。
グループ全体に対して権限を与えることも、取り消すこともできます。
<productname>PostgreSQL</productname>では、グループを表すロールを作成することで行われます。
そして、そのグループロールに個々のユーザロールの<firstterm>メンバ資格</firstterm>を与えます。
  </para>

  <para>
<!--
   To set up a group role, first create the role:
-->
グループロールを設定するには、まずロールを作成します。
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   Typically a role being used as a group would not have the <literal>LOGIN</literal>
   attribute, though you can set it if you wish.
-->
通常、グループとして使用されるロールには<literal>LOGIN</literal>属性を持たせません。
しかし、そうしたければ持たせることもできます。
  </para>

  <para>
<!--
   Once the group role exists, you can add and remove members using the
   <link linkend="sql-grant"><command>GRANT</command></link> and
   <link linkend="sql-revoke"><command>REVOKE</command></link> commands:
-->
グループロールをいったん作成すれば、<link linkend="sql-grant"><command>GRANT</command></link>および<link linkend="sql-revoke"><command>REVOKE</command></link>コマンドを使用してメンバの追加と削除を行うことができます。
<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
<!--
   You can grant membership to other group roles, too (since there isn't
   really any distinction between group roles and non-group roles).  The
   database will not let you set up circular membership loops.  Also,
   it is not permitted to grant membership in a role to
   <literal>PUBLIC</literal>.
-->
他のグループロールへのメンバ資格を与えることもできます。
（グループロールと非グループロールとの間には実際には区別がないからです。）
データベースはグループのメンバ資格がループし、循環するような設定はさせません。
また、ロール内のメンバ資格を<literal>PUBLIC</literal>に付与することはできません。
  </para>

  <para>
<!--
   The members of a group role can use the privileges of the role in two
   ways.  First, member roles that have been granted membership with the
   <literal>SET</literal> option can do
   <link linkend="sql-set-role"><command>SET ROLE</command></link> to
   temporarily <quote>become</quote> the group role.  In this state, the
   database session has access to the privileges of the group role rather
   than the original login role, and any database objects created are
   considered owned by the group role not the login role.  Second, member
   roles that have been granted membership with the
   <literal>INHERIT</literal> option automatically have use of the
   privileges of those directly or indirectly a member of, though the
   chain stops at memberships lacking the inherit option.  As an example,
   suppose we have done:
-->
グループロールのメンバは、2つの方法でロールの権限を使用できます。
1つ目として、メンバ資格が<literal>SET</literal>オプションで付与されたメンバロールは、<link linkend="sql-set-role"><command>SET</command></link>オプションを使用して、一時的にグループロール<quote>になる</quote>ことができます。
この状態では、データベースセッションは、元のログインロールではなくグループロールの権限にアクセスでき、作成されたデータベースオブジェクトは、ログインロールではなくグループロールによって所有されているとみなされます。
2つ目として、<literal>INHERIT</literal>オプションでメンバ資格が付与されたメンバロールは、直接的または間接的にメンバであるメンバの権限を自動的に使用できます。ただし、この連鎖は継承オプションを持たないメンバ資格で停止します。
例えば、以下の状態を想定します。
<programlisting>
CREATE ROLE joe LOGIN;
CREATE ROLE admin;
CREATE ROLE wheel;
CREATE ROLE island;
GRANT admin TO joe WITH INHERIT TRUE;
GRANT wheel TO admin WITH INHERIT FALSE;
GRANT island TO joe WITH INHERIT TRUE, SET FALSE;
</programlisting>
<!--
   Immediately after connecting as role <literal>joe</literal>, a database
   session will have use of privileges granted directly to <literal>joe</literal>
   plus any privileges granted to <literal>admin</literal> and
   <literal>island</literal>, because <literal>joe</literal>
   <quote>inherits</quote> those privileges.  However, privileges
   granted to <literal>wheel</literal> are not available, because even though
   <literal>joe</literal> is indirectly a member of <literal>wheel</literal>, the
   membership is via <literal>admin</literal> which was granted using
   <literal>WITH INHERIT FALSE</literal>. After:
-->
ロール<literal>joe</literal>として接続した直後、データベースは<literal>joe</literal>に直接付与された権限に加えて、<literal>admin</literal>と<literal>island</literal>に付与された権限を<quote>継承</quote>するため、これらの権限を使用できます。
ただし、<literal>wheel</literal>に付与された権限は使用できません。これは、<literal>joe</literal>が間接的に<literal>wheel</literal>のメンバであるにもかかわらず、メンバシップは<literal>admin</literal>を介して付与され、<literal>WITH INHERIT FALSE</literal>を使用して付与されたためです。
<programlisting>
SET ROLE admin;
</programlisting>
<!--
   the session would have use of only those privileges granted to
   <literal>admin</literal>, and not those granted to <literal>joe</literal> or
   <literal>island</literal>.  After:
-->
を行った後、セッションは、<literal>admin</literal>に付与された権限のみを使用し、<literal>joe</literal>や<literal>island</literal>に付与された権限は使用しません。
<programlisting>
SET ROLE wheel;
</programlisting>
<!--
   the session would have use of only those privileges granted to
   <literal>wheel</literal>, and not those granted to either <literal>joe</literal>
   or <literal>admin</literal>.  The original privilege state can be restored
   with any of:
-->
を行った後、セッションは<literal>wheel</literal>に与えられた権限のみを使用できるようになり、<literal>joe</literal>や<literal>admin</literal>に与えられた権限は使用できなくなります。
元の状態の権限に戻すには、以下のいずれかを行います。
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>

  <note>
   <para>
<!--
    The <command>SET ROLE</command> command always allows selecting any role
    that the original login role is directly or indirectly a member of,
    provided that there is a chain of membership grants each of which has
    <literal>SET TRUE</literal> (which is the default).
    Thus, in the above example, it is not necessary to become
    <literal>admin</literal> before becoming <literal>wheel</literal>.
    On the other hand, it is not possible to become <literal>island</literal>
    at all; <literal>joe</literal> can only access those privileges via
    inheritance.
-->
メンバシップの許可の連鎖が存在し、それぞれが<literal>SET TRUE</literal>（デフォルトです）である場合、<command>SET ROLE</command>コマンドは、元のログインロールが直接的または間接的にメンバであるロールを常に選択できるようにします。
したがって、上記の例では、<literal>admin</literal>になる前に<literal>wheel</literal>になる必要はありません。
一方、<literal>island</literal>になることはできません。 <literal>joe</literal>は継承を介してのみこれらの権限にアクセスできます。
   </para>
  </note>

  <note>
   <para>
<!--
    In the SQL standard, there is a clear distinction between users and roles,
    and users do not automatically inherit privileges while roles do.  This
    behavior can be obtained in <productname>PostgreSQL</productname> by giving
    roles being used as SQL roles the <literal>INHERIT</literal> attribute, while
    giving roles being used as SQL users the <literal>NOINHERIT</literal> attribute.
    However, <productname>PostgreSQL</productname> defaults to giving all roles
    the <literal>INHERIT</literal> attribute, for backward compatibility with pre-8.1
    releases in which users always had use of permissions granted to groups
    they were members of.
-->
標準SQLでは、ユーザとロールとの間に明確な違いがあり、ユーザはロールのように自動的に権限を継承することができません。
<productname>PostgreSQL</productname>でこの振舞いを実現させるには、SQLロールとして使用するロールには<literal>INHERIT</literal>属性を付与し、SQLユーザとして使用するロールには<literal>NOINHERIT</literal>属性を付与します。
しかし、8.1リリースより前との互換性を保持するために、<productname>PostgreSQL</productname>はデフォルトで、すべてのロールに<literal>INHERIT</literal>属性を付与します。
以前は、ユーザは常にメンバとして属するグループに付与された権限を常に使用できました。
   </para>
  </note>

  <para>
<!--
   The role attributes <literal>LOGIN</literal>, <literal>SUPERUSER</literal>,
   <literal>CREATEDB</literal>, and <literal>CREATEROLE</literal> can be thought of as
   special privileges, but they are never inherited as ordinary privileges
   on database objects are.  You must actually <command>SET ROLE</command> to a
   specific role having one of these attributes in order to make use of
   the attribute.  Continuing the above example, we might choose to
   grant <literal>CREATEDB</literal> and <literal>CREATEROLE</literal> to the
   <literal>admin</literal> role.  Then a session connecting as role <literal>joe</literal>
   would not have these privileges immediately, only after doing
   <command>SET ROLE admin</command>.
-->
<literal>LOGIN</literal>、<literal>SUPERUSER</literal>、<literal>CREATEDB</literal>、および<literal>CREATEROLE</literal>ロール属性は、特別な権限とみなすことができますが、データベースオブジェクトに対する通常の権限のように継承されません。
こうした属性の1つを使用できるようにするためには、その属性を特定のロールに設定するように実際に<command>SET ROLE</command>を行う必要があります。
上の例を続けると、<literal>admin</literal>ロールに<literal>CREATEDB</literal>権限と<literal>CREATEROLE</literal>権限を付与することを選ぶことができます。
こうすると、<literal>joe</literal>ロールとして接続するセッションでは、すぐさまこれらの権限を持ちません。
<command>SET ROLE admin</command>を行った後で、この権限を持ちます。
  </para>

  <para>
  </para>

  <para>
<!--
   To destroy a group role, use <link
   linkend="sql-droprole"><command>DROP ROLE</command></link>:
-->
グループロールを削除するには、<link linkend="sql-droprole"><command>DROP ROLE</command></link>を使用してください。
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   Any memberships in the group role are automatically revoked (but the
   member roles are not otherwise affected).
-->
グループロール内のメンバ資格も自動的に取り上げられます。
（しかし、メンバロールには何も影響ありません。）
  </para>
 </sect1>

 <sect1 id="role-removal">
<!--
  <title>Dropping Roles</title>
-->
  <title>ロールの削除</title>

  <para>
<!--
   Because roles can own database objects and can hold privileges
   to access other objects, dropping a role is often not just a matter of a
   quick <link linkend="sql-droprole"><command>DROP ROLE</command></link>.  Any objects owned by the role must
   first be dropped or reassigned to other owners; and any permissions
   granted to the role must be revoked.
-->
ロールはデータベースオブジェクトを所有したり、他のオブジェクトにアクセスする権限を保持したりできるので、ロールを削除するのは、単に<link linkend="sql-droprole"><command>DROP ROLE</command></link>を実行すれば良いというだけのものでないことがよくあります。
そのロールが所有するすべてのオブジェクトについて、まずそれを削除するか、あるいは他の所有者に移すかしなければなりません。
また、そのロールに付与されたすべての権限を取り上げる必要があります。
  </para>

  <para>
<!--
   Ownership of objects can be transferred one at a time
   using <command>ALTER</command> commands, for example:
-->
オブジェクトの所有権は<command>ALTER</command>コマンドを使って、1度に1つずつ移管することができます。
以下に例を示します。
<programlisting>
ALTER TABLE bobs_table OWNER TO alice;
</programlisting>
<!--
   Alternatively, the <link linkend="sql-reassign-owned"><command>REASSIGN OWNED</command></link> command can be
   used to reassign ownership of all objects owned by the role-to-be-dropped
   to a single other role.  Because <command>REASSIGN OWNED</command> cannot access
   objects in other databases, it is necessary to run it in each database
   that contains objects owned by the role.  (Note that the first
   such <command>REASSIGN OWNED</command> will change the ownership of any
   shared-across-databases objects, that is databases or tablespaces, that
   are owned by the role-to-be-dropped.)
-->
その代わりに<link linkend="sql-reassign-owned"><command>REASSIGN OWNED</command></link>コマンドを使って、削除予定のロールが所有するすべてのオブジェクトの所有権を、単一の他のロールに移管することもできます。
<command>REASSIGN OWNED</command>は他のデータベースのオブジェクトにはアクセスできないので、そのロールが所有するオブジェクトを含むそれぞれのデータベース内で実行する必要があります。
（最初にそのような<command>REASSIGN OWNED</command>を実行した時に、データベース間で共有されるオブジェクト、つまりデータベースとテーブル空間については、すべて削除予定のロールから所有権が変更されることに注意してください。）
  </para>

  <para>
<!--
   Once any valuable objects have been transferred to new owners, any
   remaining objects owned by the role-to-be-dropped can be dropped with
   the <link linkend="sql-drop-owned"><command>DROP OWNED</command></link> command.  Again, this command cannot
   access objects in other databases, so it is necessary to run it in each
   database that contains objects owned by the role.  Also, <command>DROP
   OWNED</command> will not drop entire databases or tablespaces, so it is
   necessary to do that manually if the role owns any databases or
   tablespaces that have not been transferred to new owners.
-->
重要なオブジェクトがすべて新しい所有者に移管された後は、削除予定のロールが所有する残りのオブジェクトはすべて<link linkend="sql-drop-owned"><command>DROP OWNED</command></link> commandコマンドで削除することができます。
ここでも、このコマンドは他のデータベースのオブジェクトにはアクセスできないので、そのロールが所有するオブジェクトを含むそれぞれのデータベース内で実行する必要があります。
また、<command>DROP OWNED</command>はデータベース全体、あるいはテーブル空間全体を削除することはありませんので、ロールが所有するデータベースあるいはテーブル空間で新しい所有者に移管されていないものがあれば、手作業でそれを削除する必要があります。
  </para>

  <para>
<!--
   <command>DROP OWNED</command> also takes care of removing any privileges granted
   to the target role for objects that do not belong to it.
   Because <command>REASSIGN OWNED</command> does not touch such objects, it's
   typically necessary to run both <command>REASSIGN OWNED</command>
   and <command>DROP OWNED</command> (in that order!) to fully remove the
   dependencies of a role to be dropped.
-->
<command>DROP OWNED</command>は対象のロールが所有しないオブジェクトについて、そのロールに付与されたすべての権限を削除することも行います。
<command>REASSIGN OWNED</command>はそのようなオブジェクトに関与しないので、削除されるロールによる依存関係を完全に取り除くには、多くの場合、<command>REASSIGN OWNED</command>と<command>DROP OWNED</command>の両方を（この順序で！）実行する必要があります。
  </para>

  <para>
<!--
   In short then, the most general recipe for removing a role that has been
   used to own objects is:
-->
まとめると、オブジェクトを所有するために使用されたロールを削除する最も一般的な手順は以下のようになります。
  </para>
<programlisting>
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
<!--
&#45;- repeat the above commands in each database of the cluster
-->
-- 上記のコマンドをクラスタ内の各データベースについて繰り返す
DROP ROLE doomed_role;
</programlisting>

  <para>
<!--
   When not all owned objects are to be transferred to the same successor
   owner, it's best to handle the exceptions manually and then perform
   the above steps to mop up.
-->
すべての所有オブジェクトを同一の後継所有者に移管するのでない場合は、例外部分を手作業で処理した後で、上記の手順を実行して残りを処理するのが最善でしょう。
  </para>

  <para>
<!--
   If <command>DROP ROLE</command> is attempted while dependent objects still
   remain, it will issue messages identifying which objects need to be
   reassigned or dropped.
-->
依存するオブジェクトがまだ残っている状態で<command>DROP ROLE</command>を実行すると、どのオブジェクトが所有者変更または削除の必要があるかを特定するメッセージが発行されます。
  </para>
 </sect1>

 <sect1 id="predefined-roles">
<!--
  <title>Predefined Roles</title>
-->
  <title>定義済みロール</title>

  <indexterm zone="predefined-roles">
   <primary>role</primary>
  </indexterm>
  <indexterm zone="predefined-roles">
   <primary>ロール</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides a set of predefined roles
   that provide access to certain, commonly needed, privileged capabilities
   and information.  Administrators (including roles that have the
   <literal>CREATEROLE</literal> privilege) can <command>GRANT</command> these
   roles to users and/or other roles in their environment, providing those
   users with access to the specified capabilities and information.
-->
<productname>PostgreSQL</productname>では、ある種の共通に必要で、特権のある機能や情報にアクセスできるよう、いくつかのあらかじめ定義されたロールを提供しています。
(<literal>CREATEROLE</literal>権限を持つロールを含む)管理者は自分の環境のユーザあるいはロールに対し、これらのロールを<command>GRANT</command>(付与)することで、それらのユーザに、その機能や情報を提供することができます。
  </para>

  <para>
<!--
   The predefined roles are described in <xref linkend="predefined-roles-table"/>.
   Note that the specific permissions for each of the roles may change in
   the future as additional capabilities are added.  Administrators
   should monitor the release notes for changes.
-->
定義済みロールについては<xref linkend="predefined-roles-table"/>で説明します。
それぞれのロールの個別の権限については、将来、さらなる機能が追加されるに連れて変更されるかもしれないことに注意してください。
管理者は、変更がないかリリースノートを確認するようにしてください。
  </para>

   <table tocentry="1" id="predefined-roles-table">
<!--
    <title>Predefined Roles</title>
-->
    <title>定義済みロール</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
      <row>
<!--
       <entry>Role</entry>
       <entry>Allowed Access</entry>
-->
       <entry>ロール</entry>
       <entry>可能なアクセス</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>pg_read_all_data</entry>
<!--
       <entry>Read all data (tables, views, sequences), as if having
       <command>SELECT</command> rights on those objects, and USAGE rights on
       all schemas, even without having it explicitly.  This role does not have
       the role attribute <literal>BYPASSRLS</literal> set.  If RLS is being
       used, an administrator may wish to set <literal>BYPASSRLS</literal> on
       roles which this role is GRANTed to.</entry>
-->
       <entry>
それらのオブジェクトに対する<command>SELECT</command>権限を持っていて、明示的に持っていなかったとしてもすべてのスキーマに対してUSAGE権限を持っているかのように、すべてのデータ(テーブル、ビュー、シーケンス)を読み取る。
このロールにはロール属性<literal>BYPASSRLS</literal>は設定されていません。
RLSが使われているのであれば、管理者はこのロールがGRANTされるロールに対して<literal>BYPASSRLS</literal>を設定したいと思うかもしれません。
       </entry>
      </row>
      <row>
       <entry>pg_write_all_data</entry>
<!--
       <entry>Write all data (tables, views, sequences), as if having
       <command>INSERT</command>, <command>UPDATE</command>, and
       <command>DELETE</command> rights on those objects, and USAGE rights on
       all schemas, even without having it explicitly.  This role does not have
       the role attribute <literal>BYPASSRLS</literal> set.  If RLS is being
       used, an administrator may wish to set <literal>BYPASSRLS</literal> on
       roles which this role is GRANTed to.</entry>
-->
       <entry>
それらのオブジェクトに対する<command>INSERT</command>、<command>UPDATE</command>および<command>DELETE</command>権限を持っていて、明示的に持っていなかったとしてもすべてのスキーマに対してUSAGE権限を持っているかのように、すべてのデータ(テーブル、ビュー、シーケンス)に書き込む。
このロールにはロール属性<literal>BYPASSRLS</literal>は設定されていません。
RLSが使われているのであれば、管理者はこのロールがGRANTされるロールに対して<literal>BYPASSRLS</literal>を設定したいと思うかもしれません。
       </entry>
      </row>
      <row>
       <entry>pg_read_all_settings</entry>
<!--
       <entry>Read all configuration variables, even those normally visible only to
       superusers.</entry>
-->
       <entry>通常スーパーユーザのみが読み取れる、全ての設定変数を読み取る</entry>
      </row>
      <row>
       <entry>pg_read_all_stats</entry>
<!--
       <entry>Read all pg_stat_* views and use various statistics related extensions,
       even those normally visible only to superusers.</entry>
-->
       <entry>通常スーパーユーザのみが読み取れる、すべてのpg_stat_*ビューを読み取り、各種の統計関連のエクステンションを使用する</entry>
      </row>
      <row>
       <entry>pg_stat_scan_tables</entry>
<!--
       <entry>Execute monitoring functions that may take <literal>ACCESS SHARE</literal> locks on tables,
       potentially for a long time.</entry>
-->
       <entry>潜在的に長時間、テーブルの<literal>ACCESS SHARE</literal>ロックを取得する可能性がある監視機能を実行する</entry>
      </row>
      <row>
       <entry>pg_monitor</entry>
<!--
       <entry>Read/execute various monitoring views and functions.
       This role is a member of <literal>pg_read_all_settings</literal>,
       <literal>pg_read_all_stats</literal> and
       <literal>pg_stat_scan_tables</literal>.</entry>
-->
       <entry>各種の監視ビューや機能を読み取り/実行する。
       このロールは、<literal>pg_read_all_settings</literal>、<literal>pg_read_all_stats</literal>および<literal>pg_stat_scan_tables</literal>のメンバです。</entry>
      </row>
      <row>
       <entry>pg_database_owner</entry>
<!--
       <entry>None.  Membership consists, implicitly, of the current database owner.</entry>
-->
       <entry>なし。メンバ資格は暗黙に現在のデータベースの所有者から構成されます。</entry>
      </row>
      <row>
       <entry>pg_signal_backend</entry>
<!--
       <entry>Signal another backend to cancel a query or terminate its session.</entry>
-->
       <entry>他のバックエンドに問い合わせのキャンセルやセッションの終了のシグナルを送信する</entry>
      </row>
      <row>
       <entry>pg_read_server_files</entry>
<!--
       <entry>Allow reading files from any location the database can access on the server with COPY and
       other file-access functions.</entry>
-->
       <entry>COPYやその他のファイルアクセス関数で、データベースがサーバ上でアクセスできる任意の場所からファイルを読み取ることを許可する</entry>
      </row>
      <row>
       <entry>pg_write_server_files</entry>
<!--
       <entry>Allow writing to files in any location the database can access on the server with COPY and
       other file-access functions.</entry>
-->
       <entry>COPYやその他のファイルアクセス関数で、データベースがサーバ上でアクセスできる任意の場所にファイルを書き込むことを許可する</entry>
      </row>
      <row>
       <entry>pg_execute_server_program</entry>
<!--
       <entry>Allow executing programs on the database server as the user the database runs as with
       COPY and other functions which allow executing a server-side program.</entry>
-->
       <entry>COPYやサーバ側のプログラムを実行できるその他の関数で、データベースを実行しているユーザとしてデータベースサーバ上でのプログラムの実行を許可する</entry>
      </row>
      <row>
       <entry>pg_checkpoint</entry>
<!--
       <entry>Allow executing
       the <link linkend="sql-checkpoint"><command>CHECKPOINT</command></link>
       command.</entry>
-->
       <entry><link linkend="sql-checkpoint"><command>CHECKPOINT</command></link>コマンドの実行を許可する</entry>
      </row>
      <row>
       <entry>pg_maintain</entry>
       <entry>Allow executing
       <link linkend="sql-vacuum"><command>VACUUM</command></link>,
       <link linkend="sql-analyze"><command>ANALYZE</command></link>,
       <link linkend="sql-cluster"><command>CLUSTER</command></link>,
       <link linkend="sql-refreshmaterializedview"><command>REFRESH MATERIALIZED VIEW</command></link>,
       <link linkend="sql-reindex"><command>REINDEX</command></link>,
       and <link linkend="sql-lock"><command>LOCK TABLE</command></link> on all
       relations, as if having <literal>MAINTAIN</literal> rights on those
       objects, even without having it explicitly.</entry>
      </row>
      <row>
       <entry>pg_use_reserved_connections</entry>
<!--
       <entry>Allow use of connection slots reserved via
       <xref linkend="guc-reserved-connections"/>.</entry>
-->
       <entry><xref linkend="guc-reserved-connections"/>によって予約済みの接続スロットの使用を許可する
       </entry>
      </row>
      <row>
       <entry>pg_create_subscription</entry>
<!--
       <entry>Allow users with <literal>CREATE</literal> permission on the
       database to issue
       <link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link>.</entry>
-->
       <entry>
        <link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link>を実行するために、ユーザに対してデータベースへの<literal>CREATE</literal>権限を許可する
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
  The <literal>pg_monitor</literal>, <literal>pg_read_all_settings</literal>,
  <literal>pg_read_all_stats</literal> and <literal>pg_stat_scan_tables</literal>
  roles are intended to allow administrators to easily configure a role for the
  purpose of monitoring the database server. They grant a set of common privileges
  allowing the role to read various useful configuration settings, statistics and
  other system information normally restricted to superusers.
-->
  <literal>pg_monitor</literal>、<literal>pg_read_all_settings</literal>、<literal>pg_read_all_stats</literal>および<literal>pg_stat_scan_tables</literal>ロールは、データベースサーバを監視するためのロールを、管理者が簡単に設定できるようにする目的があります。
  これらのロールは通常スーパーユーザに限定されている各種の有用な構成設定、統計情報およびその他のシステム情報を読むことができる一般的な権限のセットを与えることができます。
  </para>

  <para>
<!--
  The <literal>pg_database_owner</literal> role has one implicit,
  situation-dependent member, namely the owner of the current database.  Like
  any role, it can own objects or receive grants of access privileges.
  Consequently, once <literal>pg_database_owner</literal> has rights within a
  template database, each owner of a database instantiated from that template
  will exercise those rights.  <literal>pg_database_owner</literal> cannot be
  a member of any role, and it cannot have non-implicit members.  Initially,
  this role owns the <literal>public</literal> schema, so each database owner
  governs local use of the schema.
-->
<literal>pg_database_owner</literal>ロールには暗黙で状況に依存したメンバが1つあります。すなわち、現在のデータベースの所有者です。
他のロールと同様に、オブジェクトを所有したり、アクセス権限の許可を受けたりすることができます。
したがって、<literal>pg_database_owner</literal>がテンプレートデータベース内で権限を一度持てば、そのテンプレートから作成されたデータベースの所有者は皆、その権限を行使します。
<literal>pg_database_owner</literal>は他のロールのメンバにはなれませんし、暗黙でないメンバも持てません。
最初に、このロールは<literal>public</literal>スキーマを所有していますので、各データベース所有者はそのスキーマのローカルでの利用を管理します。
  </para>

  <para>
<!--
  The <literal>pg_signal_backend</literal> role is intended to allow
  administrators to enable trusted, but non-superuser, roles to send signals
  to other backends. Currently this role enables sending of signals for
  canceling a query on another backend or terminating its session. A user
  granted this role cannot however send signals to a backend owned by a
  superuser.  See <xref linkend="functions-admin-signal"/>.
-->
<literal>pg_signal_backend</literal>ロールは、信頼はできるが非スーパーユーザであるロールが他のバックエンドにシグナルを送信することを、管理者が許可できるようにすることを意図しています。
今のところ、このロールは他のバックエンドでの問い合わせをキャンセルしたり、セッションを終了するシグナルを送信できます。
しかしながら、このロールの権限を与えられたユーザは、スーパーユーザが所有するバックエンドにシグナルを送信できません。
<xref linkend="functions-admin-signal"/>を参照してください。
  </para>

  <para>
<!--
  The <literal>pg_read_server_files</literal>, <literal>pg_write_server_files</literal> and
  <literal>pg_execute_server_program</literal> roles are intended to allow administrators to have
  trusted, but non-superuser, roles which are able to access files and run programs on the
  database server as the user the database runs as.  As these roles are able to access any file on
  the server file system, they bypass all database-level permission checks when accessing files
  directly and they could be used to gain superuser-level access, therefore
  great care should be taken when granting these roles to users.
-->
<literal>pg_read_server_files</literal>、<literal>pg_write_server_files</literal>、<literal>pg_execute_server_program</literal>ロールは、信頼はできるが非スーパーユーザであるロールがデータベースを実行しているユーザとしてデータベースサーバ上でファイルにアクセスしたりプログラムを実行したりすることを、管理者が許可できるようにすること意図しています。
これらのロールはサーバファイルシステムの任意のファイルにアクセスできますので、ファイルに直接アクセスする時にはデータベースレベルの権限検査はすべて行なわれず、スーパーユーザレベルのアクセスを得るのに使えます。ですので、これらのロールをユーザに許可する時には注意すべきです。
  </para>

  <para>
<!--
  Care should be taken when granting these roles to ensure they are only used where
  needed and with the understanding that these roles grant access to privileged
  information.
-->
これらのロールを許可する場合は、必要な場合にのみ、これらのロールは機密情報へのアクセス権を与えることを理解して、使用されるように注意する必要があります。
  </para>

  <para>
<!--
   Administrators can grant access to these roles to users using the
   <link linkend="sql-grant"><command>GRANT</command></link> command, for example:
-->
管理者は<link linkend="sql-grant"><command>GRANT</command></link>コマンドを使って、ユーザにこれらのロールへのアクセスを許可できます。例えば、

<programlisting>
GRANT pg_signal_backend TO admin_user;
</programlisting>
  </para>

 </sect1>

 <sect1 id="perm-functions">
<!--
  <title>Function Security</title>
-->
  <title>関数のセキュリティ</title>

  <para>
<!--
   Functions, triggers and row-level security policies allow users to insert
   code into the backend server that other users might execute
   unintentionally. Hence, these mechanisms permit users to <quote>Trojan
   horse</quote> others with relative ease. The strongest protection is tight
   control over who can define objects. Where that is infeasible, write
   queries referring only to objects having trusted owners.  Remove
   from <varname>search_path</varname> any schemas that permit untrusted users
   to create objects.
-->
関数やトリガや行単位セキュリティポリシーによって、ユーザは他のユーザが意識しないで実行できるようなコードを、バックエンドサーバに挿入することができます。
したがって、これらの機能によってユーザは比較的簡単に他のユーザにとって<quote>トロイの木馬</quote>となるものを実行することができます。
最も強力な保護は、誰がオブジェクトを定義できるかを厳格に管理することです。
それが実行不可能な場合は、信頼できる所有者を持つオブジェクトのみを参照する問い合わせを記述します。
<varname>search_path</varname>から、信頼できないユーザがオブジェクトを作成できるスキーマを削除します。
  </para>

  <para>
<!--
   Functions run inside the backend
   server process with the operating system permissions of the
   database server daemon.  If the programming language
   used for the function allows unchecked memory accesses, it is
   possible to change the server's internal data structures.
   Hence, among many other things, such functions can circumvent any
   system access controls.  Function languages that allow such access
   are considered <quote>untrusted</quote>, and
   <productname>PostgreSQL</productname> allows only superusers to
   create functions written in those languages.
-->
関数は、データベースサーバデーモンのオペレーティングシステム権限で、バックエンドサーバプロセスの中で実行されます。
プログラミング言語で関数に未検査のメモリアクセスを許可している場合、サーバの内部データ構造を変更することが可能です。
したがって、その他の多数のことの中でも、そのような関数はどのようなシステムアクセスコントロールも回避することができます。
このようなアクセスを許可する関数言語は<quote>信頼されない</quote>ものとみなされ、<productname>PostgreSQL</productname>はこれらの言語による関数の作成をスーパーユーザのみに限定して許可しています。
  </para>
 </sect1>

</chapter>
