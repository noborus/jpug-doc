<!-- doc/src/sgml/btree.sgml -->

<sect1 id="btree">
<!--
<title>B-Tree Indexes</title>
-->
<title>B-Treeインデックス</title>

   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>
   <indexterm>
    <primary>インデックス</primary>
    <secondary>B-Tree</secondary>
   </indexterm>

<sect2 id="btree-intro">
<!--
 <title>Introduction</title>
-->
 <title>はじめに</title>

 <para>
<!--
  <productname>PostgreSQL</productname> includes an implementation of the
  standard <acronym>btree</acronym> (multi-way balanced tree) index data
  structure.  Any data type that can be sorted into a well-defined linear
  order can be indexed by a btree index.  The only limitation is that an
  index entry cannot exceed approximately one-third of a page (after TOAST
  compression, if applicable).
-->
<productname>PostgreSQL</productname>は、標準的な<acronym>btree</acronym>（multi-way balanced tree）インデックスデータ構造を実装しています。
明確に定義された線形順にソート可能なデータ型は、すべてbtreeインデックスで索引付できます。
唯一の制限は、一つのインデックスエントリが（適用可能であれば、TOAST圧縮後）ページの約1/3を超えられないことです。
 </para>

 <para>
<!--
  Because each btree operator class imposes a sort order on its data type,
  btree operator classes (or, really, operator families) have come to be
  used as <productname>PostgreSQL</productname>'s general representation
  and understanding of sorting semantics.  Therefore, they've acquired
  some features that go beyond what would be needed just to support btree
  indexes, and parts of the system that are quite distant from the
  btree <acronym>AM</acronym> make use of them.
-->
btree演算子クラスはそのデータ型がソート順を持つことが必要なので、btree演算子クラス（実際には演算子族）は、<productname>PostgreSQL</productname>の一般的表現として、およびソートセマンティクスを理解するものとして利用されてきました。
ですから、単にbtreeインデックスをサポートするだけに必要なもの以上の機能と、btree <acronym>AM</acronym>が使用するものからはかけ離れたシステムの部品を備えなければなりません。
 </para>

</sect2>

<sect2 id="btree-behavior">
<!--
 <title>Behavior of B-Tree Operator Classes</title>
-->
 <title>B-Tree演算子クラスの振る舞い</title>

 <para>
<!--
  As shown in <xref linkend="xindex-btree-strat-table"/>, a btree operator
  class must provide five comparison operators,
  <literal>&lt;</literal>,
  <literal>&lt;=</literal>,
  <literal>=</literal>,
  <literal>&gt;=</literal> and
  <literal>&gt;</literal>.
  One might expect that <literal>&lt;&gt;</literal> should also be part of
  the operator class, but it is not, because it would almost never be
  useful to use a <literal>&lt;&gt;</literal> WHERE clause in an index
  search.  (For some purposes, the planner treats <literal>&lt;&gt;</literal>
  as associated with a btree operator class; but it finds that operator via
  the <literal>=</literal> operator's negator link, rather than
  from <structname>pg_amop</structname>.)
-->
<xref linkend="xindex-btree-strat-table"/>で示すように、btree演算子クラスは次の5つの比較演算子を提供しなければなりません。
<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、<literal>&gt;=</literal>、そして<literal>&gt;</literal>です。
<literal>&lt;&gt;</literal>も演算子クラスの一部であると期待する方もいるかもしれませんが、そうではありません。
インデックス検索のWHERE句で<literal>&lt;&gt;</literal>を使うのは、ほとんど常に役に立たないからです。
（ある種の目的のためにプランナは<literal>&lt;&gt;</literal>をbtree演算子クラスに関連しているものとして扱います。
しかし、プランナは<structname>pg_amop</structname>から検索するのではなく<literal>=</literal>の否定子リンクから検索します。）
 </para>

 <para>
<!--
  When several data types share near-identical sorting semantics, their
  operator classes can be grouped into an operator family.  Doing so is
  advantageous because it allows the planner to make deductions about
  cross-type comparisons.  Each operator class within the family should
  contain the single-type operators (and associated support functions)
  for its input data type, while cross-type comparison operators and
  support functions are <quote>loose</quote> in the family.  It is
  recommendable that a complete set of cross-type operators be included
  in the family, thus ensuring that the planner can represent any
  comparison conditions that it deduces from transitivity.
-->
複数のデータ型がほとんど同じソートセマンティクスを共有している場合、それらの演算子クラスは演算子族にまとめることができます。
そうすることによりプランナが型をまたがる比較を推論できるので、これはメリットがあります。
演算子族内の各演算子クラスは、入力データ型のための単一型演算子（および関連するサポート関数）を含むべきです。
一方型をまたがる比較演算子とサポート関数は演算子族中で<quote>ゆるやか</quote>です。
プランナが推移関係から推論するすべての比較条件を提示できるように、型をまたがる演算子の完全な集合を演算子族に入れておくことをお勧めします。
 </para>

 <para>
<!--
  There are some basic assumptions that a btree operator family must
  satisfy:
-->
btree演算子族が満たさなければならない基本的な前提条件があります。
 </para>

 <itemizedlist>
  <listitem>
   <para>
<!--
    An <literal>=</literal> operator must be an equivalence relation; that
    is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable> of the
    data type:
-->
<literal>=</literal>演算子は等号関係でなければなりません。
つまり、そのデータ型のすべての非NULL値<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>について、

    <itemizedlist>
     <listitem>
      <para>
<!--
       <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>reflexive law</firstterm>)
-->
<replaceable>A</replaceable> <literal>=</literal> <replaceable>A</replaceable>が真である（<firstterm>反射律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable>,
       then <replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>
       (<firstterm>symmetric law</firstterm>)
-->
<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>なら、<replaceable>B</replaceable> <literal>=</literal> <replaceable>A</replaceable>である（<firstterm>対称律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable> and <replaceable>B</replaceable>
       <literal>=</literal> <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
-->
<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>かつ<replaceable>B</replaceable><literal>=</literal> <replaceable>C</replaceable>なら、<replaceable>A</replaceable> <literal>=</literal> <replaceable>C</replaceable>である（<firstterm>推移律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
<!--
    A <literal>&lt;</literal> operator must be a strong ordering relation;
    that is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable>:
-->
<literal>&lt;</literal>は強順序関係でなければなりません。つまり、すべての非NULL値<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>に対して、

    <itemizedlist>
     <listitem>
      <para>
<!--
       <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is false
       (<firstterm>irreflexive law</firstterm>)
-->
<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>は偽である（<firstterm>非反射律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       if <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>
       and <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
-->
<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>かつ<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>なら、<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>である（<firstterm>推移律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
<!--
    Furthermore, the ordering is total; that is, for all non-null
    values <replaceable>A</replaceable>, <replaceable>B</replaceable>:
-->
更に、順序は全である。すなわち、すべての非NULL値<replaceable>A</replaceable>、<replaceable>B</replaceable>に対して、

    <itemizedlist>
     <listitem>
      <para>
<!--
       exactly one of <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>, <replaceable>A</replaceable>
       <literal>=</literal> <replaceable>B</replaceable>, and
       <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>trichotomy law</firstterm>)
-->
厳密に<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>、<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>のうちどれか一つが真（<firstterm>三分律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>

<!--
    (The trichotomy law justifies the definition of the comparison support
    function, of course.)
-->
（もちろん、三分律は比較サポート関数の定義を正当化します。）
   </para>
  </listitem>
 </itemizedlist>

 <para>
<!--
  The other three operators are defined in terms of <literal>=</literal>
  and <literal>&lt;</literal> in the obvious way, and must act consistently
  with them.
-->
他の3つの演算子は<literal>=</literal>と<literal>&lt;</literal>に沿って自明に定義され、それらと一貫していなければなりません。
 </para>

 <para>
<!--
  For an operator family supporting multiple data types, the above laws must
  hold when <replaceable>A</replaceable>, <replaceable>B</replaceable>,
  <replaceable>C</replaceable> are taken from any data types in the family.
  The transitive laws are the trickiest to ensure, as in cross-type
  situations they represent statements that the behaviors of two or three
  different operators are consistent.
  As an example, it would not work to put <type>float8</type>
  and <type>numeric</type> into the same operator family, at least not with
  the current semantics that <type>numeric</type> values are converted
  to <type>float8</type> for comparison to a <type>float8</type>.  Because
  of the limited accuracy of <type>float8</type>, this means there are
  distinct <type>numeric</type> values that will compare equal to the
  same <type>float8</type> value, and thus the transitive law would fail.
-->
複数のデータ型をサポートする演算子族について、演算子族中のデータ型であるどんな<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>も上記の法則を満たさなければなりません。
型をまたがる際に2つあるいは3つの異なる演算子が一貫していることを表明することになるので、推移律を満たすことはもっとも困難です。
例をあげると、少なくとも<type>float8</type>と比較するために<type>numeric</type>値を<type>float8</type>に変換する現在の意味論のもとでは、<type>float8</type>と<type>numeric</type>を同じ演算子族に加えるのはうまくいかないでしょう。
<type>float8</type>の精度に限りがあるからです。
これは同じ<type>float8</type>値に対して等号比較する複数の異なる<type>numeric</type>値が存在することを意味し、したがって推移律は満たされません。
 </para>

 <para>
<!--
  Another requirement for a multiple-data-type family is that any implicit
  or binary-coercion casts that are defined between data types included in
  the operator family must not change the associated sort ordering.
-->
複数データ型族に関する別な要件は、演算子族に含まれるデータ型間に定義される暗黙的あるいは二値型強制(binary-coercion)キャストは、関係するソート順を変更してはならないことです。
 </para>

 <para>
<!--
  It should be fairly clear why a btree index requires these laws to hold
  within a single data type: without them there is no ordering to arrange
  the keys with.  Also, index searches using a comparison key of a
  different data type require comparisons to behave sanely across two
  data types.  The extensions to three or more data types within a family
  are not strictly required by the btree index mechanism itself, but the
  planner relies on them for optimization purposes.
-->
単一のデータ型において、btreeインデックスがこれらの法則を守ることを要求するのはかなり明確です。
これらの法則なしにはキー並べる順序がなくなってしまうからです。
また、異なるデータ型の比較キーを使うインデックス検索では、2つのデータ型またがる比較が正常に動作することが必要です。
演算子族中で3つ以上のデータ型に対する拡張はbtreeインデックスの機構自体では要求されませんが、プランナは最適化の目的でそれらに依存します。
 </para>

</sect2>

<sect2 id="btree-support-funcs">
<!--
 <title>B-Tree Support Functions</title>
-->
 <title>B-Treeサポート関数</title>

 <para>
<!--
  As shown in <xref linkend="xindex-btree-support-table"/>, btree defines
  one required and four optional support functions.  The five
  user-defined methods are:
-->
<xref linkend="xindex-btree-support-table"/>で示すように、btreeでは一つの必須サポート関数と、4つの省略可能なサポート関数を定義します。
5つのユーザ定義メソッドは以下の通りです。
 </para>
 <variablelist>
  <varlistentry>
   <term><function>order</function></term>
   <listitem>
    <para>
<!--
     For each combination of data types that a btree operator family
     provides comparison operators for, it must provide a comparison
     support function, registered in
     <structname>pg_amproc</structname> with support function number 1
     and
     <structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>
     equal to the left and right data types for the comparison (i.e.,
     the same data types that the matching operators are registered
     with in <structname>pg_amop</structname>).  The comparison
     function must take two non-null values
     <replaceable>A</replaceable> and <replaceable>B</replaceable> and
     return an <type>int32</type> value that is
     <literal>&lt;</literal> <literal>0</literal>,
     <literal>0</literal>, or <literal>&gt;</literal>
     <literal>0</literal> when <replaceable>A</replaceable>
     <literal>&lt;</literal> <replaceable>B</replaceable>,
     <replaceable>A</replaceable> <literal>=</literal>
     <replaceable>B</replaceable>, or <replaceable>A</replaceable>
     <literal>&gt;</literal> <replaceable>B</replaceable>,
     respectively.  A null result is disallowed: all values of the
     data type must be comparable.  See
     <filename>src/backend/access/nbtree/nbtcompare.c</filename> for
     examples.
-->
btreeの演算子族が比較演算子を提供する各データ型の組み合わせに対して、比較サポート関数を提供しなければなりません。それらはサポート関数1番で<structname>pg_amproc</structname>に、また、比較での左右のデータ型と等しい<structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>に、登録されます（すなわち、<structname>pg_amop</structname>に登録されている演算子が対応するものと同じデータ型です）。
比較関数は2つの非NULL値<replaceable>A</replaceable>と<replaceable>B</replaceable>を取り、
<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>、または、<replaceable>A</replaceable> <literal>&gt;</literal> <replaceable>B</replaceable>であるときにそれぞれ、<literal>&lt;</literal> <literal>0</literal>、<literal>0</literal>、または、<literal>&gt;</literal> <literal>0</literal>である<type>int32</type>の値を返さなければなりません。
NULLの結果は許されず、データ型の全ての値は比較可能でなければなりません。
例として<filename>src/backend/access/nbtree/nbtcompare.c</filename>を参照してください。
    </para>

    <para>
<!--
     If the compared values are of a collatable data type, the
     appropriate collation OID will be passed to the comparison
     support function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
-->
比較される値が照合順序が適用可能なデータ型のものである場合、比較サポート関数に適切な照合順序のOIDが渡され、標準の<function>PG_GET_COLLATION()</function>機構が使用されます。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>sortsupport</function></term>
   <listitem>
    <para>
<!--
     Optionally, a btree operator family may provide <firstterm>sort
      support</firstterm> function(s), registered under support
     function number 2.  These functions allow implementing
     comparisons for sorting purposes in a more efficient way than
     naively calling the comparison support function.  The APIs
     involved in this are defined in
     <filename>src/include/utils/sortsupport.h</filename>.
-->
任意で、btree演算子族は<firstterm>ソートサポート</firstterm>関数を提供してもよいです。これはサポート関数2番で登録されます。
この関数は、素朴に比較サポート関数を呼び出すよりも、ソート目的により効果的な方法での比較の実装を可能にします。
これに関するAPIは<filename>src/include/utils/sortsupport.h</filename>で定義されています。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>in_range</function></term>
   <listitem>
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>
    <indexterm>
     <primary>in_rangeサポート関数</primary>
    </indexterm>

    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
    <indexterm>
     <primary>サポート関数</primary>
     <secondary>in_range</secondary>
    </indexterm>
    <para>
<!--
     Optionally, a btree operator family may provide
     <firstterm>in_range</firstterm> support function(s), registered
     under support function number 3.  These are not used during btree
     index operations; rather, they extend the semantics of the
     operator family so that it can support window clauses containing
     the <literal>RANGE</literal> <replaceable>offset</replaceable>
     <literal>PRECEDING</literal> and <literal>RANGE</literal>
     <replaceable>offset</replaceable> <literal>FOLLOWING</literal>
     frame bound types (see <xref
      linkend="syntax-window-functions"/>).  Fundamentally, the extra
     information provided is how to add or subtract an
     <replaceable>offset</replaceable> value in a way that is
     compatible with the family's data ordering.
-->
任意で、btree演算子族は<firstterm>in_range</firstterm>サポート関数を提供してもよいです。これはサポート関数3番に登録されます。
これはbtreeインデックス操作中には使われません。そうではなく、演算子族のセマンティクスを<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>PRECEDING</literal>と<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>FOLLOWING</literal>フレーム境界タイプ（<xref linkend="syntax-window-functions"/>を参照）を含むWINDOW句に対応できるように拡張します。
基本的には、提供される拡張情報はどのように演算子族のデータ並び順と互換性のある方法で<replaceable>offset</replaceable>値を足すか引くかです。
    </para>

    <para>
<!--
     An <function>in_range</function> function must have the signature
-->
<function>in_range</function>関数は以下のシグネチャを持たなければなりません。
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
<!--
     <replaceable>val</replaceable> and
     <replaceable>base</replaceable> must be of the same type, which
     is one of the types supported by the operator family (i.e., a
     type for which it provides an ordering).  However,
     <replaceable>offset</replaceable> could be of a different type,
     which might be one otherwise unsupported by the family.  An
     example is that the built-in <literal>time_ops</literal> family
     provides an <function>in_range</function> function that has
     <replaceable>offset</replaceable> of type <type>interval</type>.
     A family can provide <function>in_range</function> functions for
     any of its supported types and one or more
     <replaceable>offset</replaceable> types.  Each
     <function>in_range</function> function should be entered in
     <structname>pg_amproc</structname> with
     <structfield>amproclefttype</structfield> equal to
     <type>type1</type> and <structfield>amprocrighttype</structfield>
     equal to <type>type2</type>.
-->
<replaceable>val</replaceable>と<replaceable>base</replaceable>は同じ型でなければならず、これは演算子族でサポートされる型の一つ（すなわち、並び順を提供する対象の型）です。
しかしながら、<replaceable>offset</replaceable>は異なる型のものでも可能です。それは演算子族でサポートされないものでもよいです。
例としては、組み込みの<literal>time_ops</literal>族が<type>interval</type>型の<replaceable>offset</replaceable>を持つ<function>in_range</function>関数を提供しています。
演算子族は、任意のサポートされる型と一つまたは複数の<replaceable>offset</replaceable>型に対する<function>in_range</function>関数を提供できます。
各<function>in_range</function>関数は、<structname>pg_amproc</structname>に<type>type1</type>と等しい<structfield>amproclefttype</structfield>と<type>type2</type>に等しい<structfield>amproclefttype</structfield>で登録されるべきです。
    </para>

    <para>
<!--
     The essential semantics of an <function>in_range</function>
     function depend on the two Boolean flag parameters.  It should
     add or subtract <replaceable>base</replaceable> and
     <replaceable>offset</replaceable>, then compare
     <replaceable>val</replaceable> to the result, as follows:
-->
<function>in_range</function>関数の本質的なセマンティクスは2つのBooleanフラグパラメータに依存します。
これは以下のように、<replaceable>base</replaceable>に<replaceable>offset</replaceable>を加算または減算して、それから<replaceable>val</replaceable>を結果と比較すべきです。
     <itemizedlist>
      <listitem>
       <para>
<!--
        if <literal>!</literal><replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
-->
        <literal>!</literal><replaceable>sub</replaceable>かつ
        <literal>!</literal><replaceable>less</replaceable>であるなら、
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)を返します
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        if <literal>!</literal><replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
-->
        <literal>!</literal><replaceable>sub</replaceable>かつ
        <replaceable>less</replaceable>であるなら、
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)を返します
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        if <replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
-->
        <replaceable>sub</replaceable>かつ
        <literal>!</literal><replaceable>less</replaceable>であるなら、
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)を返します
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        if <replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
-->
        <replaceable>sub</replaceable>かつ
        <replaceable>less</replaceable>であるなら、
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)を返します
       </para>
      </listitem>
     </itemizedlist>
<!--
     Before doing so, the function should check the sign of
     <replaceable>offset</replaceable>: if it is less than zero, raise
     error
     <literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal>
     (22013) with error text like <quote>invalid preceding or
      following size in window function</quote>.  (This is required by
     the SQL standard, although nonstandard operator families might
     perhaps choose to ignore this restriction, since there seems to
     be little semantic necessity for it.) This requirement is
     delegated to the <function>in_range</function> function so that
     the core code needn't understand what <quote>less than
      zero</quote> means for a particular data type.
-->
このように実行する前に、本関数は、<replaceable>offset</replaceable>の符号を検査すべきです。
すなわち、負であったなら、エラー<literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal>(22013)、エラー文面としては<quote>invalid preceding or following size in window function(ウィンドウ関数で先行または後続のサイズが不正です)</quote>などを出すことです。
（意味上の必要性が乏しいと見られることから非標準の演算子族はこの制限を無視することを選ぶかもしれませんが、これは標準SQLで必要とされています。）
中核コードが特定のデータ型における<quote>ゼロより小さい</quote>ことの意味を理解しなくても良いように、この要件は<function>in_range</function>関数に委託されます。
    </para>

    <para>
<!--
     An additional expectation is that <function>in_range</function>
     functions should, if practical, avoid throwing an error if
     <replaceable>base</replaceable> <literal>+</literal>
     <replaceable>offset</replaceable> or
     <replaceable>base</replaceable> <literal>-</literal>
     <replaceable>offset</replaceable> would overflow.  The correct
     comparison result can be determined even if that value would be
     out of the data type's range.  Note that if the data type
     includes concepts such as <quote>infinity</quote> or
     <quote>NaN</quote>, extra care may be needed to ensure that
     <function>in_range</function>'s results agree with the normal
     sort order of the operator family.
-->
さらに期待されることは、<function>in_range</function>関数は、実用的には、<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>や<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>がオーバーフローする場合にエラーを投げるのを避けるべきです。
たとえ値がデータ型の範囲を超えたとしても正しい比較結果は決定できます。
データ型が<quote>infinity</quote>や<quote>NaN</quote>などの概念を含む場合には、<function>in_range</function>の結果が演算子族の通常のソート順序と一致するように特別な対応が必要となることに注意してください。
    </para>

    <para>
<!--
     The results of the <function>in_range</function> function must be
     consistent with the sort ordering imposed by the operator family.
     To be precise, given any fixed values of
     <replaceable>offset</replaceable> and
     <replaceable>sub</replaceable>, then:
-->
<function>in_range</function>関数の結果は、演算子族で規定されるソート順序と整合していなければなりません。
正確には、与えらえれた任意の<replaceable>offset</replaceable>と<replaceable>sub</replaceable>の修正値は以下のようになります。
     <itemizedlist>
      <listitem>
       <para>
<!--
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be true for every
        <replaceable>val2</replaceable> <literal>&lt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
-->
<replaceable>less</replaceable> = trueの<function>in_range</function>がいくつかの<replaceable>val1</replaceable>と<replaceable>base</replaceable>に対して真であるなら、同じ<replaceable>base</replaceable>の全ての<replaceable>val2</replaceable> <literal>&lt;=</literal> <replaceable>val1</replaceable>に対して真でなければなりません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be false for every
        <replaceable>val2</replaceable> <literal>&gt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
-->
<replaceable>less</replaceable> = trueの<function>in_range</function>が、いくつかの<replaceable>val1</replaceable>と<replaceable>base</replaceable>に対して偽であるなら、同じ<replaceable>base</replaceable>の全ての<replaceable>val2</replaceable> <literal>&gt;=</literal> <replaceable>val1</replaceable>に対して偽でなければなりません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be true for every
        <replaceable>base2</replaceable> <literal>&gt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
-->
<replaceable>less</replaceable> = trueの<function>in_range</function>がいくつかの<replaceable>val</replaceable>と<replaceable>base1</replaceable>に対して真であるなら、同じ<replaceable>val</replaceable>の全ての<replaceable>base2</replaceable> <literal>&gt;=</literal> <replaceable>base1</replaceable>に対して真でなければなりません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be false for every
        <replaceable>base2</replaceable> <literal>&lt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
-->
<replaceable>less</replaceable> = trueの<function>in_range</function>が一部の<replaceable>val</replaceable>と<replaceable>base1</replaceable>に対して偽であるなら、同じ<replaceable>val</replaceable>の全ての<replaceable>base2</replaceable> <literal>&lt;=</literal> <replaceable>base1</replaceable>に対して偽でなければなりません。
       </para>
      </listitem>
     </itemizedlist>
<!--
     Analogous statements with inverted conditions hold when
     <replaceable>less</replaceable> = false.
-->
<replaceable>less</replaceable> = falseのときには、逆条件の類似した命題が適用できます。
    </para>

    <para>
<!--
     If the type being ordered (<type>type1</type>) is collatable, the
     appropriate collation OID will be passed to the
     <function>in_range</function> function, using the standard
     PG_GET_COLLATION() mechanism.
-->
整列しようとしている型(<type>type1</type>)が照合可能であるなら、標準のPG_GET_COLLATION()機構を使って、<function>in_range</function>関数に適切な照合順序のOIDが渡されます。
    </para>

    <para>
<!--
     <function>in_range</function> functions need not handle NULL
     inputs, and typically will be marked strict.
-->
<function>in_range</function>関数は、通例STRICTと印付けされ、NULL入力を処理する必要がありません。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>equalimage</function></term>
   <listitem>
    <para>
<!--
     Optionally, a btree operator family may provide
     <function>equalimage</function> (<quote>equality implies image
      equality</quote>) support functions, registered under support
     function number 4.  These functions allow the core code to
     determine when it is safe to apply the btree deduplication
     optimization.  Currently, <function>equalimage</function>
     functions are only called when building or rebuilding an index.
-->
省略可能ですが、btree演算子族は<function>equalimage</function> (<quote>イメージ等価を意味する等価</quote>)サポート関数を提供してもよいです。これはサポート関数4番で登録されます。
この関数は、中核コードがbtree重複排除の最適化を適用するのが安全かを決定できるようにします。
今のところ、<function>equalimage</function>関数はインデックスの構築または再構築時にのみ呼び出されます。
    </para>
    <para>
<!--
     An <function>equalimage</function> function must have the
     signature
-->
<function>equalimage</function>関数は以下のシグネチャを持たなければなりません。
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
<!--
     The return value is static information about an operator class
     and collation.  Returning <literal>true</literal> indicates that
     the <function>order</function> function for the operator class is
     guaranteed to only return <literal>0</literal> (<quote>arguments
      are equal</quote>) when its <replaceable>A</replaceable> and
     <replaceable>B</replaceable> arguments are also interchangeable
     without any loss of semantic information.  Not registering an
     <function>equalimage</function> function or returning
     <literal>false</literal> indicates that this condition cannot be
     assumed to hold.
-->
戻り値は演算子クラスと照合順序についての静的な情報です。
<literal>true</literal>を返すことは、<replaceable>A</replaceable>および<replaceable>B</replaceable>引数が何らセマンティック情報を損失すること無しに交換可能でもあるとき、演算子クラスに対する<function>order</function>関数が<literal>0</literal>（<quote>引数が等しい</quote>）だけを返すことが保証されていることを示します。
<function>equalimage</function>関数が登録されていなかったり、<literal>false</literal>を返すことは、この条件は守られないであろうことを示します。
    </para>
    <para>
<!--
     The <replaceable>opcintype</replaceable> argument is the
     <literal><structname>pg_type</structname>.oid</literal> of the
     data type that the operator class indexes.  This is a convenience
     that allows reuse of the same underlying
     <function>equalimage</function> function across operator classes.
     If <replaceable>opcintype</replaceable> is a collatable data
     type, the appropriate collation OID will be passed to the
     <function>equalimage</function> function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
-->
<replaceable>opcintype</replaceable>引数は演算子クラスタがインデックスを作るデータ型の<literal><structname>pg_type</structname>.oid</literal>です。
これは同じ基となる<function>equalimage</function>関数を演算子クラスを横断して再利用できるようになる利便性があります。
<replaceable>opcintype</replaceable>が照合可能なデータ型である場合には、適切な照合順序のOIDが、標準の<function>PG_GET_COLLATION()</function>機構を使って、<function>equalimage</function>関数に渡されます。
    </para>
    <para>
<!--
     As far as the operator class is concerned, returning
     <literal>true</literal> indicates that deduplication is safe (or
     safe for the collation whose OID was passed to its
     <function>equalimage</function> function).  However, the core
     code will only deem deduplication safe for an index when
     <emphasis>every</emphasis> indexed column uses an operator class
     that registers an <function>equalimage</function> function, and
     each function actually returns <literal>true</literal> when
     called.
-->
演算子クラスに関する限り、<literal>true</literal>を返すことは、重複排除が安全（あるいは<function>equalimage</function>関数に渡されたOIDの照合順序について安全）であることを示します。
しかしながら、コアコードは、<emphasis>全ての</emphasis>インデックス列が<function>equalimage</function>関数を登録する演算子クラスを使っていて、各関数が呼ばれたとき実際に<literal>true</literal>を返すときに、そのインデックスに対して重複排除を安全と見做すだけです。
    </para>
    <para>
<!--
     Image equality is <emphasis>almost</emphasis> the same condition
     as simple bitwise equality.  There is one subtle difference: When
     indexing a varlena data type, the on-disk representation of two
     image equal datums may not be bitwise equal due to inconsistent
     application of <acronym>TOAST</acronym> compression on input.
     Formally, when an operator class's
     <function>equalimage</function> function returns
     <literal>true</literal>, it is safe to assume that the
     <literal>datum_image_eq()</literal> C function will always agree
     with the operator class's <function>order</function> function
     (provided that the same collation OID is passed to both the
     <function>equalimage</function> and <function>order</function>
     functions).
-->
イメージ等価は単純にビット毎に等しいことと<emphasis>ほとんど</emphasis>同じ条件です。
一点微妙な違いがあります。varlenaデータ型にインデックス作成するとき、入力時の一貫性のない<acronym>TOAST</acronym>圧縮の適用のために、同じdatumの二つのイメージのディスク上の表現はビット毎には等しくないかもしれません。
これまでは、演算子クラスの<function>equalimage</function>関数が<literal>true</literal>を返すときには、<literal>datum_image_eq()</literal> C関数が常に演算子クラスの<function>order</function>関数と一致すると想定して安全でした（同じ照合順序のOIDが<function>equalimage</function>と<function>order</function>の両関数に渡されるとして）。
    </para>
    <para>
<!--
     The core code is fundamentally unable to deduce anything about
     the <quote>equality implies image equality</quote> status of an
     operator class within a multiple-data-type family based on
     details from other operator classes in the same family.  Also, it
     is not sensible for an operator family to register a cross-type
     <function>equalimage</function> function, and attempting to do so
     will result in an error.  This is because <quote>equality implies
      image equality</quote> status does not just depend on
     sorting/equality semantics, which are more or less defined at the
     operator family level.  In general, the semantics that one
     particular data type implements must be considered separately.
-->
コアコードは基本的に、複数データ型の族の中の演算子クラスの<quote>等価性がイメージ等価性を含む</quote>状態について、同族の他の演算子クラスの詳細に基づいた、いかなる推測もできません。
また、ある演算子族が型にまたがって<function>equalimage</function>関数を登録していることを認識できず、そのような試みはエラーになります。
これは<quote>等価性がイメージ等価性を含む</quote>状態は、演算子族の階層でおおむね定義されている、ソートと等価性のセマンティクスに依存しているだけでは無いためです。
一般に、ある特定データ型の実装によるセマンティクスは別個に考慮されなければなりません。
    </para>
    <para>
<!--
     The convention followed by the operator classes included with the
     core <productname>PostgreSQL</productname> distribution is to
     register a stock, generic <function>equalimage</function>
     function.  Most operator classes register
     <function>btequalimage()</function>, which indicates that
     deduplication is safe unconditionally.  Operator classes for
     collatable data types such as <type>text</type> register
     <function>btvarstrequalimage()</function>, which indicates that
     deduplication is safe with deterministic collations.  Best
     practice for third-party extensions is to register their own
     custom function to retain control.
-->
コア<productname>PostgreSQL</productname>配布物に含まれる演算子クラスが従う慣習は、標準品、すなわち、一般的な<function>equalimage</function>関数を登録することです。
大部分の演算子クラスタは<function>btequalimage()</function>を登録しています。これは重複排除が無条件に安全であることを示しています。
<type>text</type>などの照合可能なデータ型に対する演算子クラスは<function>btvarstrequalimage()</function>を登録します。これは決定的な照合順序では重複排除が安全であることを示します。
サードパーティ拡張におけるベストプラクティスは制御を保つためにそれら自身のカスタム関数を登録することです。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>options</function></term>
   <listitem>
    <para>
<!--
     Optionally, a B-tree operator family may provide
     <function>options</function> (<quote>operator class specific
     options</quote>) support functions, registered under support
     function number 5.  These functions define a set of user-visible
     parameters that control operator class behavior.
-->
省略可能ですが、B-treeの演算子族は<function>options</function>（<quote>演算子クラス固有オプション</quote>）サポート関数を提供してもよいです。これはサポート関数5番に登録されます。
この関数はユーザに見える演算子クラスの振る舞いを制御するパラメータの集合を定義します。
    </para>
    <para>
<!--
     An <function>options</function> support function must have the
     signature
-->
<function>options</function>サポート関数は以下のシグネチャを持たなければなりません。
<synopsis>
options(<replaceable>relopts</replaceable> <type>local_relopts *</type>) returns void
</synopsis>
<!--
     The function is passed a pointer to a <structname>local_relopts</structname>
     struct, which needs to be filled with a set of operator class
     specific options.  The options can be accessed from other support
     functions using the <literal>PG_HAS_OPCLASS_OPTIONS()</literal> and
     <literal>PG_GET_OPCLASS_OPTIONS()</literal> macros.
-->
関数には<structname>local_relopts</structname>構造体へのポインタが渡されます。ここには演算子クラス固有のオプションの集合が書かれている必要があります。
このオプションには<literal>PG_HAS_OPCLASS_OPTIONS()</literal>および<literal>PG_GET_OPCLASS_OPTIONS()</literal>マクロを使って他のサポート関数からアクセスが可能です。
    </para>
    <para>
<!--
     Currently, no B-Tree operator class has an <function>options</function>
     support function.  B-tree doesn't allow flexible representation of keys
     like GiST, SP-GiST, GIN and BRIN do.  So, <function>options</function>
     probably doesn't have much application in the current B-tree index
     access method.  Nevertheless, this support function was added to B-tree
     for uniformity, and will probably find uses during further
     evolution of B-tree in <productname>PostgreSQL</productname>.
-->
今のところ、<function>options</function>サポート関数を持ったB-Treeの演算子クラスはありません。
B-treeはGiST、SP-GiST、GINおよびBRINで行われているような柔軟なキーの表現を許していません。
そのため、おそらくは<function>options</function>が現在のB-treeインデックスアクセスメソッドで多数適用されることはありません。
それでも、統一性のためにサポート関数がB-treeに追加されました。おそらく<productname>PostgreSQL</productname>でのB-treeの更なる進化の過程で使用法を見つけ出すでしょう。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect2>

<sect2 id="btree-implementation">
<!--
 <title>Implementation</title>
-->
 <title>実装</title>

 <para>
<!--
  This section covers B-Tree index implementation details that may be
  of use to advanced users.  See
  <filename>src/backend/access/nbtree/README</filename> in the source
  distribution for a much more detailed, internals-focused description
  of the B-Tree implementation.
-->
本節では、上級ユーザに役立つかもしれない、B-Treeインデックスの実装の詳細について説明します。
更なる詳細、B-Tree実装の内部に焦点をあてた記述については、ソース配布物の<filename>src/backend/access/nbtree/README</filename>を参照してください。
 </para>
 <sect3 id="btree-structure">
<!--
  <title>B-Tree Structure</title>
-->
  <title>B-Treeの構造</title>
  <para>
<!--
   <productname>PostgreSQL</productname> B-Tree indexes are
   multi-level tree structures, where each level of the tree can be
   used as a doubly-linked list of pages.  A single metapage is stored
   in a fixed position at the start of the first segment file of the
   index.  All other pages are either leaf pages or internal pages.
   Leaf pages are the pages on the lowest level of the tree.  All
   other levels consist of internal pages.  Each leaf page contains
   tuples that point to table rows.  Each internal page contains
   tuples that point to the next level down in the tree.  Typically,
   over 99% of all pages are leaf pages.  Both internal pages and leaf
   pages use the standard page format described in <xref
    linkend="storage-page-layout"/>.
-->
<productname>PostgreSQL</productname>のB-Treeインデックスは複数階層のツリー構造で、ツリーの各階層はページの双方向連結リストとして使用できます。
一つのメタページがインデックスの最初のセグメントファイルの固定位置に格納されます。
それ以外の全てのページはリーフページか内部ページのいずれかです。
リーフページはツリーの最下階層にあるページです。
それ以外の全ての階層は内部ページで構成されます。
各リーフページはテーブルの行を指すタプルを含みます。
各内部ページはツリーの次の下位層を指すタプルを含みます。
典型的には、全ページの99％以上がリーフページです。
内部ページとリーフページは共に、<xref linkend="storage-page-layout"/>に記載されている標準のページ書式を使用します。
  </para>
  <para>
<!--
   New leaf pages are added to a B-Tree index when an existing leaf
   page cannot fit an incoming tuple.  A <firstterm>page
    split</firstterm> operation makes room for items that originally
   belonged on the overflowing page by moving a portion of the items
   to a new page.  Page splits must also insert a new
   <firstterm>downlink</firstterm> to the new page in the parent page,
   which may cause the parent to split in turn.  Page splits
   <quote>cascade upwards</quote> in a recursive fashion.  When the
   root page finally cannot fit a new downlink, a <firstterm>root page
    split</firstterm> operation takes place.  This adds a new level to
   the tree structure by creating a new root page that is one level
   above the original root page.
-->
既存リーフページがやってくるタプルをはめ込むことができないとき、新たなリーフページがB-Treeインデックスに追加されます。
<firstterm>ページ分割</firstterm>操作は一部のアイテムを新ページに動かすことで、当初は溢れているページに属していたアイテムのために空間を作ります。
ページ分割は、また、新ページへの新たな<firstterm>ダウンリンク</firstterm>を親ページに挿入しなければなりません。これは親ページの分割を同様に引き起こすかもしれません。
ページは分割は再帰的に<quote>上向きに連鎖</quote>します。
最終的にルートページが新たなダウンリンクをはめ込みできないときには、<firstterm>ルートページ分割</firstterm>が実施されます。
これは元のルートページの一つ上の階層に新たなルートページを作ることで、ツリー構造に新しい階層を加えます。
  </para>
 </sect3>

 <sect3 id="btree-deletion">
<!--
  <title>Bottom-up Index Deletion</title>
-->
  <title>ボトムアップインデックスの削除</title>
  <para>
<!--
   B-Tree indexes are not directly aware that under MVCC, there might
   be multiple extant versions of the same logical table row; to an
   index, each tuple is an independent object that needs its own index
   entry.  <quote>Version churn</quote> tuples may sometimes
   accumulate and adversely affect query latency and throughput.  This
   typically occurs with <command>UPDATE</command>-heavy workloads
   where most individual updates cannot apply the
   <link linkend="storage-hot"><acronym>HOT</acronym> optimization.</link>
   Changing the value of only
   one column covered by one index during an <command>UPDATE</command>
   <emphasis>always</emphasis> necessitates a new set of index tuples
   &mdash; one for <emphasis>each and every</emphasis> index on the
   table.  Note in particular that this includes indexes that were not
   <quote>logically modified</quote> by the <command>UPDATE</command>.
   All indexes will need a successor physical index tuple that points
   to the latest version in the table.  Each new tuple within each
   index will generally need to coexist with the original
   <quote>updated</quote> tuple for a short period of time (typically
   until shortly after the <command>UPDATE</command> transaction
   commits).
-->
B-Treeインデックスは、MVCCの下で同じ論理テーブル行の複数の現存するバージョンが存在する可能性があることを直接認識していません。
インデックスに対して、各タプルは独自のインデックスエントリを必要とする独立したオブジェクトです。
<quote>バージョンチャーン</quote>タプルは蓄積し、クエリ待ち時間とスループットに悪影響を与える可能性があります。
これは通常、個々の更新のほとんどが<link linkend="storage-hot"><acronym>HOT</acronym>最適化</link>を適用できないような<command>UPDATE</command>の重いワークロードで発生します。
<command>UPDATE</command>中にあるインデックスによって、カバーされる一つだけの行の値を変更するには、新しいインデックスタプルのセットを<emphasis>いつも</emphasis>必要とします。
テーブル上にある <emphasis>ありとあらゆる</emphasis>インデックスにつき一つです。
具体的には、<command>UPDATE</command>によって<quote>論理的に変更</quote>されなかったインデックスが含まれることに注意してください。
すべてのインデックスは、テーブル上で最新バージョンを指す後継の物理的なインデックスタプルを必要とします。
各インデックス中のそれぞれの新しいタプルは通常元の<quote>更新された</quote>タプルと短期間共存する必要があります（通常、<command>UPDATE</command>トランザクションのコミットした直後までです）。
  </para>
  <para>
<!--
   B-Tree indexes incrementally delete version churn index tuples by
   performing <firstterm>bottom-up index deletion</firstterm> passes.
   Each deletion pass is triggered in reaction to an anticipated
   <quote>version churn page split</quote>.  This only happens with
   indexes that are not logically modified by
   <command>UPDATE</command> statements, where concentrated build up
   of obsolete versions in particular pages would occur otherwise.  A
   page split will usually be avoided, though it's possible that
   certain implementation-level heuristics will fail to identify and
   delete even one garbage index tuple (in which case a page split or
   deduplication pass resolves the issue of an incoming new tuple not
   fitting on a leaf page).  The worst-case number of versions that
   any index scan must traverse (for any single logical row) is an
   important contributor to overall system responsiveness and
   throughput.  A bottom-up index deletion pass targets suspected
   garbage tuples in a single leaf page based on
   <emphasis>qualitative</emphasis> distinctions involving logical
   rows and versions.  This contrasts with the <quote>top-down</quote>
   index cleanup performed by autovacuum workers, which is triggered
   when certain <emphasis>quantitative</emphasis> table-level
   thresholds are exceeded (see <xref linkend="autovacuum"/>).
-->
B-Treeインデックスは、<firstterm>ボトムアップインデックスの削除</firstterm>パスの実行によって、バージョンチャーンのインデックスタプルを徐々に削除します。
各削除パスは、予期された<quote>バージョンチャーンのページ分割</quote>に対してトリガされます。
これは、<command>UPDATE</command>文によって論理的に変更されてないインデックスだけで発生します。
さもないと、特定のページで使われなくなったバージョンが集中的に蓄積されます。
ある種の実装レベルの発見的手法は、均一のごみインデックスタプルの特定及び削除に失敗する可能がありますが、ページの分割は通常避けることができます（ページ分割もしくは重複排除パスの場合に、リーフページ上の収まらない新しいタプルが入ることの問題が解決します）。
インデックススキャンが（単一の論理行に対して）通過しなければならない最悪の場合のバージョン数は、システム全体の応答性やスループットに重要な影響があります。
ボトムアップインデックス削除パスは、論理行とバージョンを含む<emphasis>定性的な</emphasis>特徴に基づいた単一のリーフページ内の疑わしいごみタプルを対象としています。
これは、一定の<emphasis>定量的な</emphasis>テーブルレベルの閾値が超えられたとき（<xref linkend="autovacuum"/>参照）に起動されるautovacuumワーカーによって実行された<quote>トップダウン</quote>インデックスのクリーンアップと対照的です。
  </para>
  <note>
   <para>
<!--
    Not all deletion operations that are performed within B-Tree
    indexes are bottom-up deletion operations.  There is a distinct
    category of index tuple deletion: <firstterm>simple index tuple
     deletion</firstterm>.  This is a deferred maintenance operation
    that deletes index tuples that are known to be safe to delete
    (those whose item identifier's <literal>LP_DEAD</literal> bit is
    already set).  Like bottom-up index deletion, simple index
    deletion takes place at the point that a page split is anticipated
    as a way of avoiding the split.
-->
B-Treeインデックス内で実行されたすべての削除操作がボトムアップ削除操作とは限りません。
インデックスタプルの削除の異なる分類があります。
それは、<firstterm>単純なインデックスのタプル削除</firstterm>です。
これは、削除が安全であると分かるインデックスタプル(アイテム識別子の<literal>LP_DEAD</literal>ビットが既に設定されているタプル)を削除する遅延メンテナンス操作です。
ボトムアップインデックス削除と同様に、単純インデックス削除は分割を回避する方法としてページ分割が予測された時点で実行されます。
   </para>
   <para>
<!--
    Simple deletion is opportunistic in the sense that it can only
    take place when recent index scans set the
    <literal>LP_DEAD</literal> bits of affected items in passing.
    Prior to <productname>PostgreSQL</productname> 14, the only
    category of B-Tree deletion was simple deletion.  The main
    differences between it and bottom-up deletion are that only the
    former is opportunistically driven by the activity of passing
    index scans, while only the latter specifically targets version
    churn from <command>UPDATE</command>s that do not logically modify
    indexed columns.
-->
単純削除は、最近のインデックススキャンでは影響があるアイテムに<literal>LP_DEAD</literal>ビットをセットする際に、ついでに実行できる機会の場合のみに実行されるという意味で、機会主義と言えます。
<productname>PostgreSQL</productname> 14より前では、B-Treeの削除の種類は単純な削除のみでした。
単純な削除とボトムアップ削除の主な違いは、前者だけがインデックススキャンの動きによって機会を狙って駆動されることに対して、後者だけがインデックスカラムが論理的に変更されない<command>UPDATE</command>からのバージョンチャーンを具体的に対象とすることです。
   </para>
  </note>
  <para>
<!--
   Bottom-up index deletion performs the vast majority of all garbage
   index tuple cleanup for particular indexes with certain workloads.
   This is expected with any B-Tree index that is subject to
   significant version churn from <command>UPDATE</command>s that
   rarely or never logically modify the columns that the index covers.
   The average and worst-case number of versions per logical row can
   be kept low purely through targeted incremental deletion passes.
   It's quite possible that the on-disk size of certain indexes will
   never increase by even one single page/block despite
   <emphasis>constant</emphasis> version churn from
   <command>UPDATE</command>s.  Even then, an exhaustive <quote>clean
    sweep</quote> by a <command>VACUUM</command> operation (typically
   run in an autovacuum worker process) will eventually be required as
   a part of <emphasis>collective</emphasis> cleanup of the table and
   each of its indexes.
-->
ボトムアップインデックス削除は、明確なワークロードによる特定インデックスのすべてのゴミインデックスタプルの掃除の大多数を実行します。
これは、インデックスがカバーするカラムを論理的に変更することが滅多にまたは決してない<command>UPDATE</command>からの有意なバージョンチャーンに依存するB-Treeインデックスで予想されます。
論理行ごとのバージョン数の平均と最も悪いケースは、対象とされた増分削除パスによって純粋に低く維持することができます。
特定インデックスのディスク上のサイズは、<command>UPDATE</command>からの<emphasis>一定の</emphasis>バージョンチャーンがあるにも関わらず、ページやブロックが一つも増加することがない可能性が十分にあります。
そのような場合でも、<command>VACUUM</command>操作（通常、自動バキュームワーカープロセスで実行します）による、徹底的な<quote>一掃</quote>が、テーブルとその各インデックスの<emphasis>共通の</emphasis>クリーンアップの一部として最終的に要求されます。
  </para>
  <para>
<!--
   Unlike <command>VACUUM</command>, bottom-up index deletion does not
   provide any strong guarantees about how old the oldest garbage
   index tuple may be.  No index can be permitted to retain
   <quote>floating garbage</quote> index tuples that became dead prior
   to a conservative cutoff point shared by the table and all of its
   indexes collectively.  This fundamental table-level invariant makes
   it safe to recycle table <acronym>TID</acronym>s.  This is how it
   is possible for distinct logical rows to reuse the same table
   <acronym>TID</acronym> over time (though this can never happen with
   two logical rows whose lifetimes span the same
   <command>VACUUM</command> cycle).
-->
 <command>VACUUM</command>とは異なり、ボトムアップインデックス削除は最も古いゴミのインデックスタプルがどのくらい経過しているかについて強い保証を提供しません。
テーブルと全てのインデックスの合計によって共通する保守的な切り捨て点より前に、不要になる<quote>浮いているゴミ</quote>インデックスタプルの維持を許可することはできません。
この基本的なテーブルレベルの不変条件は、テーブルの<acronym>TID</acronym>を安全にリサイクルします。
これにより、時間の経過と共に異なる論理行が同じテーブル<acronym>TID</acronym>を再利用することが可能です（ただし、これは存続期間が同じ<command>VACUUM</command>サイクルにまたがる、二つの論理行に同時には発生しません）。
  </para>
 </sect3>

 <sect3 id="btree-deduplication">
<!--
  <title>Deduplication</title>
-->
  <title>重複排除</title>
  <para>
<!--
   A duplicate is a leaf page tuple (a tuple that points to a table
   row) where <emphasis>all</emphasis> indexed key columns have values
   that match corresponding column values from at least one other leaf
   page tuple in the same index.  Duplicate tuples are quite common in
   practice.  B-Tree indexes can use a special, space-efficient
   representation for duplicates when an optional technique is
   enabled: <firstterm>deduplication</firstterm>.
-->
重複とは、同じインデックスで<emphasis>全ての</emphasis>インデックスキー列が少なくとも一つの他のリーフページタプルの該当する列の値と一致する値をもっている、リーフページタプル（テーブルの行を指すタプル）です。
重複タプルは実際によくあります。
オプションの技法「<firstterm>重複排除</firstterm>」が有効にされているとき、B-Treeインデックスは、特別な重複に対する空間効率の良い表現方法を使用できます。
  </para>
  <para>
<!--
   Deduplication works by periodically merging groups of duplicate
   tuples together, forming a single <firstterm>posting list</firstterm> tuple for each
   group.  The column key value(s) only appear once in this
   representation.  This is followed by a sorted array of
   <acronym>TID</acronym>s that point to rows in the table.  This
   significantly reduces the storage size of indexes where each value
   (or each distinct combination of column values) appears several
   times on average.  The latency of queries can be reduced
   significantly.  Overall query throughput may increase
   significantly.  The overhead of routine index vacuuming may also be
   reduced significantly.
-->
重複排除は重複タプルのグループを定期的に合併して、各グループに対する単一の<firstterm>ポスティングリスト</firstterm>タプルを形成することで機能します。
この表現方法では列のキー値は一度だけ現れます。
テーブルの行を指す<acronym>TID</acronym>のソートされた配列がこれに続きます。
概して各値（あるいは列値の異なる組み合わせ）が複数回出現する場合に、これは顕著にインデックスの格納サイズを減らします。
問い合わせの遅延も顕著に削減できます。
全体的な問い合わせのスループットも顕著に増加するかもしれません。
インデックスのバキューム処理のオーバーヘッドも顕著に削減されるかもしれません。
  </para>
  <note>
   <para>
<!--
    B-Tree deduplication is just as effective with
    <quote>duplicates</quote> that contain a NULL value, even though
    NULL values are never equal to each other according to the
    <literal>=</literal> member of any B-Tree operator class.  As far
    as any part of the implementation that understands the on-disk
    B-Tree structure is concerned, NULL is just another value from the
    domain of indexed values.
-->
B-Tree重複排除は、B-Tree演算子クラスの<literal>=</literal>項に従ってNULL値が決して互いに等しくならないとしても、NULL値を含む<quote>重複</quote>に効果的です。
ディスク上のB-Tree構造を解するいかなる実装部分に関しても、NULLはまさにインデックス値の定義域以外の一つの値です。
   </para>
  </note>
  <para>
<!--
   The deduplication process occurs lazily, when a new item is
   inserted that cannot fit on an existing leaf page, though only when
   index tuple deletion could not free sufficient space for the new
   item (typically deletion is briefly considered and then skipped
   over).  Unlike GIN posting list tuples, B-Tree posting list tuples
   do not need to expand every time a new duplicate is inserted; they
   are merely an alternative physical representation of the original
   logical contents of the leaf page.  This design prioritizes
   consistent performance with mixed read-write workloads.  Most
   client applications will at least see a moderate performance
   benefit from using deduplication.  Deduplication is enabled by
   default.
-->
既存のリーフページに収まらない新たな要素が挿入されたとき、重複排除の処理は怠惰に実行されますが、インデックスタプルの削除は新しいアイテムのための十分なスペースを解放できなかった場合に限ります（通常、削除は簡易に検討した上で無視されます）。
GINのポスティングリストのタプルと違って、B-Treeのポスティングリストのタプルは新たな重複が挿入される度に拡張する必要がありません。それらはリーフページの元の論理内容に対する単なる代替の物理表現にすぎません。
この設計は読み書き混合のワークロードでの性能の一貫性を重視しています。
ほとんどのクライアントアプリケーションは重複排除を使うことで少なくとも控えめな性能の恩恵を確認することができるでしょう。
重複排除はデフォルトで有効になっています。
  </para>
  <para>
<!--
   <command>CREATE INDEX</command> and <command>REINDEX</command>
   apply deduplication to create posting list tuples, though the
   strategy they use is slightly different.  Each group of duplicate
   ordinary tuples encountered in the sorted input taken from the
   table is merged into a posting list tuple
   <emphasis>before</emphasis> being added to the current pending leaf
   page.  Individual posting list tuples are packed with as many
   <acronym>TID</acronym>s as possible.  Leaf pages are written out in
   the usual way, without any separate deduplication pass.  This
   strategy is well-suited to <command>CREATE INDEX</command> and
   <command>REINDEX</command> because they are once-off batch
   operations.
-->
<command>CREATE INDEX</command>と<command>REINDEX</command>は、使用する手順が若干異なりますが、ポスティングリストタプルを作って重複排除を適用します。
テーブルから取得されてソートされた入力で遭遇した重複した通常タプルの各グループは、現在のペンディングリーフページに追加される<emphasis>前に</emphasis>、ポスティングリストタプルにマージされます。
個別のポスティングリストタプルには、可能な限り多数の<acronym>TID</acronym>が詰め込まれます。
リーフページは、重複排除用の別パスではなく、通常の方法で書き出されます。
この戦略は<command>CREATE INDEX</command>と<command>REINDEX</command>に良く適合します。これらは1回で終わるバッチ操作であるからです。
  </para>
  <para>
<!--
   Write-heavy workloads that don't benefit from deduplication due to
   having few or no duplicate values in indexes will incur a small,
   fixed performance penalty (unless deduplication is explicitly
   disabled).  The <literal>deduplicate_items</literal> storage
   parameter can be used to disable deduplication within individual
   indexes.  There is never any performance penalty with read-only
   workloads, since reading posting list tuples is at least as
   efficient as reading the standard tuple representation.  Disabling
   deduplication isn't usually helpful.
-->
インデックスの値に重複が無いか殆ど無いために重複排除から利益を得られない、書き込みの多いワークロードには、（重複排除が明示的に無効化されて居ない限り）固定のペナルティによる小さい負荷増があります。
<literal>deduplicate_items</literal>格納パラメータは個別のインデックス内で重複排除を無効化するのに使うことができます。
ポスティングリストタプルの読み込みは少なくとも通常タプル表現の読み込み程度に効率的であるため、読み込みのみのワークロードで性能ペナルティは一切ありません。
通常は重複排除を無効化することは有益ではありません。
  </para>
  <para>
<!--
   It is sometimes possible for unique indexes (as well as unique
   constraints) to use deduplication.  This allows leaf pages to
   temporarily <quote>absorb</quote> extra version churn duplicates.
   Deduplication in unique indexes augments bottom-up index deletion,
   especially in cases where a long-running transaction holds a
   snapshot that blocks garbage collection.  The goal is to buy time
   for the bottom-up index deletion strategy to become effective
   again.  Delaying page splits until a single long-running
   transaction naturally goes away can allow a bottom-up deletion pass
   to succeed where an earlier deletion pass failed.
-->
一意性インデックス(や一意制約)が重複排除に使用できる場合があります。
これにより、リーフページは余分なバージョンチャーンの重複を一時的に<quote>吸収</quote>することができます。
一意性インデックス内の重複排除は、特に時間のかかるトランザクションがガベージコレクションを妨げるスナップショットを保持している場合にボトムアップインデックス削除を増強します。
目的は、ボトムアップインデックス削除の戦略が再び有効になるための時間を稼ぐことです。
一つの時間のかかるトランザクションが自然に消えるまでページ分割を遅らせることで、以前の削除パスが失敗した場所でボトムアップ削除パスを成功することができます。
  </para>
  <tip>
   <para>
<!--
    A special heuristic is applied to determine whether a
    deduplication pass in a unique index should take place.  It can
    often skip straight to splitting a leaf page, avoiding a
    performance penalty from wasting cycles on unhelpful deduplication
    passes.  If you're concerned about the overhead of deduplication,
    consider setting <literal>deduplicate_items = off</literal>
    selectively.  Leaving deduplication enabled in unique indexes has
    little downside.
-->
一意性インデックスで重複排除パスを実行すべきかどうかの判断には、特別なヒューリスティックが適用されます。
これは、しばしばリーフページ分割まで連続してスキップして、無益な重複排除パスでの無駄なサイクルによる性能ペナルティを回避できます。
重複排除のオーバーヘッドを懸念するなら、選択的に設定<literal>deduplicate_items = off</literal>を検討してください。
一意性インデックスでは重複排除を無効にすることに不都合はありません。
   </para>
  </tip>
  <para>
<!--
   Deduplication cannot be used in all cases due to
   implementation-level restrictions.  Deduplication safety is
   determined when <command>CREATE INDEX</command> or
   <command>REINDEX</command> is run.
-->
実装レベルの制限により、重複排除は全ての場合に使えるわけではありません。
重複排除の安全性は<command>CREATE INDEX</command>あるいは<command>REINDEX</command>が実行されたときに決定されます。
  </para>
  <para>
<!--
   Note that deduplication is deemed unsafe and cannot be used in the
   following cases involving semantically significant differences
   among equal datums:
-->
等しいデータの間で意味的に明らかな違いを伴う以下の場合には、重複排除は安全でないと見做されて使用できないことに注意してください。
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
<!--
      <type>text</type>, <type>varchar</type>, and <type>char</type>
      cannot use deduplication when a
      <emphasis>nondeterministic</emphasis> collation is used.  Case
      and accent differences must be preserved among equal datums.
-->
<emphasis>非決定的な</emphasis>照合順序が使われているとき<type>text</type>、<type>varchar</type>、および、<type>char</type>は重複排除を使えません。
等しいデータの間で大文字小文字やアクセントの違いが維持されなければなりません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      <type>numeric</type> cannot use deduplication.  Numeric display
      scale must be preserved among equal datums.
-->
<type>numeric</type>は重複排除を使えません。
等しいデータの間で数の表示スケールが維持されなければなりません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      <type>jsonb</type> cannot use deduplication, since the
      <type>jsonb</type> B-Tree operator class uses
      <type>numeric</type> internally.
-->
<type>jsonb</type>のB-Tree演算子クラスは内部的に<type>numeric</type>を使っているため、<type>jsonb</type>は重複排除を使えません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      <type>float4</type> and <type>float8</type> cannot use
      deduplication.  These types have distinct representations for
      <literal>-0</literal> and <literal>0</literal>, which are
      nevertheless considered equal.  This difference must be
      preserved.
-->
<type>float4</type>および<type>float8</type>は重複排除を使えません。
これらの型は<literal>-0</literal>と<literal>0</literal>に異なる表現を持ち、にもかかわらずこれらは等しいと見做されます。
この違いは維持されなければなりません。
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
<!--
   There is one further implementation-level restriction that may be
   lifted in a future version of
   <productname>PostgreSQL</productname>:
-->
さらに以下の実装レベルの制限があります。これは<productname>PostgreSQL</productname>の将来バージョンで解消されるかもしれません。
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
<!--
      Container types (such as composite types, arrays, or range
      types) cannot use deduplication.
-->
コンテナ型（複合型、配列型、あるいは、範囲型など）は、重複排除を使えません。
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
<!--
   There is one further implementation-level restriction that applies
   regardless of the operator class or collation used:
-->
さらに以下の実装レベルの制限があります。これは使われている演算子クラスや照合順序にかかわりなく該当します。
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>INCLUDE</literal> indexes can never use deduplication.
-->
      <literal>INCLUDE</literal>インデックスには重複排除は使えません。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect3>
</sect2>

</sect1>
