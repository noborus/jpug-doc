<!-- doc/src/sgml/trigger.sgml -->

 <chapter id="triggers">
<!--
  <title>Triggers</title>
-->
<title>トリガ</title>

  <indexterm zone="triggers">
<!--
   <primary>trigger</primary>
-->
   <primary>トリガ</primary>
  </indexterm>

  <para>
<!--
   This chapter provides general information about writing trigger functions.
   Trigger functions can be written in most of the available procedural
   languages, including
   <application>PL/pgSQL</application> (<xref linkend="plpgsql"/>),
   <application>PL/Tcl</application> (<xref linkend="pltcl"/>),
   <application>PL/Perl</application> (<xref linkend="plperl"/>), and
   <application>PL/Python</application> (<xref linkend="plpython"/>).
   After reading this chapter, you should consult the chapter for
   your favorite procedural language to find out the language-specific
   details of writing a trigger in it.
-->
本章ではトリガ関数の作成に関する一般的な情報を示します。
トリガ関数は、<application>PL/pgSQL</application> (<xref linkend="plpgsql"/>)、<application>PL/Tcl</application> (<xref linkend="pltcl"/>)、<application>PL/Perl</application> (<xref linkend="plperl"/>)、<application>PL/Python</application> (<xref linkend="plpython"/>)など、利用可能な手続き言語のほとんどで作成することができます。
本章を読んだ後、好みの手続き言語に関する章を参照して、トリガ作成に関する言語特有の詳細を確認すべきです。
  </para>

  <para>
<!--
   It is also possible to write a trigger function in C, although
   most people find it easier to use one of the procedural languages.
   It is not currently possible to write a trigger function in the
   plain SQL function language.
-->
また、C言語でトリガ関数を作成することができます。
しかし、ほとんどの方は、手続き言語のいずれかで作成する方が簡単であることに気づくでしょう。
現時点では、普通のSQL関数言語ではトリガ関数を作成することはできません。
  </para>

  <sect1 id="trigger-definition">
<!--
   <title>Overview of Trigger Behavior</title>
-->
   <title>トリガ動作の概要</title>

   <para>
<!--
    A trigger is a specification that the database should automatically
    execute a particular function whenever a certain type of operation is
    performed.  Triggers can be attached to tables (partitioned or not),
    views, and foreign tables.
-->
トリガとは、データベースが、ある特定の操作が行われた時に常に自動的に実行しなければならない特定の機能に関する規定です。
トリガはテーブル（パーティション化されているかどうかにかかわらず）、ビュー、外部テーブルに付与することができます。
  </para>

  <para>
<!--
    On tables and foreign tables, triggers can be defined to execute either
    before or after any <command>INSERT</command>, <command>UPDATE</command>,
    or <command>DELETE</command> operation, either once per modified row,
    or once per <acronym>SQL</acronym> statement.
    <command>UPDATE</command> triggers can moreover be set to fire only if
    certain columns are mentioned in the <literal>SET</literal> clause of
    the <command>UPDATE</command> statement.  Triggers can also fire
    for <command>TRUNCATE</command> statements.  If a trigger event occurs,
    the trigger's function is called at the appropriate time to handle the
    event.
-->
テーブルおよび外部テーブル上では、トリガを<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の前後に、行を変更する度、あるいは<acronym>SQL</acronym>文ごとに実行するように定義することができます。
<command>INSERT</command>が<literal>ON CONFLICT DO UPDATE</literal>句を含む場合、<varname>EXCLUDED</varname>列への参照があるなら、BEFORE INSERTトリガとBEFORE UPDATEトリガの両方が適用されることもあります。
さらに、UPDATEトリガについては、特定のカラムがUPDATE文のSET句の対象になった時のみ発動するよう設定することができます。
また、トリガはTRUNCATE文についても発動できます。
トリガイベントが起こると、トリガ関数がそのイベントを扱う適切な時点で呼び出されます。
   </para>

   <para>
<!--
    On views, triggers can be defined to execute instead of
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
    Such <literal>INSTEAD OF</literal> triggers
    are fired once for each row that needs to be modified in the view.
    It is the responsibility of the
    trigger's function to perform the necessary modifications to the view's
    underlying base table(s) and, where appropriate, return the modified
    row as it will appear in the view.  Triggers on views can also be defined
    to execute once per <acronym>SQL</acronym> statement, before or after
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
    However, such triggers are fired only if there is also
    an <literal>INSTEAD OF</literal> trigger on the view.  Otherwise,
    any statement targeting the view must be rewritten into a statement
    affecting its underlying base table(s), and then the triggers
    that will be fired are the ones attached to the base table(s).
-->
ビュー上では、トリガを<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の代わりに実行するものとして定義できます。
そうした<literal>INSTEAD OF</literal>トリガは、ビュー内の変更を行うために必要となる行それぞれに対して一度発行されます。
ビューの元になっている基底テーブルへの必要な変更の実施、そして必要に応じて、ビュー上で見えるであろう変更された行を返却するのは、トリガ関数の責任です。
ビューへのトリガは、<acronym>SQL</acronym>文ごとに、<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の前後で実行させるよう定義することもできます。
しかし、そうしたトリガは、ビューに<literal>INSTEAD OF</literal>トリガがあるときにだけ発行されます。
<literal>INSTEAD OF</literal>トリガを定義しない場合は、ビューを操作しようとする文は、元になる基底テーブルに影響を与える文に書き換えなければなりません。
その結果、発行されるトリガは、基底テーブルに付けられたトリガとなります。
   </para>

   <para>
<!--
    The trigger function must be defined before the trigger itself can be
    created.  The trigger function must be declared as a
    function taking no arguments and returning type <literal>trigger</literal>.
    (The trigger function receives its input through a specially-passed
    <structname>TriggerData</structname> structure, not in the form of ordinary function
    arguments.)
-->
トリガ関数は、トリガ自体が作成される前までに定義しておく必要があります。
トリガ関数は、引数を取らない、<literal>trigger</literal>型を返す関数として宣言される必要があります
（トリガ関数は、通常の関数で使用される引数という形ではなく、<structname>TriggerData</structname>構造体で入力を受け取ります）。
   </para>

   <para>
<!--
    Once a suitable trigger function has been created, the trigger is
    established with
    <xref linkend="sql-createtrigger"/>.
    The same trigger function can be used for multiple triggers.
-->
適切なトリガ関数が作成されると、<xref linkend="sql-createtrigger"/>を使用してトリガを構築することができます。
同一のトリガ関数を複数のトリガに使用することができます。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> offers both <firstterm>per-row</firstterm>
    triggers and <firstterm>per-statement</firstterm> triggers.  With a per-row
    trigger, the trigger function
    is invoked once for each row that is affected by the statement
    that fired the trigger. In contrast, a per-statement trigger is
    invoked only once when an appropriate statement is executed,
    regardless of the number of rows affected by that statement. In
    particular, a statement that affects zero rows will still result
    in the execution of any applicable per-statement triggers. These
    two types of triggers are sometimes called <firstterm>row-level</firstterm>
    triggers and <firstterm>statement-level</firstterm> triggers,
    respectively. Triggers on <command>TRUNCATE</command> may only be
    defined at statement level, not per-row.
-->
<productname>PostgreSQL</productname>は、<firstterm>行単位の</firstterm>トリガと<firstterm>文単位の</firstterm>トリガの両方を提供します。
行単位のトリガでは、トリガを発行した文によって影響を受ける行ごとにトリガ関数が呼び出されます。
反対に、文単位のトリガでは、適切な文が実行された時に、その文で何行が影響を受けたかどうかは関係なく、一度だけ呼び出されます。
特に、行に影響を与えない文であっても、適切な文単位のトリガがあれば実行されます。
この2種類のトリガはそれぞれ<firstterm>行レベル</firstterm>トリガと<firstterm>文レベル</firstterm>トリガと呼ばれることがあります。
<command>TRUNCATE</command>に対するトリガは、行単位ではなく、文レベルにのみに定義することができます。
   </para>

   <para>
<!--
    Triggers are also classified according to whether they fire
    <firstterm>before</firstterm>, <firstterm>after</firstterm>, or
    <firstterm>instead of</firstterm> the operation. These are referred to
    as <literal>BEFORE</literal> triggers, <literal>AFTER</literal> triggers, and
    <literal>INSTEAD OF</literal> triggers respectively.
    Statement-level <literal>BEFORE</literal> triggers naturally fire before the
    statement starts to do anything, while statement-level <literal>AFTER</literal>
    triggers fire at the very end of the statement.  These types of
    triggers may be defined on tables, views, or foreign tables.  Row-level
    <literal>BEFORE</literal> triggers fire immediately before a particular row is
    operated on, while row-level <literal>AFTER</literal> triggers fire at the end of
    the statement (but before any statement-level <literal>AFTER</literal> triggers).
    These types of triggers may only be defined on tables and
    foreign tables, not views.
    <literal>INSTEAD OF</literal> triggers may only be
    defined on views, and only at row level; they fire immediately as each
    row in the view is identified as needing to be operated on.
-->
また、トリガはそれらが操作の<firstterm>前</firstterm>、<firstterm>後</firstterm>または<firstterm>代わり</firstterm>のどれで実行されるかに応じて分けられます。
これらはそれぞれ<literal>BEFORE</literal>トリガ、<literal>AFTER</literal>トリガ、そして<literal>INSTEAD OF</literal>トリガと呼ばれます。
文レベルの<literal>BEFORE</literal>トリガは、もちろん文が何かを始める前に発行され、文レベルの<literal>AFTER</literal>トリガは文の本当に最後に発行されます。
これらのタイプのトリガはテーブル、ビュー、あるいは外部テーブルに定義できます。
行レベルの<literal>BEFORE</literal>トリガは、特定の行が操作される直前に発行され、行レベルの<literal>AFTER</literal>トリガは文の終わり（ただし、全ての文レベルの<literal>AFTER</literal>トリガの前）に発行されます。
これらのタイプのトリガは、外部テーブルに定義できますが、ビューには定義できません。
<literal>INSTEAD OF</literal>トリガはビューにのみ定義され、行レベルのみが許されます。
つまり、ビュー上のそれぞれの行で処理が必要と判断された場合には、即座に発動します。
   </para>

   <para>
<!--
    A statement that targets a parent table in an inheritance or partitioning
    hierarchy does not cause the statement-level triggers of affected child
    tables to be fired; only the parent table's statement-level triggers are
    fired.  However, row-level triggers of any affected child tables will be
    fired.
-->
継承あるいはパーティション階層において、親テーブルをターゲットとする文は、影響を受けた子テーブルの文レベルトリガを発動しません。
すなわち、親テーブルの文レベルトリガのみが発動します。
しかし、影響を受けた子テーブルの行レベルトリガは発動します。
   </para>

   <para>
<!--
    If an <command>INSERT</command> contains an <literal>ON CONFLICT
    DO UPDATE</literal> clause, it is possible that the effects of
    row-level <literal>BEFORE</literal> <command>INSERT</command> triggers and
    row-level <literal>BEFORE</literal> <command>UPDATE</command> triggers can
    both be applied in a way that is apparent from the final state of
    the updated row, if an <varname>EXCLUDED</varname> column is referenced.
    There need not be an <varname>EXCLUDED</varname> column reference for
    both sets of row-level <literal>BEFORE</literal> triggers to execute,
    though.  The
    possibility of surprising outcomes should be considered when there
    are both <literal>BEFORE</literal> <command>INSERT</command> and
    <literal>BEFORE</literal> <command>UPDATE</command> row-level triggers
    that change a row being inserted/updated (this can be
    problematic even if the modifications are more or less equivalent, if
    they're not also idempotent).  Note that statement-level
    <command>UPDATE</command> triggers are executed when <literal>ON
    CONFLICT DO UPDATE</literal> is specified, regardless of whether or not
    any rows were affected by the <command>UPDATE</command> (and
    regardless of whether the alternative <command>UPDATE</command>
    path was ever taken).  An <command>INSERT</command> with an
    <literal>ON CONFLICT DO UPDATE</literal> clause will execute
    statement-level <literal>BEFORE</literal> <command>INSERT</command>
    triggers first, then statement-level <literal>BEFORE</literal>
    <command>UPDATE</command> triggers, followed by statement-level
    <literal>AFTER</literal> <command>UPDATE</command> triggers and finally
    statement-level <literal>AFTER</literal> <command>INSERT</command>
    triggers.
-->
<command>INSERT</command>が<literal>ON CONFLICT DO UPDATE</literal>句を含む場合、<varname>EXCLUDED</varname>列が参照されていると、行単位<literal>BEFORE</literal> <command>INSERT</command>トリガおよび行単位<literal>BEFORE</literal> <command>UPDATE</command>トリガの両方の効果が適用され、それが更新後の行の最後の状態から明らかな場合がありえます。
ただし、両方の行レベルの<literal>BEFORE</literal>トリガを実行するために<varname>EXCLUDED</varname>の参照が必要なわけではありません。
驚くような結果の可能性について、<literal>BEFORE</literal> <command>INSERT</command>と<literal>BEFORE</literal> <command>UPDATE</command>の両方の文単位トリガーがあり、それらがいずれも挿入あるいは更新対象の行に影響を与える場合に考慮すべきです（これは更新が冪等ではないが、ほぼ同等であるときには、それでも問題になります）。
文単位の<command>UPDATE</command>トリガは<literal>ON CONFLICT DO UPDATE</literal>が指定されたとき、その<command>UPDATE</command>によって行が影響を受けたかどうかに関わらず（そしてその代替である<command>UPDATE</command>部分が実行されたかどうかに関わらず）実行されることに注意してください。
<literal>ON CONFLICT DO UPDATE</literal>句のある<command>INSERT</command>では、まず文単位の<literal>BEFORE</literal> <command>INSERT</command>トリガ、次に文単位の<literal>BEFORE</literal> <command>UPDATE</command>トリガ、次いで文単位の<literal>AFTER</literal> <command>UPDATE</command>トリガ、最後に文単位の<literal>AFTER</literal> <command>INSERT</command>トリガを実行します。
   </para>

   <para>
<!--
    If an <command>UPDATE</command> on a partitioned table causes a row to move
    to another partition, it will be performed as a <command>DELETE</command>
    from the original partition followed by an <command>INSERT</command> into
    the new partition. In this case, all row-level <literal>BEFORE</literal>
    <command>UPDATE</command> triggers and all row-level
    <literal>BEFORE</literal> <command>DELETE</command> triggers are fired on
    the original partition. Then all row-level <literal>BEFORE</literal>
    <command>INSERT</command> triggers are fired on the destination partition.
    The possibility of surprising outcomes should be considered when all these
    triggers affect the row being moved. As far as <literal>AFTER ROW</literal>
    triggers are concerned, <literal>AFTER</literal> <command>DELETE</command>
    and <literal>AFTER</literal> <command>INSERT</command> triggers are
    applied; but <literal>AFTER</literal> <command>UPDATE</command> triggers
    are not applied because the <command>UPDATE</command> has been converted to
    a <command>DELETE</command> and an <command>INSERT</command>. As far as
    statement-level triggers are concerned, none of the
    <command>DELETE</command> or <command>INSERT</command> triggers are fired,
    even if row movement occurs; only the <command>UPDATE</command> triggers
    defined on the target table used in the <command>UPDATE</command> statement
    will be fired.
-->
あるパーティション化されたテーブルに適用された<command>UPDATE</command>の結果、行が他のパーティションに移動することになるなら、元のパーティションで<command>DELETE</command>し、続いて新しいパーティションに<command>INSERT</command>する操作として実行されます。
この場合、すべての行レベル<literal>BEFORE</literal> <command>UPDATE</command>トリガと<literal>BEFORE</literal> <command>DELETE</command>トリガが元のパーティションで発動します。
そして、すべての行レベル<literal>BEFORE</literal> <command>INSERT</command>トリガが移動先のパーティションで発動します。
これらのトリガが移動対象の行に対して影響を及ぼす際に、驚くべき結果となる可能性を考慮しておくべきでしょう。
<literal>AFTER ROW</literal>トリガに関しては、<literal>AFTER</literal> <command>DELETE</command>と<literal>AFTER</literal> <command>INSERT</command>トリガが適用されます。しかし、<literal>AFTER</literal> <command>UPDATE</command>トリガは適用されません。なぜなら、<command>UPDATE</command>は<command>DELETE</command>と<command>INSERT</command>に変換されるからです。
文レベルのトリガに関しては、たとえ行の移動が起こったとしても<command>DELETE</command>トリガも<command>INSERT</command>トリガも発動されません。<command>UPDATE</command>文中に現れた対象テーブルに定義された<command>UPDATE</command>トリガだけが発動されます。
   </para>

   <para>
<!--
    Trigger functions invoked by per-statement triggers should always
    return <symbol>NULL</symbol>. Trigger functions invoked by per-row
    triggers can return a table row (a value of
    type <structname>HeapTuple</structname>) to the calling executor,
    if they choose.  A row-level trigger fired before an operation has
    the following choices:
-->
文単位のトリガによって呼び出されるトリガ関数は常に<symbol>NULL</symbol>を返さなければなりません。
行単位のトリガによって呼び出されるトリガ関数は呼び出し元のエクゼキュータにテーブル行（<structname>HeapTuple</structname>型の値）を返すように選択することができます。
操作前に発行された行レベルのトリガでは以下の選択肢があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       It can return <symbol>NULL</symbol> to skip the operation for the
       current row. This instructs the executor to not perform the
       row-level operation that invoked the trigger (the insertion,
       modification, or deletion of a particular table row).
-->
<symbol>NULL</symbol>を返して、現在の行への操作を飛ばすことができます。
これは、エクゼキュータにトリガの元になった行レベルの操作（特定のテーブル行の挿入、更新、削除）を行わないよう指示します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       For row-level <command>INSERT</command>
       and <command>UPDATE</command> triggers only, the returned row
       becomes the row that will be inserted or will replace the row
       being updated.  This allows the trigger function to modify the
       row being inserted or updated.
-->
行レベルの<command>INSERT</command>および<command>UPDATE</command>トリガの場合のみ、返される行が挿入される、もしくは実際に更新される行になります。
これにより、トリガ関数で、挿入される行もしくは更新される行を変更することができます。
      </para>
     </listitem>
    </itemizedlist>

<!--
    A row-level <literal>BEFORE</literal> trigger that does not intend to cause
    either of these behaviors must be careful to return as its result the same
    row that was passed in (that is, the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    triggers, the <varname>OLD</varname> row for
    <command>DELETE</command> triggers).
-->
これらの動作をさせたくない行レベルの<literal>BEFORE</literal>トリガについては、渡された行（つまり、<command>INSERT</command>および<command>UPDATE</command>トリガでは<varname>NEW</varname>行、<command>DELETE</command>の場合は<varname>OLD</varname>行）と同じ行結果を返すように気を付ける必要があります。
   </para>

   <para>
<!--
    A row-level <literal>INSTEAD OF</literal> trigger should either return
    <symbol>NULL</symbol> to indicate that it did not modify any data from
    the view's underlying base tables, or it should return the view
    row that was passed in (the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    operations, or the <varname>OLD</varname> row for
    <command>DELETE</command> operations). A nonnull return value is
    used to signal that the trigger performed the necessary data
    modifications in the view.  This will cause the count of the number
    of rows affected by the command to be incremented. For
    <command>INSERT</command> and <command>UPDATE</command> operations only, the trigger
    may modify the <varname>NEW</varname> row before returning it.  This will
    change the data returned by
    <command>INSERT RETURNING</command> or <command>UPDATE RETURNING</command>,
    and is useful when the view will not show exactly the same data
    that was provided.
-->
行レベルの<literal>INSTEAD OF</literal>トリガは、ビューの元となった元テーブルのデータをまったく変更しないことを表す<symbol>NULL</symbol>、または、渡されたビューの行（<command>INSERT</command>と<command>UPDATE</command>操作の場合<varname>NEW</varname>行、<command>DELETE</command>操作の場合<varname>OLD</varname>行）を返さなければなりません。
非NULLの戻り値は、そのトリガがビューにおいて必要なデータ変更を実行したことを通知するために使用されます。
これにより影響を受けた行数を数えるカウンタは増加されます。
<command>INSERT</command>と<command>UPDATE</command>操作のみ、トリガは戻す前に<varname>NEW</varname>行を変更することができます。
これは<command>INSERT RETURNING</command>または<command>UPDATE RETURNING</command>で返されるデータを変更しますので、ビューが提供されたデータと正確に同じ結果を返さない場合に有益です。
   </para>

   <para>
<!--
    The return value is ignored for row-level triggers fired after an
    operation, and so they can return <symbol>NULL</symbol>.
-->
操作の後に発生する行レベルトリガでは戻り値は無視されますので、これらは<symbol>NULL</symbol>を返すことができます。
   </para>

   <para>
<!--
    Some considerations apply for generated
    columns.<indexterm><primary>generated column</primary><secondary>in
    triggers</secondary></indexterm>  Stored generated columns are computed after
    <literal>BEFORE</literal> triggers and before <literal>AFTER</literal>
    triggers.  Therefore, the generated value can be inspected in
    <literal>AFTER</literal> triggers.  In <literal>BEFORE</literal> triggers,
    the <literal>OLD</literal> row contains the old generated value, as one
    would expect, but the <literal>NEW</literal> row does not yet contain the
    new generated value and should not be accessed.  In the C language
    interface, the content of the column is undefined at this point; a
    higher-level programming language should prevent access to a stored
    generated column in the <literal>NEW</literal> row in a
    <literal>BEFORE</literal> trigger.  Changes to the value of a generated
    column in a <literal>BEFORE</literal> trigger are ignored and will be
    overwritten.
-->
生成列に対してはいくつか考慮が必要です。<indexterm><primary>生成列</primary><secondary>トリガでの</secondary></indexterm>
格納された生成列は、<literal>BEFORE</literal>トリガの後、<literal>AFTER</literal>トリガの前に計算されます。
そのため、生成される値は<literal>AFTER</literal>トリガで調べることができます。
<literal>BEFORE</literal>トリガでは、皆さんが期待している通り<literal>OLD</literal>行は以前の生成された値を含んでいますが、<literal>NEW</literal>行は新しく生成される値をまだ含んでおらず、アクセスすべきではありません。
C言語インタフェースでは、この時点では列の内容は未定義です。高レベルプログラム言語は、<literal>BEFORE</literal>トリガ内では<literal>NEW</literal>行の生成列へのアクセスを避けるべきです。
<literal>BEFORE</literal>トリガでの生成列の値の変更は無視され、上書きされます。
   </para>

   <para>
<!--
    If more than one trigger is defined for the same event on the same
    relation, the triggers will be fired in alphabetical order by
    trigger name.  In the case of <literal>BEFORE</literal> and
    <literal>INSTEAD OF</literal> triggers, the possibly-modified row returned by
    each trigger becomes the input to the next trigger.  If any
    <literal>BEFORE</literal> or <literal>INSTEAD OF</literal> trigger returns
    <symbol>NULL</symbol>, the operation is abandoned for that row and subsequent
    triggers are not fired (for that row).
-->
同一リレーション、同一イベントに対して1つ以上のトリガが定義された場合、トリガはその名前のアルファベット順に発生します。
<literal>BEFORE</literal>トリガと<literal>INSTEAD OF</literal>トリガの場合では、各トリガで返される、変更された可能性がある行が次のトリガの入力となります。
もし、ある<literal>BEFORE</literal>トリガや<literal>INSTEAD OF</literal>トリガが<symbol>NULL</symbol>を返したら、(いまのところ)操作はその行で中断し、残りのトリガは発生しません。
   </para>

   <para>
<!--
    A trigger definition can also specify a Boolean <literal>WHEN</literal>
    condition, which will be tested to see whether the trigger should
    be fired.  In row-level triggers the <literal>WHEN</literal> condition can
    examine the old and/or new values of columns of the row.  (Statement-level
    triggers can also have <literal>WHEN</literal> conditions, although the feature
    is not so useful for them.)  In a <literal>BEFORE</literal> trigger, the
    <literal>WHEN</literal>
    condition is evaluated just before the function is or would be executed,
    so using <literal>WHEN</literal> is not materially different from testing the
    same condition at the beginning of the trigger function.  However, in
    an <literal>AFTER</literal> trigger, the <literal>WHEN</literal> condition is evaluated
    just after the row update occurs, and it determines whether an event is
    queued to fire the trigger at the end of statement.  So when an
    <literal>AFTER</literal> trigger's
    <literal>WHEN</literal> condition does not return true, it is not necessary
    to queue an event nor to re-fetch the row at end of statement.  This
    can result in significant speedups in statements that modify many
    rows, if the trigger only needs to be fired for a few of the rows.
    <literal>INSTEAD OF</literal> triggers do not support
    <literal>WHEN</literal> conditions.
-->
トリガ定義は、トリガを発動するかどうかを<literal>WHEN</literal>句の論理条件で指定することも可能です。行レベルトリガにおいて、<literal>WHEN</literal>条件は行の列の古い値と(あるいは)新しい値を検索することができます。(あまり有用ではありませんが、文レベルトリガでも<literal>WHEN</literal>条件で同じことができます。)<literal>BEFORE</literal>トリガでは、実質的にトリガ関数の開始時と同じ条件で検査できるように、<literal>WHEN</literal>条件の評価が関数の実施直前になされます。しかし<literal>AFTER</literal>トリガでは、<literal>WHEN</literal>条件の評価は行の更新直後に行われ、文の終わり(コミット時)にトリガを発動するためのイベントを待ち行列に入れるかどうかを決めます。そのため、ある<literal>AFTER</literal>トリガの<literal>WHEN</literal>条件が真を返さなかった場合は、イベントを待ち行列に入れる必要も文の終わりに行を再取得する必要もありません。これは、大量の行の変更が発生するけれども、トリガがその内の少数の行に対してのみ発動させる必要がある、といった文の処理速度を大幅に上げる効果があります。<literal>INSTEAD OF</literal>トリガは<literal>WHEN</literal>条件をサポートしていません。
   </para>

   <para>
<!--
    Typically, row-level <literal>BEFORE</literal> triggers are used for checking or
    modifying the data that will be inserted or updated.  For example,
    a <literal>BEFORE</literal> trigger might be used to insert the current time into a
    <type>timestamp</type> column, or to check that two elements of the row are
    consistent. Row-level <literal>AFTER</literal> triggers are most sensibly
    used to propagate the updates to other tables, or make consistency
    checks against other tables.  The reason for this division of labor is
    that an <literal>AFTER</literal> trigger can be certain it is seeing the final
    value of the row, while a <literal>BEFORE</literal> trigger cannot; there might
    be other <literal>BEFORE</literal> triggers firing after it.  If you have no
    specific reason to make a trigger <literal>BEFORE</literal> or
    <literal>AFTER</literal>, the <literal>BEFORE</literal> case is more efficient, since
    the information about
    the operation doesn't have to be saved until end of statement.
-->
通常、行レベルの<literal>BEFORE</literal>トリガは、挿入あるいは更新される予定のデータの検査や変更のために使用されます。
例えば、<literal>BEFORE</literal>トリガは、<type>timestamp</type>型の列に現在時刻を挿入するために、あるいは行の2つの要素の整合性を検査するために使用される可能性があります。
行レベルの<literal>AFTER</literal>トリガは、ほとんど常識的に他のテーブルに更新を伝播させるために、あるいは他のテーブルとの整合性を検査するために使用されます。
こうした仕事の切り分け理由は、<literal>AFTER</literal>トリガは行の最終値を見ることができ、<literal>BEFORE</literal>トリガは見ることができないという点です。
トリガを<literal>BEFORE</literal>にするか<literal>AFTER</literal>にするかを決める時に特別な理由がないのであれば、操作の情報を行が終わるまで保持する必要がない分、<literal>BEFORE</literal>を使う方が効率的です。
   </para>

   <para>
<!--
    If a trigger function executes SQL commands then these
    commands might fire triggers again. This is known as cascading
    triggers.  There is no direct limitation on the number of cascade
    levels.  It is possible for cascades to cause a recursive invocation
    of the same trigger; for example, an <command>INSERT</command>
    trigger might execute a command that inserts an additional row
    into the same table, causing the <command>INSERT</command> trigger
    to be fired again.  It is the trigger programmer's responsibility
    to avoid infinite recursion in such scenarios.
-->
トリガ関数がSQLコマンドを処理する場合、これらの問い合わせがトリガを再度発行することがあります。
これはカスケードされたトリガと呼ばれます。
カスケードの段数に直接的な制限はありません。
カスケードの場合、同じトリガを再帰的に呼び出すことが可能です。
例えば、<command>INSERT</command>トリガで同じテーブルに追加の行を挿入する問い合わせが実行された場合、その結果として<command>INSERT</command>トリガが再度発行されます。
こうした状況で無限再帰を防ぐのは、トリガプログラマの責任です。
   </para>

   <para>
    <indexterm>
<!--
     <primary>trigger</primary>
     <secondary>arguments for trigger functions</secondary>
-->
     <primary>トリガ</primary>
     <secondary>トリガ関数の引数</secondary>
    </indexterm>
<!--
    When a trigger is being defined, arguments can be specified for
    it. The purpose of including arguments in the
    trigger definition is to allow different triggers with similar
    requirements to call the same function.  As an example, there
    could be a generalized trigger function that takes as its
    arguments two column names and puts the current user in one and
    the current time stamp in the other.  Properly written, this
    trigger function would be independent of the specific table it is
    triggering on.  So the same function could be used for
    <command>INSERT</command> events on any table with suitable
    columns, to automatically track creation of records in a
    transaction table for example. It could also be used to track
    last-update events if defined as an <command>UPDATE</command>
    trigger.
-->
トリガを定義する時、そのトリガ用の引数を指定することができます。
トリガ定義に引数を含めた目的は、似たような要求の異なるトリガに同じ関数を呼び出すことができるようにすることです。
例えば、2つの列名を引数とし、片方に現在のユーザをもう片方に現在のタイムスタンプを取る、汎化トリガ関数があるとします。
適切に作成すれば、この関数が特定のトリガの発行元となるテーブルに依存することはなくなります。
同じ関数を使用して、例えば、トランザクションテーブルに作成記録を自動的に登録させるために、適切な列を持つ任意のテーブルの<command>INSERT</command>イベントに使用することができます。
また、<command>UPDATE</command>として定義すれば、最終更新イベントを追跡するために使用することも可能です。
   </para>

   <para>
<!--
    Each programming language that supports triggers has its own method
    for making the trigger input data available to the trigger function.
    This input data includes the type of trigger event (e.g.,
    <command>INSERT</command> or <command>UPDATE</command>) as well as any
    arguments that were listed in <command>CREATE TRIGGER</command>.
    For a row-level trigger, the input data also includes the
    <varname>NEW</varname> row for <command>INSERT</command> and
    <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> row
    for <command>UPDATE</command> and <command>DELETE</command> triggers.
-->
トリガをサポートするプログラミング言語はそれぞれ独自の方法で、トリガ関数で利用できるトリガの入力データを作成します。
この入力データにはトリガイベント種類（例えば<command>INSERT</command>や<command>UPDATE</command>など、<command>CREATE TRIGGER</command>で指定された全ての引数）が含まれます。
行レベルトリガの入力データには、<command>INSERT</command>および<command>UPDATE</command>トリガの場合は<varname>NEW</varname>行が、<command>UPDATE</command>および<command>DELETE</command>トリガの場合は<varname>OLD</varname>行が含まれます。
   </para>

   <para>
<!--
    By default, statement-level triggers do not have any way to examine the
    individual row(s) modified by the statement.  But an <literal>AFTER
    STATEMENT</literal> trigger can request that <firstterm>transition tables</firstterm>
    be created to make the sets of affected rows available to the trigger.
    <literal>AFTER ROW</literal> triggers can also request transition tables, so
    that they can see the total changes in the table as well as the change in
    the individual row they are currently being fired for.  The method for
    examining the transition tables again depends on the programming language
    that is being used, but the typical approach is to make the transition
    tables act like read-only temporary tables that can be accessed by SQL
    commands issued within the trigger function.
-->
デフォルトでは、文レベルトリガには文によって変更された個々の行を検査するための手段がありません。
しかし、トリガがアクセスできる影響を受けた行の集合を作成するために、<literal>AFTER STATEMENT</literal>トリガは、<firstterm>遷移テーブル(transition tables)</firstterm>の作成を依頼することができます。
<literal>AFTER ROW</literal>トリガも遷移テーブルを依頼できるので、発動中の個々の行における変更だけでなく、テーブル全体におけるすべての変更を見ることができます。
遷移テーブルを検査する方法も使用中のプログラミング言語に依存しますが、典型的な方法は、トリガ関数の中で発行するSQLコマンドでアクセスできる、読み込み専用の一時テーブルのように振る舞う遷移テーブルを作成することです。
   </para>

  </sect1>

  <sect1 id="trigger-datachanges">
<!--
   <title>Visibility of Data Changes</title>
-->
   <title>データ変更の可視性</title>

   <para>
<!--
    If you execute SQL commands in your trigger function, and these
    commands access the table that the trigger is for, then
    you need to be aware of the data visibility rules, because they determine
    whether these SQL commands will see the data change that the trigger
    is fired for.  Briefly:
-->
トリガ関数内でSQLコマンドを実行し、このコマンドがトリガの元となったテーブルにアクセスする場合、データの可視性規則に注意する必要があります。
この規則が、SQLコマンドがトリガの発行原因となったデータ変更を見ることができるかどうかを決定するからです。
簡単に以下に示します。

    <itemizedlist>

     <listitem>
      <para>
<!--
       Statement-level triggers follow simple visibility rules: none of
       the changes made by a statement are visible to statement-level
       <literal>BEFORE</literal> triggers, whereas all
       modifications are visible to statement-level <literal>AFTER</literal>
       triggers.
-->
文レベルトリガは次に示す簡単な可視性規則に従います。
文によってなされた変更は、文レベルの<literal>BEFORE</literal>トリガでは不可視です。
一方、文レベルの<literal>AFTER</literal>トリガでは全ての変更が可視です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The data change (insertion, update, or deletion) causing the
       trigger to fire is naturally <emphasis>not</emphasis> visible
       to SQL commands executed in a row-level <literal>BEFORE</literal> trigger,
       because it hasn't happened yet.
-->
当然ながら行レベルの<literal>BEFORE</literal>トリガ内のSQLコマンドでは、トリガの発生原因となったデータ変更（挿入、更新、削除）はまだ発生していませんので、可視<emphasis>ではありません</emphasis>。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       However, SQL commands executed in a row-level <literal>BEFORE</literal>
       trigger <emphasis>will</emphasis> see the effects of data
       changes for rows previously processed in the same outer
       command.  This requires caution, since the ordering of these
       change events is not in general predictable; a SQL command that
       affects multiple rows can visit the rows in any order.
-->
しかし、行レベルの<literal>BEFORE</literal>トリガで実行されるSQLコマンドは、その外側のコマンドで以前に処理された行へのデータ変更の影響を見る<emphasis>ことになるでしょう</emphasis>。
これらの変更イベントの順序は一般的に予測できませんので、注意が必要です。
複数行に影響するSQLコマンドはどのような順番でもその行を更新することができます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Similarly, a row-level <literal>INSTEAD OF</literal> trigger will see the
       effects of data changes made by previous firings of <literal>INSTEAD
       OF</literal> triggers in the same outer command.
-->
同様に、行レベルの<literal>INSTEAD OF</literal>トリガは、同じ外側のコマンドで以前に処理された<literal>INSTEAD OF</literal>トリガよる変更結果を見ることになるでしょう。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When a row-level <literal>AFTER</literal> trigger is fired, all data
       changes made
       by the outer command are already complete, and are visible to
       the invoked trigger function.
-->
行レベルの<literal>AFTER</literal>トリガが発生すると、その外側のコマンドによってなされた全ての変更は既に完了していますので、呼び出されたトリガ関数から可視になります。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    If your trigger function is written in any of the standard procedural
    languages, then the above statements apply only if the function is
    declared <literal>VOLATILE</literal>.  Functions that are declared
    <literal>STABLE</literal> or <literal>IMMUTABLE</literal> will not see changes made by
    the calling command in any case.
-->
もし、あなたのトリガが標準的な手続き型言語のいずれかで記述されている時、上記の可視性は関数が<literal>VOLATILE</literal>で定義されている場合のみ適用されます。
<literal>STABLE</literal>、もしくは<literal>IMMUTABLE</literal>で定義されている関数は、どのようなケースにおいても、呼び出しコマンドによる変更は見ないでしょう。
   </para>

   <para>
<!--
    Further information about data visibility rules can be found in
    <xref linkend="spi-visibility"/>.  The example in <xref
    linkend="trigger-example"/> contains a demonstration of these rules.
-->
データ可視性規則に関する詳細は<xref linkend="spi-visibility"/>にあります。
<xref linkend="trigger-example"/>の例にこの規則を示します。
   </para>
  </sect1>

  <sect1 id="trigger-interface">
<!--
   <title>Writing Trigger Functions in C</title>
-->
   <title>Cによるトリガ関数の作成</title>

   <indexterm zone="trigger-interface">
<!--
    <primary>trigger</primary>
    <secondary>in C</secondary>
-->
    <primary>トリガ</primary>
    <secondary>Cによる</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>transition tables</primary>
    <secondary>referencing from C trigger</secondary>
-->
    <primary>遷移テーブル</primary>
    <secondary>Cトリガからの参照</secondary>
   </indexterm>

   <para>
<!--
    This section describes the low-level details of the interface to a
    trigger function.  This information is only needed when writing
    trigger functions in C.  If you are using a higher-level language then
    these details are handled for you.  In most cases you should consider
    using a procedural language before writing your triggers in C.  The
    documentation of each procedural language explains how to write a
    trigger in that language.
-->
本節ではトリガ関数とのインタフェースについて低レベルな詳細を説明します。
この情報はC言語でトリガ関数を作成する時にのみ必要です。
高レベルな言語で作成すれば、こうした詳細は代わりに扱ってもらえます。
たいていの場合、Cでトリガを作成する前に手続き言語を使用することを検討すべきです。
各手続き言語の文書で、その言語を使用したトリガの作成方法を説明します。
   </para>

   <para>
<!--
    Trigger functions must use the <quote>version 1</quote> function manager
    interface.
-->
トリガ関数は<quote>version 1</quote>関数マネージャインタフェースを使わなくてはいけません。
   </para>

   <para>
<!--
    When a function is called by the trigger manager, it is not passed
    any normal arguments, but it is passed a <quote>context</quote>
    pointer pointing to a <structname>TriggerData</structname> structure.  C
    functions can check whether they were called from the trigger
    manager or not by executing the macro:
-->
関数がトリガマネージャから呼び出される時は、通常の引数が渡されるのではなく、<structname>TriggerData</structname>構造体を指す<quote>context</quote>ポインタが渡されます。
C関数は、トリガマネージャから呼び出されたのかどうかを以下のマクロを実行することで検査することができます。
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
<!--
    which expands to:
-->
これは以下に展開されます。
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
<!--
    If this returns true, then it is safe to cast
    <literal>fcinfo-&gt;context</literal> to type <literal>TriggerData
    *</literal> and make use of the pointed-to
    <structname>TriggerData</structname> structure.  The function must
    <emphasis>not</emphasis> alter the <structname>TriggerData</structname>
    structure or any of the data it points to.
-->
もしこれが真を返す場合、<literal>fcinfo-&gt;context</literal>を<literal>TriggerData *</literal>型にキャストし、指された<structname>TriggerData</structname>構造体を使用することは安全です。
その関数は、<structname>TriggerData</structname>構造体やそれが指すどのようなデータも変更しては<emphasis>いけません</emphasis>。
   </para>

   <para>
<!--
    <structname>struct TriggerData</structname> is defined in
    <filename>commands/trigger.h</filename>:
-->
<structname>struct TriggerData</structname>は<filename>commands/trigger.h</filename>の中で定義されています。

<programlisting>
typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    TupleTableSlot  *tg_trigslot;
    TupleTableSlot  *tg_newslot;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
    const Bitmapset *tg_updatedcols;
} TriggerData;
</programlisting>

<!--
    where the members are defined as follows:
-->
メンバは下記のように定義されています。

    <variablelist>
     <varlistentry>
      <term><structfield>type</structfield></term>
      <listitem>
       <para>
<!--
        Always <literal>T_TriggerData</literal>.
-->
常に<literal>T_TriggerData</literal>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</structfield></term>
      <listitem>
       <para>
<!--
        Describes the event for which the function is called. You can use the
        following macros to examine <literal>tg_event</literal>:
-->
その関数が呼び出されたイベントを記述します。
<literal>tg_event</literal>を調べるためには下記のマクロを使うことができます。

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired before the operation.
-->
トリガが操作の前に(before)発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired after the operation.
-->
トリガが操作の後に(after)発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired instead of the operation.
-->
トリガがINSTEAD OFで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired for a row-level event.
-->
トリガが行レベルのイベントで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired for a statement-level event.
-->
トリガが文レベルのイベントで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by an <command>INSERT</command> command.
-->
トリガが<command>INSERT</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by an <command>UPDATE</command> command.
-->
トリガが<command>UPDATE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by a <command>DELETE</command> command.
-->
トリガが<command>DELETE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by a <command>TRUNCATE</command> command.
-->
トリガが<command>TRUNCATE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to a structure describing the relation that the trigger fired for.
        Look at <filename>utils/rel.h</filename> for details about
        this structure.  The most interesting things are
        <literal>tg_relation-&gt;rd_att</literal> (descriptor of the relation
        tuples) and <literal>tg_relation-&gt;rd_rel-&gt;relname</literal>
        (relation name; the type is not <type>char*</type> but
        <type>NameData</type>; use
        <literal>SPI_getrelname(tg_relation)</literal> to get a <type>char*</type> if you
        need a copy of the name).
-->
トリガの発行元のリレーションを記述する構造体へのポインタです。
この構造体についての詳細は、<filename>utils/rel.h</filename>を参照してください。
最も興味深いのは、<literal>tg_relation-&gt;rd_att</literal>（リレーションタプルの記述子）と<literal>tg_relation-&gt;rd_rel->relname</literal>です（リレーション名、これは<type>char*</type>ではなく<type>NameData</type>です。
名前のコピーが必要な場合は、<type>char*</type>を得るために<literal>SPI_getrelname(tg_relation)</literal>を使用してください）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to the row for which the trigger was fired. This is
        the row being inserted, updated, or deleted.  If this trigger
        was fired for an <command>INSERT</command> or
        <command>DELETE</command> then this is what you should return
        from the function if you don't want to replace the row with
        a different one (in the case of <command>INSERT</command>) or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
-->
トリガが発行された行へのポインタです。
これは挿入される、削除される、あるいは更新される行です。
もし<command>INSERT</command>/<command>DELETE</command>でこのトリガが発行された時、この行を別のもので置き換えたくない（<command>INSERT</command>の場合）場合や、その操作を飛ばしたくない場合は、これをこの関数から返してください。
外部テーブルのトリガに対しては、システム列の値はここでは指定されません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to the new version of the row, if the trigger was
        fired for an <command>UPDATE</command>, and <symbol>NULL</symbol> if
        it is for an <command>INSERT</command> or a
        <command>DELETE</command>. This is what you have to return
        from the function if the event is an <command>UPDATE</command>
        and you don't want to replace this row by a different one or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
-->
トリガが<command>UPDATE</command>で発行された場合は、行の新しいバージョンへのポインタです。
<command>INSERT</command>もしくは<command>DELETE</command>の場合は、<symbol>NULL</symbol>です。
<command>UPDATE</command>イベントの時、この行を別のもので置き換えたくない場合や操作を飛ばしたくない場合は、これをこの関数から返してください。
外部テーブルのトリガに対しては、システム列の値はここでは指定されません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to a structure of type <structname>Trigger</structname>,
        defined in <filename>utils/reltrigger.h</filename>:
-->
以下のように<filename>utils/reltrigger.h</filename>で定義された、<structname>Trigger</structname>構造体へのポインタです。

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
</programlisting>

<!--
       where <structfield>tgname</structfield> is the trigger's name,
       <structfield>tgnargs</structfield> is the number of arguments in
       <structfield>tgargs</structfield>, and <structfield>tgargs</structfield> is an array of
       pointers to the arguments specified in the <command>CREATE
       TRIGGER</command> statement. The other members are for internal use
       only.
-->
ここで、<structfield>tgname</structfield>がトリガの名前、<structfield>tgnargs</structfield>が<structfield>tgargs</structfield>内の引数の数、<structfield>tgargs</structfield>は<command>CREATE TRIGGER</command>文で指定された引数へのポインタの配列です。
他のメンバは内部でのみ使用されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigslot</structfield></term>
      <listitem>
       <para>
<!--
        The slot containing <structfield>tg_trigtuple</structfield>,
        or a <symbol>NULL</symbol> pointer if there is no such tuple.
-->
<structfield>tg_trigtuple</structfield>を含むスロット、またはタプルが存在しない場合は<symbol>NULL</symbol>ポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newslot</structfield></term>
      <listitem>
       <para>
<!--
        The slot containing <structfield>tg_newtuple</structfield>,
        or a <symbol>NULL</symbol> pointer if there is no such tuple.
-->
<structfield>tg_newtuple</structfield>を含むスロット、またはタプルが存在しない場合は<symbol>NULL</symbol>ポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_oldtable</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer
        if there is no <literal>OLD TABLE</literal> transition relation.
-->
<structfield>tg_relation</structfield>で指定するフォーマットの0以上の行を含む<structname>Tuplestorestate</structname>型の構造体へのポインタです。
<literal>OLD TABLE</literal>遷移リレーションが存在しない場合は<symbol>NULL</symbol>ポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtable</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer
        if there is no <literal>NEW TABLE</literal> transition relation.
-->
<structfield>tg_relation</structfield>で指定するフォーマットの0以上の行を含む<structname>Tuplestorestate</structname>型の構造体へのポインタです。
<literal>NEW TABLE</literal>遷移リレーションが存在しない場合は<symbol>NULL</symbol>ポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_updatedcols</structfield></term>
      <listitem>
       <para>
<!--
        For <literal>UPDATE</literal> triggers, a bitmap set indicating the
        columns that were updated by the triggering command.  Generic trigger
        functions can use this to optimize actions by not having to deal with
        columns that were not changed.
-->
<literal>UPDATE</literal>トリガに対しては、トリガコマンドにより更新された列を示すビットマップ集合です。
汎用のトリガ関数はこれを使って、変更されていない列を扱わないことで動作を最適化できます。
       </para>

       <para>
<!--
        As an example, to determine whether a column with attribute number
        <varname>attnum</varname> (1-based) is a member of this bitmap set,
        call <literal>bms_is_member(attnum -
        FirstLowInvalidHeapAttributeNumber,
        trigdata->tg_updatedcols))</literal>.
-->
例として、属性番号<varname>attnum</varname>(1始まり)の列がこのビットマップ集合のメンバであるかどうか判定するために、<literal>bms_is_member(attnum - FirstLowInvalidHeapAttributeNumber, trigdata->tg_updatedcols))</literal>を呼び出します。
       </para>

       <para>
<!--
        For triggers other than <literal>UPDATE</literal> triggers, this will
        be <symbol>NULL</symbol>.
-->
<literal>UPDATE</literal>トリガ以外のトリガに対しては、これは<symbol>NULL</symbol>になります。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    To allow queries issued through SPI to reference transition tables, see
    <xref linkend="spi-spi-register-trigger-data"/>.
-->
SPIを使って遷移テーブルを参照するクエリを発行する方法については、<xref linkend="spi-spi-register-trigger-data"/>を参照してください。
   </para>

   <para>
<!--
    A trigger function must return either a
    <structname>HeapTuple</structname> pointer or a <symbol>NULL</symbol> pointer
    (<emphasis>not</emphasis> an SQL null value, that is, do not set <parameter>isNull</parameter> true).
    Be careful to return either
    <structfield>tg_trigtuple</structfield> or <structfield>tg_newtuple</structfield>,
    as appropriate, if you don't want to modify the row being operated on.
-->
トリガ関数は<structname>HeapTuple</structname>ポインタもしくは<symbol>NULL</symbol>ポインタ（SQLのNULLでは<emphasis>ありません</emphasis>。
したがって、<parameter>isNull</parameter>は真にはなりません）のどちらかを返さなければなりません。
操作対象の行を変更したくない場合は、注意して、<structfield>tg_trigtuple</structfield>か<structfield>tg_newtuple</structfield>の適切な方を返してください。
   </para>
  </sect1>

  <sect1 id="trigger-example">
<!--
   <title>A Complete Trigger Example</title>
-->
   <title>完全なトリガの例</title>

   <para>
<!--
    Here is a very simple example of a trigger function written in C.
    (Examples of triggers written in procedural languages can be found
    in the documentation of the procedural languages.)
-->
C言語で作成したトリガ関数に関するとても簡単な例をここに示します
（手続き言語で作成したトリガの例は、その手続き言語の文書に記載されています。）
   </para>

   <para>
<!--
    The function <function>trigf</function> reports the number of rows in the
    table <structname>ttest</structname> and skips the actual operation if the
    command attempts to insert a null value into the column
    <structfield>x</structfield>. (So the trigger acts as a not-null constraint but
    doesn't abort the transaction.)
-->
<function>trigf</function>関数は、<structname>ttest</structname>テーブル内にある行数を報告し、問い合わせが<structfield>x</structfield>にNULL値を挿入しようとしていた場合は、その操作を飛ばします
（つまり、このトリガは、トランザクションを中断させないNOT NULL制約のような動作をします。）
   </para>

   <para>
<!--
    First, the table definition:
-->
まず、以下のようにテーブルを定義します。
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>

   <para>
<!--
    This is the source code of the trigger function:
-->
以下がトリガ関数のソースコードです。
<programlisting><![CDATA[
#include "postgres.h"
#include "fmgr.h"
]]>

<!--
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */
-->

<![CDATA[
#include "executor/spi.h"       /* これはSPIを使用する場合に必要なもの */
#include "commands/trigger.h"   /* これはトリガで必要なもの */
#include "utils/rel.h"          /* これはリレーションで必要なもの */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

]]>

<!--
    /* make sure it's called as a trigger at all */
-->

<![CDATA[
    /* トリガとして呼び出されたかどうかを確認 */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");
]]>

<!--
    /* tuple to return to executor */
-->

<![CDATA[
    /* エクゼキュータに返すタプル */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;
]]>

<!--
    /* check for null values */
-->

<![CDATA[
    /* NULL値をチェック */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;
]]>

<!--
    /* connect to SPI manager */
-->

<![CDATA[
    /* SPIマネージャに接続 */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);
]]>

<!--
    /* get number of rows in table */
-->

<![CDATA[
    /* テーブル中の行数を取得 */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);
]]>

<!--
    /* count(*) returns int8, so be careful to convert */
-->

<![CDATA[
    /* count(*)はint8を返す。変換に注意してください*/
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>

   <para>
<!--
    After you have compiled the source code (see <xref
    linkend="dfunc"/>), declare the function and the triggers:
-->
ソースコードをコンパイル（<xref linkend="dfunc"/>を参照してください）した後に、以下の様に関数とトリガを宣言します。
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE FUNCTION trigf();
</programlisting>
   </para>

   <para>
<!--
    Now you can test the operation of the trigger:
-->
これで、トリガの操作を確認することができます。
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

<!--
&#045;&#045; Insertion skipped and AFTER trigger is not fired
-->
-- 挿入操作は飛ばされ、また、AFTERトリガも発行されません。

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>

   <para>
<!--
    There are more complex examples in
    <filename>src/test/regress/regress.c</filename> and
    in <xref linkend="contrib-spi"/>.
-->
<filename>src/test/regress/regress.c</filename>と<xref linkend="contrib-spi"/>にはもっと複雑な例があります。
   </para>
  </sect1>
 </chapter>
