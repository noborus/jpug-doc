<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func2-start -->
  <sect1 id="functions-formatting">
<!--
   <title>Data Type Formatting Functions</title>
-->
   <title>データ型書式設定関数</title>

   <indexterm>
    <primary>formatting</primary>
   </indexterm>
   <indexterm>
    <primary>書式設定</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
-->
<productname>PostgreSQL</productname>の書式設定関数は多彩なデータ型（日付/時刻データ型、整数データ型、浮動小数点数データ型、数値データ型）を整形された文字列に変換したり、整形された文字列を特定のデータ型に変換する強力なツールの一式を提供しています。
<xref linkend="functions-formatting-table"/>にこれらを列挙しています。
これら関数は共通の呼び出し規約を踏襲しています。最初の引数は整形される値で2番目の引数は入力書式または出力書式を定義するテンプレートです。
   </para>

   <table id="functions-formatting-table">

<!--
    <title>Formatting Functions</title>
-->
    <title>書式設定関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts time stamp to string according to the given format.
-->
与えられた書式設定にしたがってタイムスタンプを文字列に変換します。
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts interval to string according to the given format.
-->
与えられた書式設定にしたがって時間間隔を文字列に変換します。
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts number to string according to the given format; available
        for <type>integer</type>, <type>bigint</type>, <type>numeric</type>,
        <type>real</type>, <type>double precision</type>.
-->
与えられた書式設定にしたがって数値を文字列に変換します。<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type>、<type>double precision</type>で利用可能です。
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
<!--
        Converts string to date according to the given format.
-->
与えられた書式設定にしたがって文字列を日付に変換します。
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Converts string to numeric according to the given format.
-->
与えられた書式設定にしたがって文字列を数値に変換します。
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
<!--
        Converts string to time stamp according to the given format.
        (See also <function>to_timestamp(double precision)</function> in
        <xref linkend="functions-datetime-table"/>.)
-->
与えられた書式設定にしたがって文字列をタイムスタンプに変換します。
（<xref linkend="functions-datetime-table"/>の<function>to_timestamp(double precision)</function>もご覧ください。）
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <tip>
    <para>
<!--
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
-->
<function>to_timestamp</function>と<function>to_date</function>は、単純なキャストでは変換できない入力フォーマットを処理するために存在します。
ほとんどの標準的日付および時刻のフォーマットに対しては、入力文字列を必要なデータ型に単純にキャストすれば動作し、その方がずっと簡単です。
同様に、<function>to_number</function>も標準的な数値表現に対しては不要です。
    </para>
   </tip>

   <para>
<!--
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
-->
<function>to_char</function>用の出力テンプレート文字列には、値に基づいて認識され、適切に整形されたデータで置き換えられるパターンがあります。
テンプレートパターンではない全てのテキストは単にそのままコピーされます。
同様に、（その他の関数用の）入力テンプレート文字列では、テンプレートパターンは入力されたデータ文字列で供給される値を特定します。
テンプレート文字列中にテンプレートパターンではない文字があれば、（テンプレート文字列の文字と同じかどうかにかかわらず）入力文字列データ中の該当文字は単にスキップされます。
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
-->
<xref linkend="functions-formatting-datetime-table"/>に、日付/時刻型の値の書式に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-datetime-table">
<!--
     <title>Template Patterns for Date/Time Formatting</title>
-->
     <title>日付/時刻型の書式テンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
<!--
        <entry>hour of day (01&ndash;12)</entry>
-->
        <entry>時 (01&ndash;12)</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
<!--
        <entry>hour of day (01&ndash;12)</entry>
-->
        <entry>時 (01&ndash;12)</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
<!--
        <entry>hour of day (00&ndash;23)</entry>
-->
        <entry>時 (00&ndash;23)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minute (00&ndash;59)</entry>
-->
        <entry>分 (00&ndash;59)</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
<!--
        <entry>second (00&ndash;59)</entry>
-->
        <entry>秒 (00&ndash;59)</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
<!--
        <entry>millisecond (000&ndash;999)</entry>
-->
        <entry>ミリ秒 (000&ndash;999)</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
<!--
        <entry>microsecond (000000&ndash;999999)</entry>
-->
        <entry>マイクロ秒 (000000&ndash;999999)</entry>
       </row>
       <row>
        <entry><literal>FF1</literal></entry>
<!--
        <entry>tenth of second (0&ndash;9)</entry>
-->
        <entry>10分の1秒 (0&ndash;9)</entry>
       </row>
       <row>
        <entry><literal>FF2</literal></entry>
<!--
        <entry>hundredth of second (00&ndash;99)</entry>
-->
        <entry>100分の1秒 (00&ndash;99)</entry>
       </row>
       <row>
        <entry><literal>FF3</literal></entry>
<!--
        <entry>millisecond (000&ndash;999)</entry>
-->
        <entry>ミリ秒 (000&ndash;999)</entry>
       </row>
       <row>
        <entry><literal>FF4</literal></entry>
<!--
        <entry>tenth of a millisecond (0000&ndash;9999)</entry>
-->
        <entry>10分の1ミリ秒 (0000&ndash;9999)</entry>
       </row>
       <row>
        <entry><literal>FF5</literal></entry>
<!--
        <entry>hundredth of a millisecond (00000&ndash;99999)</entry>
-->
        <entry>100分の1ミリ秒 (00000&ndash;99999)</entry>
       </row>
       <row>
        <entry><literal>FF6</literal></entry>
<!--
        <entry>microsecond (000000&ndash;999999)</entry>
-->
        <entry>マイクロ秒 (000000&ndash;999999)</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
<!--
        <entry>seconds past midnight (0&ndash;86399)</entry>
-->
        <entry>深夜0時からの秒数 (0&ndash;86399)</entry>
       </row>
       <row>
<!--
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
-->
        <entry><literal>AM</literal>、<literal>am</literal>、<literal>PM</literal>または<literal>pm</literal></entry>
<!--
        <entry>meridiem indicator (without periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
-->
        <entry><literal>A.M.</literal>、<literal>a.m.</literal>、<literal>P.M.</literal>または<literal>p.m.</literal></entry>
<!--
        <entry>meridiem indicator (with periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドあり）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
<!--
        <entry>year (4 or more digits) with comma</entry>
-->
        <entry>コンマ付き年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
<!--
        <entry>year (4 or more digits)</entry>
-->
        <entry>年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
<!--
        <entry>last 3 digits of year</entry>
-->
        <entry>年の下3桁</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
<!--
        <entry>last 2 digits of year</entry>
-->
        <entry>年の下2桁</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
<!--
        <entry>last digit of year</entry>
-->
        <entry>年の下1桁</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
<!--
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
-->
        <entry>ISO 8601週番号年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
<!--
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下3桁</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
<!--
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下2桁</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
<!--
        <entry>last digit of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下1桁</entry>
       </row>
       <row>
<!--
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
-->
        <entry><literal>BC</literal>、<literal>bc</literal>、
        <literal>AD</literal>、または<literal>ad</literal></entry>
<!--
        <entry>era indicator (without periods)</entry>
-->
        <entry>紀元前後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
-->
        <entry><literal>B.C.</literal>、<literal>b.c.</literal>、
        <literal>A.D.</literal>、または<literal>a.d.</literal></entry>
<!--
        <entry>era indicator (with periods)</entry>
-->
        <entry>紀元前後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
<!--
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
<!--
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
<!--
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
<!--
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字での短縮形の月名（英語では3文字、現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
<!--
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
<!--
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
<!--
        <entry>month number (01&ndash;12)</entry>
-->
        <entry>月番号(01&ndash;12)</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
<!--
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
<!--
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
<!--
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
<!--
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>短縮形の大文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
<!--
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
<!--
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
<!--
        <entry>day of year (001&ndash;366)</entry>
-->
        <entry>通年の日にち番号 (001&ndash;366)</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
<!--
        <entry>day of ISO 8601 week-numbering year (001&ndash;371; day 1 of the year is Monday of the first ISO week)</entry>
-->
        <entry>ISO 8601週番号年の日にち番号（001&ndash;371：通年 第１日は最初のISO週の月曜日）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
<!--
        <entry>day of month (01&ndash;31)</entry>
-->
        <entry>月内の日にち番号 (01&ndash;31)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
-->
        <entry>曜日番号、日曜日（<literal>1</literal>）から土曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
<!--
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
-->
        <entry>ISO 8601の曜日番号、月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
<!--
        <entry>week of month (1&ndash;5) (the first week starts on the first day of the month)</entry>
-->
        <entry>月中の週番号 (1&ndash;5)（その月の初日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
<!--
        <entry>week number of year (1&ndash;53) (the first week starts on the first day of the year)</entry>
-->
        <entry>年間を通じた週番号 (1&ndash;53)（元日のある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
<!--
        <entry>week number of ISO 8601 week-numbering year (01&ndash;53; the first Thursday of the year is in week 1)</entry>
-->
        <entry>ISO 8601週番号年の年間を通じた週番号 (01&ndash;53;新年の最初の木曜日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
<!--
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
-->
        <entry>世紀（2桁。21世紀は2001-01-01から開始）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
<!--
        <entry>Julian Date (integer days since November 24, 4714 BC at local
        midnight; see <xref linkend="datetime-julian-dates"/>)</entry>
-->
        <entry>ユリウス日（紀元前4714年11月24日現地時間午前零時からの整数による通算経過日。<xref linkend="datetime-julian-dates"/>参照）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
<!--
        <entry>quarter</entry>
-->
        <entry>四半期</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
<!--
        <entry>month in upper case Roman numerals (I&ndash;XII; I=January)</entry>
-->
        <entry>大文字ローマ数字による月（I&ndash;XII、Iは1月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
<!--
        <entry>month in lower case Roman numerals (i&ndash;xii; i=January)</entry>
-->
        <entry>小文字ローマ数字による月（(i&ndash;xii、iは1月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
<!--
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>大文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
<!--
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>小文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
       <entry><literal>TZH</literal></entry>
<!--
        <entry>time-zone hours</entry>
-->
        <entry>time-zoneの時間</entry>
       </row>
       <row>
       <entry><literal>TZM</literal></entry>
<!--
        <entry>time-zone minutes</entry>
-->
        <entry>time-zoneの分</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
<!--
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>UTCからの時間帯オフセット（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
-->
どのようなテンプレートパターンに対しても、その振舞いを変更するために修飾子を適用できます。
例えば、<literal>FMMonth</literal>は<literal>FM</literal>修飾子の付いた<literal>Month</literal>パターンです。
<xref linkend="functions-formatting-datetimemod-table"/>に、日付/時刻書式の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
-->
     <title>日付/時刻書式用のテンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>接頭辞</entry>
<!--
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
-->
        <entry>字詰めモード（先頭の0、およびを空白のパディングを無効）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>接尾辞</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
-->
        <entry><literal>DDTH</literal>、例えば<literal>12TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>接尾辞</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
-->
        <entry><literal>DDth</literal>、例えば<literal>12th</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>FX</literal> prefix</entry>
-->
        <entry><literal>FX</literal>接頭辞</entry>
<!--
        <entry>fixed format global option (see usage notes)</entry>
-->
        <entry>固定書式のグローバルオプション（使用上の注意事項を参照）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TM</literal> prefix</entry>
-->
        <entry><literal>TM</literal>接頭辞</entry>
<!--
        <entry>translation mode (use localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
-->
        <entry>翻訳モード（<xref linkend="guc-lc-time"/>に基づき、現地語化された曜日、月名を使います)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>SP</literal> suffix</entry>
-->
        <entry><literal>SP</literal>接尾辞</entry>
<!--
        <entry>spell mode (not implemented)</entry>
-->
        <entry>スペルモード（未実装）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for date/time formatting:
-->
日付/時刻型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
-->
<literal>FM</literal>は、先頭にはゼロ、末尾には空白を追加してパターンを固定長にする機能を無効にします。
<productname>PostgreSQL</productname>では、<literal>FM</literal>はその次に記述されたものだけを変更します。一方Oracleでは、<literal>FM</literal>はそれに続く全ての記述に対して影響し、<literal>FM</literal>修飾詞を繰り返すと、ゼロや空白を埋めるモードのオンとオフが切り替わります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TM</literal> suppresses trailing blanks whether or
       not <literal>FM</literal> is specified.
-->
<literal>FM</literal>が指定されているかどうかに関わらず<literal>TM</literal>は末尾の空白を抑止します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       ignore letter case in the input; so for
       example <literal>MON</literal>, <literal>Mon</literal>,
       and <literal>mon</literal> all accept the same strings.  When using
       the <literal>TM</literal> modifier, case-folding is done according to
       the rules of the function's input collation (see
       <xref linkend="collation"/>).
-->
<function>to_timestamp</function>と<function>to_date</function>は入力中の大文字小文字の区別を無視します。
例えば<literal>MON</literal>、<literal>Mon</literal>、<literal>mon</literal>はすべて同じ文字列として受け付けます。
<literal>TM</literal>修飾子を使うと関数の入力照合順のルールにしたがって大文字小文字の変換が行われます。（<xref linkend="collation"/>参照。)
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
-->
<literal>FX</literal>オプションが使用されていない限り、<function>to_timestamp</function>と<function>to_date</function>は入力文字列内最初の連続した空白と、日付と時間の値の周辺の複数の空白を無視します。
例えば、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>と<literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal>は動作しますが、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>はエラーを返します。
後者の<function>to_timestamp</function>は単一のスペースだけがあることを期待するからです。
<literal>FX</literal>はテンプレートの第1項目として指定される必要があります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
-->
<literal>FX</literal>オプションが使用されていない限り、<function>to_timestamp</function>と<function>to_date</function>のテンプレート文字列中の区切り文字（空白あるいは記号文字(訳注：原文は"non-letter/non-digit character"））は入力文字中のすべての単一の区切り文字とマッチするか、あるいはマッチしない場合はスキップします。
たとえば、<literal>to_timestamp('2000JUN', 'YYYY///MON')</literal>と<literal>to_timestamp('2000/JUN', 'YYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>は入力文字列中の区切り文字の数がテンプレート中の区切り文字の数を上回っているため、エラーを返します。
      </para>
      <para>
<!--
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
-->
<literal>FX</literal>が指定されていると、テンプレート文字列中の区切り文字は正確に入力文字列中の一文字とマッチします。
しかし、入力文字列の文字はテンプレート文字列中の区切り文字と一致する必要はないことに注意してください。
たとえば、<literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>はテンプレート文字列中の二番目の空白が入力文字列中の文字<literal>J</literal>を消費するため、エラーを返します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
-->
<literal>TZH</literal>テンプレートパターンは符号付きの数字とマッチします。
<literal>FX</literal>オプションが無い場合、マイナス符号は曖昧で、区切り文字として解釈されるかも知れません。
この曖昧さは次のようにして解消されます。
テンプレート文字列中の<literal>TZH</literal>の前の区切り文字の数が入力文字列中のマイナス符号の前の区切り文字の数よりも少なければ、そのマイナス符号は<literal>TZH</literal>の一部として解釈されます。
そうでない場合、マイナス記号が値の区切り記号と見なされます。
たとえば、<literal>to_timestamp('2000 -10', 'YYYY TZH')</literal>では<literal>-10</literal>が<literal>TZH</literal>にマッチしますが、<literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>では<literal>10</literal>が<literal>TZH</literal>にマッチします。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
-->
<function>to_char</function>テンプレートには、通常のテキストを入れることができ、それはそのまま出力されます。
部分文字列を二重引用符で括ることで、部分文字列にテンプレートパターンがあったとしても、強制的にリテラルテキストとして解釈させることができます。
例えば、<literal>'"Hello Year "YYYY'</literal>では<literal>YYYY</literal>は年データに置換されてしまいますが、<literal>Year</literal>内の<literal>Y</literal>は置換されません。
<function>to_date</function>、<function>to_number</function>、<function>to_timestamp</function>では、二重引用符で括られた文字の数だけ入力された文字をスキップします。例えば<literal>"XX"</literal>は2文字の入力文字（それが<literal>XX</literal>であるかどうかにかかわらず)をスキップします。
      </para>
      <tip>
        <para>
<!--
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
-->
<productname>PostgreSQL</productname> 12より前では、記号文字（訳注：原文は"non-letter or non-digit"）を使って入力文字列中の任意のテキストをスキップすることが可能でした。
たとえば、<literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal>は動作しました。
現在は、この目的のために非記号文字（訳注：原文は"letter characters"）だけを使うことができます。
たとえば、<literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal>と<literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>は、<literal>y</literal>、<literal>m</literal>、<literal>d</literal>をスキップします。
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
<!--
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045;&#045; 原文コメント "" font-lock sanity :-) &#045;&#045;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
-->
出力に二重引用符を付けたい場合、<literal>'\"YYYY Month\"'</literal>のようにその前にバックスラッシュを付けなければなりません。
バックスラッシュは、二重引用符の外側では特別扱いされません。
二重引用符の内側では、バックスラッシュによって次の文字が何であれ文字通りに扱われるようになります。
（しかし、次の文字が二重引用符であるか、あるいは別のバックスラッシュでない限り、これは特別な効果をもたらしません。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.,
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.,
       <literal>95</literal> becomes 1995.
-->
<function>to_timestamp</function>において<function>to_date</function>、<literal>YYY</literal>の様に4桁未満の年書式が指定され、かつ与えられる年が4桁未満だった場合、年は2020年に最も近くなるよう調整されます。例えば、<literal>95</literal>の場合は1995年になります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       negative years are treated as signifying BC.  If you write both a
       negative year and an explicit <literal>BC</literal> field, you get AD
       again.  An input of year zero is treated as 1 BC.
-->
<function>to_timestamp</function>および<function>to_date</function>において負の年はBCを表します。
負の年と明示的な<literal>BC</literal>フィールドの両方を記述すると、再びADになります。
すべての形のゼロ年はBC 1として扱われます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYYY</literal>変換は、5桁以上の年数値を処理するときに制限事項があります。
このような場合、<literal>YYYY</literal>の後に数字以外の文字またはテンプレートを使わなければなりません。 そうしないと年は常に4桁と解釈されます。
例えば（20000年として）、<literal>to_date('200001131', 'YYYYMMDD')</literal>は4桁の年と解釈されるので、代わりに<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>または<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>のように数字でない区切り文字を使用してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYY</literal>、<literal>YYYY</literal>、もしくは<literal>Y,YYY</literal>フィールドが存在すると<literal>CC</literal>（世紀）フィールドは受け入れられますが、無視されます。
<literal>CC</literal>が<literal>YY</literal>もしくは<literal>Y</literal>と共に使用されると、結果は指定された世紀のその年として計算されます。
世紀が指定され、年が指定されないときは、その世紀の最初の年と想定されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
-->
<function>to_timestamp</function>および<function>to_date</function>において、曜日の名前や数字（<literal>DAY</literal>、<literal>D</literal>および関連したフィールドの型）は受け付けられますが、結果を計算するという目的においては無視されます。
同じことは四半期（<literal>Q</literal>）フィールドにも当てはまります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
-->
<function>to_timestamp</function>および<function>to_date</function>において、
ISO 8601週番号日は（グレゴリオ暦の日付とは異なって）以下の２つの方法のうちのひとつで指定できます。
       <itemizedlist>
        <listitem>
         <para>
<!--
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
-->
年、通年の週番号、曜日番号。
例えば、<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>は、日付<literal>2006-10-19</literal>を返します。
曜日番号を省略した場合、1（月曜日）と想定されます。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
-->
年と通年の日付番号。例えば、<literal>to_date('2006-291', 'IYYY-IDDD')</literal>も<literal>2006-10-19</literal>を返します。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
<!--
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
-->
ISO 8601週番号とグレゴリオ暦日のフィールドを混在して使用して日付を構築する試みは無意味なことで、エラーの原因になります。
ISO 8601週番号年の文脈では、<quote>月</quote>、あるいは<quote>月内の日付番号</quote>は意味を持ちません。
グレゴリオ暦の年の文脈では、ISO週番号は意味を持ちません。
      </para>
      <caution>
       <para>
<!--
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
-->
<function>to_date</function>はグレゴリオとISO週番号日のフィールドの混在を拒否しますが、<function>to_char</function>はそうではありません。<literal>YYYY-MM-DD (IYYY-IDDD)</literal>のような出力書式指定が有用な場合があるからです。
しかし、<literal>IYYY-MM-DD</literal>のような書き方は避けてください。年の初めの近くで驚くべき結果になるでしょう。
(より詳細な情報は<xref linkend="functions-datetime-extract"/>を参照してください。)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
-->
<function>to_timestamp</function>において、ミリ秒（<literal>MS</literal>）およびマイクロ秒（<literal>US</literal>）フィールドは小数点の後の秒の桁として使用されます。
例えば、<literal>to_timestamp('12.3', 'SS.MS')</literal>は3ミリ秒ではなく300ミリ秒です。なぜなら変換においてこれは12 + 0.3秒と計算されるからです。
従って<literal>SS.MS</literal>書式に対して入力値<literal>12.3</literal>、<literal>12.30</literal>、<literal>12.300</literal>は同じミリ秒数を指定することになります。
3ミリ秒が必要な場合には<literal>12:003</literal>のようにしなければなりません。この時、変換において12 + 0.003 = 12.003秒と計算します。
      </para>

      <para>
<!--
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
-->
もう少し複雑な例を挙げます。
<literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>は15時間12分と2秒+20ミリ秒+1230マイクロ秒 = 2.021230秒です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
-->
<function>to_char(..., 'ID')</function>の曜日番号付けは<function>extract(isodow from ...)</function>関数に一致しますが、<function>to_char(..., 'D')</function>の曜日番号付けは<function>extract(dow from ...)</function>の曜日番号付けに一致しません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
-->
<function>to_char(interval)</function>関数は、<literal>HH</literal>と<literal>HH12</literal>を12時間の時計に表示されるように整形します。
例えば0時間と36時間はいずれも<literal>12</literal>として出力します。
一方<literal>HH24</literal>は時間の値をそのまま出力し、<type>interval</type>の値であれば23を超えることも可能です。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
-->
<xref linkend="functions-formatting-numeric-table"/>に、数値の書式設定に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-numeric-table">
<!--
     <title>Template Patterns for Numeric Formatting</title>
-->
     <title>数値書式用のテンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
<!--
        <entry>digit position (can be dropped if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときは表示しない）</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
<!--
        <entry>digit position (will not be dropped, even if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときでも表示する）</entry>
       </row>
       <row>
<!--
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
-->
        <entry><literal>.</literal>（ピリオド）</entry>
        <entry>小数点</entry>
       </row>
       <row>
<!--
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
-->
        <entry><literal>,</literal> (コンマ)</entry>
        <entry>千単位で区切る符号</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
<!--
        <entry>negative value in angle brackets</entry>
-->
        <entry>負の値の角括弧表示</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
<!--
        <entry>sign anchored to number (uses locale)</entry>
-->
        <entry>符号付き値（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
<!--
        <entry>currency symbol (uses locale)</entry>
-->
        <entry>通貨記号（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>decimal point (uses locale)</entry>
-->
        <entry>小数点（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
<!--
        <entry>group separator (uses locale)</entry>
-->
        <entry>グループ区切り文字（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minus sign in specified position (if number &lt; 0)</entry>
-->
        <entry>（数値 &lt; 0であれば）指定位置にマイナス記号</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
<!--
        <entry>plus sign in specified position (if number &gt; 0)</entry>
-->
        <entry>（数値 &gt; 0であれば）指定位置にプラス記号</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
<!--
        <entry>plus/minus sign in specified position</entry>
-->
        <entry>指定された位置にプラス/マイナス記号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
<!--
        <entry>Roman numeral (input between 1 and 3999)</entry>
-->
        <entry>ローマ数字（入力は1～3999）</entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
-->
        <entry><literal>TH</literal>または<literal>th</literal></entry>
        <entry>序数接尾辞</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
<!--
        <entry>shift specified number of digits (see notes)</entry>
-->
        <entry>指定桁でのシフト（注意事項を参照）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
<!--
        <entry>exponent for scientific notation</entry>
-->
        <entry>科学技術表記法用の指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for numeric formatting:
-->
数値型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
-->
<literal>0</literal>は、それが先頭あるいは末尾のゼロであっても必ず表示する数字の位置を指定します。
<literal>9</literal>も数字の位置を指定しますが、先頭のゼロであればそれは空白で置換され、また末尾のゼロで字詰めモードが指定されているときは削除されます。
（<function>to_number()</function>では、これら2つのパターン文字は同じ意味になります。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
-->
パターン文字<literal>S</literal>、<literal>L</literal>、<literal>D</literal>、<literal>G</literal>はそれぞれ現在のロケールで定義された符号、通貨記号、小数点、3桁区切り文字を表します（<xref linkend="guc-lc-monetary"/>および<xref linkend="guc-lc-numeric"/>を参照）。
パターン文字のピリオドとカンマはいずれもその文字そのものを表し、ロケールとは関係なく小数点と3桁区切り文字の意味を持ちます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
-->
<function>to_char()</function>のパターンで符号について明示的な条件付けがない場合、符号のために一桁が予約され、それは数に繋げられます（すぐ左側に置かれます）。
<literal>S</literal>がいくつかの<literal>9</literal>のすぐ左に置かれた場合、同様に数に繋げられます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
-->
<literal>SG</literal>、<literal>PL</literal>、または<literal>MI</literal>で整形された符号は、数値と関連付けられません。
例えば、<literal>to_char(-12, 'MI9999')</literal>は<literal>'-&nbsp;&nbsp;12'</literal>となる一方、<literal>to_char(-12, 'S9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となります。
（Oracleの実装では<literal>9</literal>の前に<literal>MI</literal>が置かれてはならず、<literal>9</literal>の後に<literal>MI</literal>が置かれることを要求しています。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
-->
<literal>TH</literal>はゼロ未満の値と小数は変換しません
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
-->
<literal>PL</literal>、<literal>SG</literal>、および<literal>TH</literal>は<productname>PostgreSQL</productname>の拡張です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
-->
<function>to_number</function>において、<literal>L</literal>あるいは<literal>TH</literal>のように非データテンプレートが使われた場合には、それがデータ文字（すなわち、数字、符号、10進小数点あるいはカンマ）でない限りテンプレートパターンにマッチするかどうかにかかわらず、該当する数分だけの入力文字がスキップされます。
例えば、<literal>TH</literal>は2つの非データ文字をスキップします。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
-->
<literal>V</literal>を<function>to_char</function>につけると、入力値を<literal>10^<replaceable>n</replaceable></literal>倍します。
ここで<replaceable>n</replaceable>は<literal>V</literal>に続く桁数です。
<literal>V</literal>を<function>to_number</function>につけると、同じように割り算をします。
<function>to_char</function>および<function>to_number</function>は、小数点と<literal>V</literal>との混在をサポートしません（例えば、<literal>99.9V99</literal> とはできません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
-->
<literal>EEEE</literal>(科学技術表記)は、桁と小数点のパターンを除き、他の書式パターンや修飾子と組み合わせて使うことはできず、また必ず書式文字列の最後に位置しなければなりません(例えば、<literal>9.99EEEE</literal>は正しい表記となります)。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
-->
すべてのテンプレートについて、その動作を変えるために、いくつかの修飾子を適用できます。
例えば、<literal>FM99.99</literal>は<literal>FM</literal>修飾子が付いた<literal>99.99</literal>パターンです。
<xref linkend="functions-formatting-numericmod-table"/>に、数値の書式用の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--
     <title>Template Pattern Modifiers for Numeric Formatting</title>
-->
     <title>数値の書式用テンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>添え字</entry>
<!--
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
-->
        <entry>字詰めモード（末尾の0と空白の埋め字を無効にする）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>添え字</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字による序数添え字</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>添え字</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>子文字による序数添え字</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
-->
<xref linkend="functions-formatting-examples-table"/>に、<function>to_char</function>関数を使用した例をいくつか示します。
  </para>

    <table id="functions-formatting-examples-table">
<!--
     <title><function>to_char</function> Examples</title>
-->
     <title><function>to_char</function>の例</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Result</entry>
-->
        <entry>式</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--
   <title>Date/Time Functions and Operators</title>
-->
   <title>日付/時刻関数と演算子</title>

  <para>
<!--
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
-->
<xref linkend="functions-datetime-table"/>は、日付/時刻型の値の処理で使用可能な関数を示しています。詳細は、以下の副節で説明します。
<xref linkend="operators-datetime-table"/>は、（<literal>+</literal>、<literal>*</literal>等の）基本的な算術演算子の振舞いを説明しています。
書式設定関数については<xref linkend="functions-formatting"/>を参照してください。
<xref linkend="datatype-datetime"/>を参照して、日付/時刻データ型についての背景となっている情報に精通していなければなりません。
  </para>

  <para>
<!--
   In addition, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for the
   date/time types.  Dates and timestamps (with or without time zone) are
   all comparable, while times (with or without time zone) and intervals
   can only be compared to other values of the same data type.  When
   comparing a timestamp without time zone to a timestamp with time zone,
   the former value is assumed to be given in the time zone specified by
   the <xref linkend="guc-timezone"/> configuration parameter, and is
   rotated to UTC for comparison to the latter value (which is already
   in UTC internally).  Similarly, a date value is assumed to represent
   midnight in the <varname>TimeZone</varname> zone when comparing it
   to a timestamp.
-->
加えて<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子が日付/時刻型で利用できます。
日付とタイムスタンプ（時間帯付きあるいは時間帯なし）はすべて互換性がありますが、時刻（時間帯付きあるいは時間帯なし）と時間間隔は同じデータ型の値同士だけが比較可能です。
時間帯なしのタイムスタンプと時間帯付きのタイムスタンプを比較する際には、前者の値は<xref linkend="guc-timezone"/>設定パラメータで指定された時間帯にあるものと仮定され、後者の値（すでに内部的にはUTCです）と比較するためにUTCに変換されます。
同様に、タイムスタンプと比較する際には、日付の値は<varname>TimeZone</varname>時間帯の午前零時であると見なされます。
  </para>

  <para>
<!--
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both <type>date</type> <literal>+</literal> <type>integer</type>
   and <type>integer</type> <literal>+</literal> <type>date</type>); we show
   only one of each such pair.
-->
以下の<type>time</type>もしくは<type>timestamp</type>型の入力を受け取る関数および演算子は全て、実際には2つの種類があります。1つは<type>time with time zone</type>型または<type>timestamp with time zone</type>型を取るもので、もう1つは<type>time without time zone</type>型もしくは<type>timestamp without time zone</type>型を取るものです。
簡略化のため、これらの種類の違いは個別に示していません。
また、<literal>+</literal>と<literal>*</literal>演算子は可換な2項をとります（例えば<type>date</type> <literal>+</literal> <type>integer</type>と<type>integer</type> <literal>+</literal> <type>date</type>）。こうした組み合わせは片方のみ示します。
  </para>

    <table id="operators-datetime-table">
<!--
     <title>Date/Time Operators</title>
-->
     <title>日付/時刻演算子</title>

     <tgroup cols="1">
      <thead>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
<!--
         Operator
-->
演算子
        </para>
        <para>
<!--
         Description
-->
説明
        </para>
        <para>
<!--
         Example(s)
-->
例
        </para></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
<!--
         Add a number of days to a date
-->
日付に日数を加算
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Add an interval to a date
-->
時刻間隔を日付に加算
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Add a time-of-day to a date
-->
日付に時刻を加算
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Add intervals
-->
時間間隔を加算
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Add an interval to a timestamp
-->
時間間隔をタイムスタンプに加算
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
<!--
         Add an interval to a time
-->
時間間隔を時分に加算
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Negate an interval
-->
時間間隔の符号を反転
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
<!--
         Subtract dates, producing the number of days elapsed
-->
日付を減算し、経過日数を返す
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
<!--
         Subtract a number of days from a date
-->
日付から日数を減算
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Subtract an interval from a date
-->
日付から時間間隔を減算
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Subtract times
-->
時分を減算
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
<!--
         Subtract an interval from a time
-->
時分から時刻間隔を減算
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Subtract an interval from a timestamp
-->
タイムスタンプから時刻間隔を減算
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Subtract intervals
-->
時間間隔を減算
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Subtract timestamps (converting 24-hour intervals into days,
         similarly to <function>justify_hours()</function>)
-->
タイムスタンプを減算（<function>justify_hours()</function>と同様に24時間間隔を日数に変換）
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Multiply an interval by a scalar
-->
時間間隔にスカラーを乗算
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Divide an interval by a scalar
-->
時間間隔をスカラーで除算
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--
     <title>Date/Time Functions</title>
-->
     <title>日付/時刻関数演算子</title>
     <tgroup cols="1">
      <thead>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
<!--
         Function
-->
関数
        </para>
        <para>
<!--
         Description
-->
説明
        </para>
        <para>
<!--
         Example(s)
-->
例
        </para></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Subtract arguments, producing a <quote>symbolic</quote> result that
         uses years and months, rather than just days
-->
引数間の減算。日数だけでなく年と月を使用した<quote>言葉による</quote>結果を生成
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Subtract argument from <function>current_date</function> (at midnight)
-->
<function>current_date</function>（午前零時時点）から引数を減算
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（文実行中に変化する）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
<!--
         Current date; see <xref linkend="functions-datetime-current"/>
-->
現在の日付。<xref linkend="functions-datetime-current"/>を参照
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
<!--
         Current time of day; see <xref linkend="functions-datetime-current"/>
-->
現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
<!--
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
-->
精度を限定した現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
-->
精度を限定した現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_bin</function> ( <type>interval</type>, <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Bin input into specified interval aligned with specified origin; see <xref linkend="functions-datetime-bin"/>
-->
指定した起源に合わせて指定の時間間隔に切り捨てます。<xref linkend="functions-datetime-bin"/>を参照してください。
        </para>
        <para>
         <literal>date_bin('15 minutes', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00')</literal>
         <returnvalue>2001-02-16 20:35:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
<!--
         Get timestamp subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
-->
タイムスタンプの部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
<!--
         Get interval subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
-->
時間間隔の部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
-->
指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照。
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Truncate to specified precision in the specified time zone; see
         <xref linkend="functions-datetime-trunc"/>
-->
指定された時間帯において指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Truncate to specified precision; see
         <xref linkend="functions-datetime-trunc"/>
-->
指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照。
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
<!--
         Get timestamp subfield; see <xref linkend="functions-datetime-extract"/>
-->
タイムスタンプの部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>numeric</returnvalue>
        </para>
        <para>
<!--
         Get interval subfield; see <xref linkend="functions-datetime-extract"/>
-->
時間間隔の部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
<!--
         Test for finite date (not +/-infinity)
-->
日付が有限（+/-無限でない）かどうかの検査
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
<!--
         Test for finite timestamp (not +/-infinity)
-->
タイムスタンプが有限（+/-無限でない）かどうかの検査
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
<!--
         Test for finite interval (currently always true)
-->
時間間隔が有限かどうかの検査（今の所常に真）
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Adjust interval so 30-day time periods are represented as months
-->
30日周期が1月を表すように時間間隔を調整
        </para>
        <para>
         <literal>justify_days(interval '35 days')</literal>
         <returnvalue>1 mon 5 days</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Adjust interval so 24-hour time periods are represented as days
-->
24時間を1日とする時間間隔の調整
        </para>
        <para>
         <literal>justify_hours(interval '27 hours')</literal>
         <returnvalue>1 day 03:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Adjust interval using <function>justify_days</function>
         and <function>justify_hours</function>, with additional sign
         adjustments
-->
<function>justify_days</function>および<function>justify_hours</function>を使用し、さらに符号による調整を行っての時間間隔の調整
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
<!--
         Current time of day;
         see <xref linkend="functions-datetime-current"/>
-->
現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
<!--
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
-->
精度を限定した現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current
         transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
-->
精度を限定した現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
<!--
         Create date from year, month and day fields
         (negative years signify BC)
-->
年、月、日フィールドから日付を作成（負の年はBCを意味します）
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
<!--
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields, each of which can default to zero
-->
年、月、週、日、時間、分、秒フィールドから時間間隔を作成
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
<!--
         Create time from hour, minute and seconds fields
-->
時、分、秒フィールドから時刻を作成
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
<!--
         Create timestamp from year, month, day, hour, minute and seconds fields
         (negative years signify BC)
-->
年、月、日、時、分、秒フィールドから時刻を作成（負の年はBCを意味します）
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields (negative years signify BC).
         If <parameter>timezone</parameter> is not
         specified, the current time zone is used; the examples assume the
         session time zone is <literal>Europe/London</literal>
-->
年、月、日、時、分、秒フィールドから時間帯付きの時刻を作成（負の年はBCを意味する）。
<parameter>timezone</parameter>が指定されていなければ、現在の時間帯が使われる。
例ではセッションの時間帯が<literal>Europe/London</literal>であると仮定。
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5, 'America/New_York')</literal>
         <returnvalue>2013-07-15 13:15:23.5+01</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（現在の文の開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
<!--
         Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（<function>clock_timestamp</function>と似ているが、<type>text</type>型文字列として返す）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp with time zone
-->
Unixエポック時間（1970-01-01 00:00:00+00からの経過秒数）をtimestamp with time zoneに変換
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
<!--
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
-->
これらの関数に加え、<literal>OVERLAPS</literal> SQL演算子がサポートされています。
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
<!--
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
-->
この式は、2つの時間間隔（その両端で定義されます）が重なる時に真を返します。重ならない場合は偽を返します。
両端は2つの日付、時刻、タイムスタンプとして、もしくは、日付/時刻/タイムスタンプとそれに続く時間間隔として指定できます。
値の組み合わせで指定する場合、開始と終了のいずれを先に記述しても構いません。<literal>OVERLAPS</literal>は与えられた値のうち、早い方を開始として扱います。
各時間間隔は、<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>という半開区間として見なされます。ただし、<replaceable>start</replaceable>と<replaceable>end</replaceable>が同じ値の場合には単一の時間点となります。
これは、例えば端点のみが共通である2つの時間間隔は、重ならないということを意味します。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
<!--
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days,
   keeping the time of day the same.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set
   to <literal>America/Denver</literal>:
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>
   This happens because an hour was skipped due to a change in daylight saving
   time at <literal>2005-04-03 02:00:00</literal> in time zone
   <literal>America/Denver</literal>.
-->
<type>timestamp with time zone</type>の値に<type>interval</type>の値を加える時（または<type>interval</type>の値を引く時）、日にちの部分は、<type>timestamp with time zone</type>の日付を指定された日数だけ先に進める、もしくは後に戻し、時刻は同じに保ちます。
（セッションの時間帯がDSTを認識する設定の場合）夏時間の移行に跨っての変化に関しては、<literal>interval '1 day'</literal>が<literal>interval '24 hours'</literal>に等しいとは限りません。
例えば、セッションの時間帯が <literal>America/Denver</literal>に設定されている時には以下のようになります。
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>結果: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>結果: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>
その理由は<literal>America/Denver</literal>時間帯で<literal>2005-04-03 02:00:00</literal>に夏時間への変更があるからです。
  </para>

  <para>
<!--
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
-->
異なる月では日数が異なりますので<function>age</function>で返される<literal>months</literal>フィールドにはあいまいさがあります。
<productname>PostgreSQL</productname>のやり方は月をまたがる２つの日付の計算において、日付の早いほうの月を使用します。
例えば、<literal>age('2004-06-01', '2004-04-30')</literal>は4月を使用して<literal>1 mon 1 day</literal>を得ます。5月は31日あり、4月は30日のため、もし5月を使用するなら結果は<literal>1 mon 2 days</literal>となるでしょう。
  </para>

  <para>
<!--
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
-->
日付とタイムスタンプの引き算は複雑になることがあります。
引き算をする概念的に単純な方法は、それぞれの値を秒数に<literal>EXTRACT(EPOCH FROM ...)</literal>で変換してから、結果を引き算する方法です。この結果は2つの値の間の<emphasis>秒</emphasis>数になります。
これは各月の日数、時間帯の変更、夏時間の調整に対して調整されるでしょう。
<quote><literal>-</literal></quote>演算子での日付やタイムスタンプの引き算は値の間の(24時間の)日数と時間/分/秒を、同様に調整して返します。
<function>age</function>関数は年、月、日、時間/分/秒をフィールド毎に引き算し、負のフィールドの値を調整します。
以下の問い合わせは上の各方法の違いを説明する例です。
例の結果は<literal>timezone = 'US/Eastern'</literal>で生成されました。2つの日付の間には夏時間の変更があります。
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<!--
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<!--
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
<!--
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>numeric</type>.
    The following are valid field names:
-->
<function>extract</function>関数は、日付/時刻の値から年や時などの部分フィールドを抽出します。
<replaceable>source</replaceable>は<type>timestamp</type>型、<type>time</type>型、または<type>interval</type>型の評価式でなければなりません（<type>date</type>型の式は<type>timestamp</type>型にキャストされますので、同様に使用可能です）。
<replaceable>field</replaceable>はsourceの値からどのフィールドを抽出するかを選択する識別子もしくは文字列です。
<function>extract</function>関数は<type>numeric</type>型の値を返します。
以下に有効なフィールド名を示します。

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
<!--
        The century
-->
世紀
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
<!--
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
-->
当時の人々にはそのような意識はありませんでしたが、最初の世紀は0001-01-01 00:00:00 ADから始まります。
この定義は全てのグレゴリオ暦を使用する国で適用されています。
0という値の世紀はありません。-1世紀の次は1世紀です。

この定義に納得できなければ、苦情をバチカンローマ聖ペテロ大聖堂のローマ法王に伝えてください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the day (of the month) field
        (1&ndash;31) ; for <type>interval</type> values, the number of days
-->
<type>timestamp</type>値については、(月内の)日付フィールド(1&ndash;31)。<type>interval</type>値については日数。
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
<!--
        The year field divided by 10
-->
年フィールドを10で割ったもの
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
-->
日曜日（<literal>0</literal>）から土曜日（<literal>6</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
<!--
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
-->
<function>extract</function>関数の曜日番号は<function>to_char(...,'D')</function>関数のそれとは異なる点に注意してください。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
<!--
        The day of the year (1&ndash;365/366)
-->
年内での通算日数（1&ndash;365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (negative for
        timestamps before that);
        for <type>date</type> and <type>timestamp</type> values, the
        nominal number of seconds since 1970-01-01 00:00:00,
        without regard to timezone or daylight-savings rules;
        for <type>interval</type> values, the total number
        of seconds in the interval
-->
<type>timestamp with time zone</type>型の値においては、1970-01-01 00:00:00 UTCからの秒数（負の数はその前）。<type>date</type>と<type>timestamp</type>型の値においては、時間帯と夏時間を考慮しないローカルタイムの1970-01-01 00:00:00からの秒数。<type>interval</type>型の値ではその時間間隔における合計の秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM TIMESTAMP '2001-02-16 20:38:40.12');
<lineannotation>Result: </lineannotation><computeroutput>982355920.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
<!--
        You can convert an epoch value back to a <type>timestamp with time zone</type>
        with <function>to_timestamp</function>:
-->
<function>to_timestamp</function>で経過秒数を<type>timestamp with time zone</type>に変換することができます。
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>

       <para>
<!--
        Beware that applying <function>to_timestamp</function> to an epoch
        extracted from a <type>date</type> or <type>timestamp</type> value
        could produce a misleading result: the result will effectively
        assume that the original value had been given in UTC, which might
        not be the case.
-->
<function>to_timestamp</function>を<type>date</type>あるいは<type>timestamp</type>の値から取り出したエポックに適用すると、誤解を招く結果が得られるかもしれないことに注意してください。結果は実質的に元の値がUTCで与えられていると見なしますが、実際は違うかもしれません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
<!--
        The hour field (0&ndash;23)
-->
時フィールド（0&ndash;23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
-->
月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
<!--
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
-->
日曜日を除き<literal>dow</literal>と同一です。
これは<acronym>ISO</acronym> 8601曜日番号付けに一致します。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
<!--
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
-->
日付に当てはまる<acronym>ISO</acronym> 8601週番号年（intervalには適用できない）。
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
<!--
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
-->
すべての<acronym>ISO</acronym> 8601週番号年は1月4日を含む週の月曜日から開始されます。従って、1月上旬、または12月下旬で<acronym>ISO</acronym>年がグレゴリオ年と異なる可能性があります。
より詳細は<literal>week</literal>フィールドを参照してください。
       </para>
       <para>
<!--
        This field is not available in PostgreSQL releases prior to 8.3.
-->
このフィールドは8.3より前のPostgreSQLリリースでは有効でありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>julian</literal></term>
      <listitem>
       <para>
<!--
        The <firstterm>Julian Date</firstterm> corresponding to the
        date or timestamp (not applicable to intervals).  Timestamps
        that are not local midnight result in a fractional value.  See
        <xref linkend="datetime-julian-dates"/> for more information.
-->
日付あるいタイムスタンプに関連する<firstterm>ユリウス日(Julian Date)</firstterm>（時間間隔には適用されない）。
ローカル午前零時ではないタイムスタンプは小数となります。
詳細は<xref linkend="datetime-julian-dates"/>をご覧ください。
       </para>

<screen>
SELECT EXTRACT(JULIAN FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2453737</computeroutput>
SELECT EXTRACT(JULIAN FROM TIMESTAMP '2006-01-01 12:00');
<lineannotation>Result: </lineannotation><computeroutput>2453737.50000000000000000000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
-->
端数部分も含む秒フィールドに、1,000,000を乗じた値。秒の整数部を含むことに注意。
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
<!--
        The millennium
-->
ミレニアム（千年期）
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
<!--
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
-->
1900年代の年は第2ミレニアムです。第3ミレニアムは2001年1月1日から始まりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
-->
端数部分も含む秒フィールドに、1000を乗た値。秒の整数部を含むことに注意してください。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
<!--
        The minutes field (0&ndash;59)
-->
分フィールド (0&ndash;59)
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the number of the month
        within the year (1&ndash;12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0&ndash;11)
-->
<type>timestamp</type>型の値に対しては年内の月番号（1&ndash;12）。<type>interval</type>型の値に対しては月数を12で割った余り（0&ndash;11）。
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
<!--
        The quarter of the year (1&ndash;4) that the date is in
-->
その日付が含まれる年の四半期(1&ndash;4)
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including any fractional seconds
-->
端数を含んだ秒フィールド
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
<!--
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
-->
秒単位のUTCからの時間帯オフセット。正の値はUTCより東の時間帯に対応し、負の値はUTCより西の時間帯に対応。
(技術的に言えば、<productname>PostgreSQL</productname>はうるう秒を制御しないためUTCを使用していない。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
<!--
        The hour component of the time zone offset
-->
時間帯オフセットの時の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
<!--
        The minute component of the time zone offset
-->
時間帯オフセットの分の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
<!--
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
-->
<acronym>ISO</acronym> 8601週番号。
定義ではISO週は月曜日から始まり、その年の1月4日を含む週をその年の第1週としています。
つまり、年の最初の木曜日がある週がその年の第1週となります。
       </para>
       <para>
<!--
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
-->
ISO週番号システムでは、1月の早い日にちは前年の第52週もしくは第53週となることがあり、12月の遅い日にちには次年の最初の週の一部となることがあります。
例えば、<literal>2005-01-01</literal>は2004年の第53週であり、<literal>2006-01-01</literal>は2005年の第52週の一部です、一方<literal>2012-12-31</literal>は2013年の第1週の一部となります。
整合性のある結果を得るため、<literal>isoyear</literal>フィールドと<literal>week</literal>を併用することを推奨します。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
<!--
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
-->
年フィールド。<literal>AD零年</literal>が存在しないことは忘れないでください。このため<literal>AD</literal>の年から<literal>BC</literal>の年を減ずる時には注意が必要です。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <note>
    <para>
<!--
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
-->
入力値が+/-無限大の場合、<function>extract</function>は単調増加するフィールド（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>）に対し、+/-無限大を返します。
その他のフィールドに対してはNULLが返されます。
<productname>PostgreSQL</productname>の9.6より前のバージョンでは、入力が無限大のすべての場合に対してゼロを返していました。
    </para>
   </note>

   <para>
<!--
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
-->
<function>extract</function>関数は主に演算処理を意図しています。
日付/時刻の値を表示する目的での書式については<xref linkend="functions-formatting"/>を参照してください。
   </para>

   <para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>関数は伝統的な<productname>Ingres</productname>上で設計されたもので、標準<acronym>SQL</acronym>の<function>extract</function>関数と等価です。
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
    For historical reasons, the <function>date_part</function> function
    returns values of type <type>double precision</type>.  This can result in
    a loss of precision in certain uses.  Using <function>extract</function>
    is recommended instead.
-->
ここで<replaceable>field</replaceable>パラメータが名前ではなく文字列値である必要があることに注意してください。
<function>date_part</function>で有効なフィールド名は<function>extract</function>と同じです。
歴史的な理由により、<function>date_part</function>関数は<type>double precision</type>型の結果を返します。
場合によってはこれによって精度が失われることがあります。
<function>extract</function>を代わりに使うことをお勧めします。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
-->
<function>date_trunc</function>関数は概念的に数値に対する<function>trunc</function>関数と類似しています。
   </para>

   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>は、データ型<type>timestamp</type>、<type>timestamp with time zone</type>もしくは<type>interval</type>の評価式です。
（<type>date</type>型と<type>time</type>型の値はそれぞれ自動的に<type>timestamp</type>もしくは<type>interval</type>にキャストされます。）
<replaceable>field</replaceable>は、入力値の値をどの精度で切り捨てるかを選択します。
同様に戻り値は<type>timestamp</type>、<type>timestamp with time zone</type>もしくは<type>interval</type>型で、指定した精度より下のすべてのフィールドがゼロに設定（日と月については1に設定）されます。
   </para>

   <para>
<!--
    Valid values for <replaceable>field</replaceable> are:
-->
<replaceable>field</replaceable>の有効値には次のものがあります。
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
<!--
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
-->
入力値が<type>timestamp with time zone</type>型の値なら、特定の時間帯を考慮して切り捨てが行われます。たとえば、<literal>日</literal>を切り捨てると値はその時間帯での真夜中になります。
デフォルトでは切り捨ては現在の<xref linkend="guc-timezone"/>の設定に従いますが、別の時間帯を指定することができるようにオプションの<replaceable>time_zone</replaceable>引数が提供されています。
時間帯名は<xref linkend="datatype-timezones"/>に記述されている方法で指定できます。
   </para>

   <para>
<!--
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
-->
<type>timestamp without time zone</type>あるいは<type>interval</type>の入力を処理している間は時間帯は指定できません。
これらは額面通りの値で扱われます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
-->
例（現地タイムゾーンは<literal>America/New_York</literal>と仮定します）：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-bin">
   <title><function>date_bin</function></title>

   <indexterm>
    <primary>date_bin</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_bin</function> <quote>bins</quote> the input
    timestamp into the specified interval (the <firstterm>stride</firstterm>)
    aligned with a specified origin.
-->
関数<function>date_bin</function>は、指定した原点に揃えて入力のタイムスタンプを指定した時間間隔(<firstterm>stride</firstterm>)に<quote>分類</quote>します。
   </para>

   <para>
<synopsis>
date_bin(<replaceable>stride</replaceable>, <replaceable>source</replaceable>, <replaceable>origin</replaceable>)
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type> or <type>timestamp with time zone</type>.  (Values
    of type <type>date</type> are cast automatically to
    <type>timestamp</type>.)  <replaceable>stride</replaceable> is a value
    expression of type <type>interval</type>.  The return value is likewise
    of type <type>timestamp</type> or <type>timestamp with time zone</type>,
    and it marks the beginning of the bin into which the
    <replaceable>source</replaceable> is placed.
-->
<replaceable>source</replaceable>は<type>timestamp</type>あるいは<type>timestamp with time zone</type>型の値式です。
（<type>date</type>型の値は<type>timestamp</type>に自動キャストされます。）
<replaceable>stride</replaceable>は<type>interval</type>型の値式です。
戻り値は同様に、<type>timestamp</type>あるいは<type>timestamp with time zone</type>型で、<replaceable>source</replaceable>が置かれた箱の開始位置に印を付けています。
   </para>

   <para>
<!--
    Examples:
-->
例を示します。
<screen>
SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2020-02-11 15:30:00</computeroutput>

SELECT date_bin('15 minutes', TIMESTAMP '2020-02-11 15:44:17', TIMESTAMP '2001-01-01 00:02:30');
<lineannotation>Result: </lineannotation><computeroutput>2020-02-11 15:32:30</computeroutput>
</screen>
   </para>

   <para>
<!--
    In the case of full units (1 minute, 1 hour, etc.), it gives the same result as
    the analogous <function>date_trunc</function> call, but the difference is
    that <function>date_bin</function> can truncate to an arbitrary interval.
-->
完全な単位(1分、1時間など)の場合は、これは類似の<function>date_trunc</function>の呼び出しと同じ結果を与えます。
違いは、<function>date_bin</function>は任意の間隔へと切り捨てられることです。
   </para>

   <para>
<!--
    The <parameter>stride</parameter> interval must be greater than zero and
    cannot contain units of month or larger.
-->
<parameter>stride</parameter>間隔はゼロより大きくなければならず、かつ月単位あるいはそれよりも大きくてはいけません。
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>
   <indexterm>
    <primary>時間帯</primary>
    <secondary>変換</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
<!--
    The <literal>AT TIME ZONE</literal> operator converts time
    stamp <emphasis>without</emphasis> time zone to/from
    time stamp <emphasis>with</emphasis> time zone, and
    <type>time with time zone</type> values to different time
    zones. <xref linkend="functions-datetime-zoneconvert-table"/> shows its
    variants.
-->
<literal>AT TIME ZONE</literal>構文を使用することにより、time stamp <emphasis>without</emphasis> time zoneからtime stamp <emphasis>with</emphasis> time zoneへ、あるいは<type>time with time zone</type>の値を異なる時間帯に変換することができます。
<xref linkend="functions-datetime-zoneconvert-table"/>にその種類を示します。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--
     <title><literal>AT TIME ZONE</literal> Variants</title>
-->
     <title><literal>AT TIME ZONE</literal>の種類</title>
     <tgroup cols="1">
      <thead>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
<!--
         Operator
-->
演算子
        </para>
        <para>
<!--
         Description
-->
説明
        </para>
        <para>
<!--
         Example(s)
-->
例
        </para></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
<!--
         Converts given time stamp <emphasis>without</emphasis> time zone to
         time stamp <emphasis>with</emphasis> time zone, assuming the given
         value is in the named time zone.
-->
与えられた<emphasis>時間帯なし</emphasis>タイムスタンプを指定された時間帯にあるとして<emphasis>時間帯あり</emphasis>タイムスタンプに変換します。
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
<!--
         Converts given time stamp <emphasis>with</emphasis> time zone to
         time stamp <emphasis>without</emphasis> time zone, as the time would
         appear in that zone.
-->
与えられた<emphasis>時間帯付き</emphasis>時刻を、時刻がその時間帯にあるものとして<emphasis>時間帯なし</emphasis>タイムスタンプに変換します。
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
<!--
         Converts given time <emphasis>with</emphasis> time zone to a new time
         zone.  Since no date is supplied, this uses the currently active UTC
         offset for the named destination zone.
-->
与えられた時刻<emphasis>with</emphasis> time zoneを新しい時間帯に変換します。
判断するためのデータがないので、現在の有効なUTCオフセットを目的の時間帯のために使用します。
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text value (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
    The interval case is only useful for zones that have fixed offsets from
    UTC, so it is not very common in practice.
-->
これらの式では、設定する時間帯<replaceable>zone</replaceable>は、（<literal>'America/Los_Angeles'</literal>のような）テキスト値、または（<literal>INTERVAL '-08:00'</literal>のような）時間間隔で指定することができます。
テキストの場合、<xref linkend="datatype-timezones"/>に示した方法で時間帯名称を指定することができます。
時間間隔を使うのはUTCからの固定のオフセットを持つ時間帯でのみ有用なので、一般的に非常に有用であるとは言えません。
   </para>

   <para>
<!--
    Examples (assuming the current <xref linkend="guc-timezone"/> setting
    is <literal>America/Los_Angeles</literal>):
-->
以下に例を示します（現在の時間帯（<xref linkend="guc-timezone"/>）を<literal>America/Los_Angeles</literal>と想定しています）。
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
<!--
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.
-->
最初の例は、時間帯のない値に時間帯を追加し、現在の<varname>TimeZone</varname>設定を使ってその値を表示します。
2番目の例は、time stamp with time zone値を指定した時間帯に変換し、その値をwithout a time zoneで返しています。
これは、<varname>TimeZone</varname>設定とは異なる値の格納と表示を可能にします。
3番目の例は、東京時間をシカゴ時間に変換します。
   </para>

   <para>
<!--
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
-->
関数<literal><function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)</literal>は、SQL準拠の構文<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>と等価です。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
<!--
   <title>Current Date/Time</title>
-->
   <title>現在の日付/時刻</title>

   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>
   <indexterm>
    <primary>日付</primary>
    <secondary>現在</secondary>
   </indexterm>

   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>
   <indexterm>
    <primary>時刻</primary>
    <secondary>現在</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>は、現在の日付時刻に関した値を返す多くの関数を提供します。
これらの標準SQL関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
-->
<function>CURRENT_TIME</function>および<function>CURRENT_TIMESTAMP</function>関数では、時間帯を伴う値を扱います。一方、<function>LOCALTIME</function>および<function>LOCALTIMESTAMP</function>関数では、時間帯を伴わない値を扱います。
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
-->
<function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>、および<function>LOCALTIMESTAMP</function>関数では、精度のパラメータをオプションで取ることができ、それに合わせて秒フィールドの端数桁を丸める結果をもたらします。
精度のパラメータがない場合、結果は使用可能な最大精度で出力されます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
<!--
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
-->
これらの関数は現在のトランザクションの開始時刻を返すため、その値はトランザクションが実行されている間は変化しません。
これは仕様であると考えられており、その意図は、単一のトランザクションが一貫性のある<quote>現在</quote>時刻の概念を持ち、同一トランザクション内の複数の変更が同一のタイムスタンプを持つようにすることにあります。
   </para>

   <note>
    <para>
<!--
     Other database systems might advance these values more
     frequently.
-->
他のデータベースシステムでは、これらの値をより頻繁に増加させることがあります。
    </para>
   </note>

   <para>
<!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>はまた、関数を呼び出した時の実際の現在時刻や現在の文の開始時刻を返す関数も提供します。
非標準SQLの時間関数の全一覧を以下に示します。
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
<!--
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
-->
<function>transaction_timestamp()</function>は<function>CURRENT_TIMESTAMP</function>と等価ですが、明確に何を返すかを反映する名前になっています。
<function>statement_timestamp()</function>は現在の文の実行開始時刻を返すものです（より具体的にいうと、直前のコマンドメッセージをクライアントから受け取った時刻です）。
<function>statement_timestamp()</function>および<function>transaction_timestamp()</function>はトランザクションの最初のコマンドでは同じ値を返しますが、その後に引き続くコマンドでは異なる可能性があります。
<function>clock_timestamp()</function>は実際の現在時刻を返しますので、その値は単一のSQLコマンドであっても異なります。
<function>timeofday()</function>は<productname>PostgreSQL</productname>の歴史的な関数です。
<function>clock_timestamp()</function>同様、実際の現在時刻を返しますが、<type>timestamp with time zone</type>型の値ではなく、整形された<type>text</type>文字列を返します。<function>now()</function>は<function>transaction_timestamp()</function>と同じもので、伝統的な<productname>PostgreSQL</productname>関数です。
   </para>

   <para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
すべての日付/時刻型はまた、特殊なリテラル値 <literal>now</literal>を受け付け、これは現在の日付と時刻（ここでも、トランザクションの開始時刻として解釈されます）を表します。
したがって、下記の３つの実行結果は全て同じものとなります。
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- but see tip below
</programlisting>
   </para>

    <tip>
     <para>
<!--
      Do not use the third form when specifying a value to be evaluated later,
      for example in a <literal>DEFAULT</literal> clause for a table column.
      The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
      (See also <xref linkend="datatype-datetime-special-values"/>.)
-->
たとえばテーブルの列に<literal>DEFAULT</literal>句を指定するのに、後から評価される値を指定する際に3番目の形式は使わないでください。
システムは<literal>now</literal>という定数を解析すると、すぐにそれを<type>timestamp</type>に変換するので、デフォルト値が必要が時には、テーブルが作成された時刻が使われます。
最初の2つの形式は関数呼び出しなので、デフォルト値が使用されるまで評価されません。
ですから、これらの関数は列の挿入時間をデフォルトとする、望ましい振舞いをします。
（<xref linkend="datatype-datetime-special-values"/>も見てください。）
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--
   <title>Delaying Execution</title>
-->
   <title>遅延実行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
   <indexterm>
    <primary>休止</primary>
   </indexterm>
   <indexterm>
    <primary>delay</primary>
   </indexterm>
   <indexterm>
    <primary>遅延</primary>
   </indexterm>

   <para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
以下の関数は、サーバプロセスの実行を遅延させるために使用可能です。
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

<!--
    <function>pg_sleep</function> makes the current session's process
    sleep until the given number of seconds have
    elapsed.  Fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function to
    allow the sleep time to be specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
-->
<function>pg_sleep</function>は、<replaceable>seconds</replaceable>秒経過するまで、現在のセッションのプロセスを休止させます。
<replaceable>seconds</replaceable>は<type>double precision</type>型の値です。そのため、小数単位で休止秒数を指定することができます。
<function>pg_sleep_for</function>は<type>interval</type>でより長い休止時間を指定する便利な関数です。
<function>pg_sleep_until</function>は特定の起床時刻が望まれる場合に便利な関数です。
以下に例を示します。

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
<!--
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
-->
休止時間の有効な分解能はプラットフォームに依存します。0.01秒が一般的な値です。
休止による遅延は最短で指定した時間と同じになります。
サーバの負荷などが要因となり、より長くなる可能性があります。
特に、<function>pg_sleep_until</function>は指定した時刻ちょうどに起床する保証はありませんが、それより早く起床することはありません。
     </para>
   </note>

   <warning>
     <para>
<!--
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
-->
<function>pg_sleep</function>またはその亜種を呼び出す時、セッションが必要以上のロックを保持していないことを確実にしてください。
さもないと、他のセッションが休止中のプロセスを待機しなければならないかもしれません。そのためシステム全体の速度が低下することになるかもしれません。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--
  <title>Enum Support Functions</title>
-->
  <title>列挙型サポート関数</title>

  <para>
<!--
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:
-->
列挙型（<xref linkend="datatype-enum"/>で解説）に対し、特に列挙型の値をハードコーディングせず簡潔なプログラミングを可能にするいくつかの関数があります。
それらの関数は<xref linkend="functions-enum-table"/>で一覧されています。
例は以下のようにして列挙型が作成されていることを想定しています。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--
    <title>Enum Support Functions</title>
-->
    <title>列挙型サポート関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
<!--
        Returns the first value of the input enum type.
-->
入力列挙型の最初の値を返します。
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
<!--
        Returns the last value of the input enum type.
-->
入力列挙型の最後の値を返します。
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Returns all values of the input enum type in an ordered array.
-->
入力列挙型の全ての値を順序付き配列として返します。
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
-->
与えられた２つの列挙型値の範囲を、順序配列として返します。
値は同一の列挙型に拠らなければなりません。
１番目のパラメータがNULLの場合、結果は列挙型の最初の値から始まります。
２番目のパラメータがNULLの場合、結果は列挙型の最後の値で終わります。
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as used in the examples.
-->
<function>enum_range</function>の２引数の形式を除き、これらの関数は、渡された特定の値を無視することに注意してください。関数は宣言されたデータ型のみ配慮します。
その型のNULLまたは特定の値を渡すことができ、同一の結果が得られます。
例で使われているような直書きした型名に対してではなく、テーブル列もしくは関数引数にこれらの関数を適用することがより一般的です。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--
  <title>Geometric Functions and Operators</title>
-->
  <title>幾何関数と演算子</title>

   <para>
<!--
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
-->
<type>point</type>、<type>box</type>、<type>lseg</type>、<type>line</type>、<type>path</type>、<type>polygon</type>、および<type>circle</type>幾何データ型には、PostgreSQLが元々サポートしている関数と演算子が豊富に揃っています（<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>、および<xref linkend="functions-geometry-conv-table"/>を参照してください）。
   </para>

   <table id="functions-geometry-op-table">
<!--
    <title>Geometric Operators</title>
-->
    <title>幾何データ演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Adds the coordinates of the second <type>point</type> to those of each
        point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
-->
最初の引数の各々の点に二番目の<type>point</type>の座標を加え、平行移動します。
<type>point</type>、<type>box</type>、<type>path</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
<!--
        Concatenates two open paths (returns NULL if either path is closed).
-->
2つの開経路を結合します。（どちらかの経路が閉じていればNULLを返します。）
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Subtracts the coordinates of the second <type>point</type> from those
        of each point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
-->
最初の引数の各々の点に二番目の<type>point</type>の座標を減算し、平行移動します。
<type>point</type>、<type>box</type>、<type>path</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Multiplies each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex multiplication).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin by the length
        of the vector, and rotating it counterclockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> a
        box with these operators only moves its corner points: the box is
        still considered to have sides parallel to the axes.  Hence the box's
        size is not preserved, as a true rotation would do.</para></footnote>
        <type>path</type>, <type>circle</type>.
-->
最初の引数の各々の点に2番目の<type>point</type>の座標を乗じます。（点を実数部と虚数部で表現する複素数として扱い、標準複素乗法を行います。）
2番目の<type>point</type>をベクトルと解釈すると、これはオブジェクトの大きさと原点からの距離をベクトルの長さで拡大し、<replaceable>x</replaceable>軸に対する角度分原点周りで反時計方向に回転させたものになります。
<type>point</type>、<type>box</type>
<footnote id="functions-geometry-rotation-fn"><para>boxをこれらの演算子で<quote>回転</quote>してもその頂点を動かすだけです。
原点に対して矩形の辺は平行のままです。ですから矩形の大きさは保存されません。真の回転ならば保存します。</para></footnote>
<type>path</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Divides each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex division).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin down by the
        length of the vector, and rotating it clockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnoteref
        linkend="functions-geometry-rotation-fn"/> <type>path</type>,
        <type>circle</type>.
-->
最初の引数の各々の点を2番目の<type>point</type>の座標で除算します。（点を実数部と虚数部で表現する複素数として扱い、標準複素除法を行います。
2番目の<type>point</type>をベクトルと解釈すると、これはオブジェクトの大きさと原点からの距離をベクトルの長さで縮小し、<replaceable>x</replaceable>軸に対する角度分原点周りで時計方向に回転させたものになります。
<type>point</type>、<type>box</type><footnoteref linkend="functions-geometry-rotation-fn"/>、<type>path</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
-->
全長を計算します。<type>lseg</type>、<type>path</type>で利用可能です。
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes the center point.
        Available for <type>box</type>, <type>lseg</type>,
        <type>polygon</type>, <type>circle</type>.
-->
中心点を計算します。
<type>box</type>、<type>lseg</type>、<type>path</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
-->
点の数を返します。
<type>path</type>、<type>polygon</type>で利用可能です。
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes the point of intersection, or NULL if there is none.
        Available for <type>lseg</type>, <type>line</type>.
-->
交点を計算します。交点がなければNULLを返します。
<type>lseg</type>、<type>line</type>で利用可能です。
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Computes the intersection of two boxes, or NULL if there is none.
-->
2つの矩形の共通部を計算します。
共通部がなければNULLを返します。
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes the closest point to the first object on the second object.
        Available for these pairs of types:
-->
最初のオブジェクトから2番目のオブジェクトへの2番目のオブジェクト上の最近点を計算します。
以下の型の対で利用可能です。
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the distance between the objects.
        Available for all geometric types except <type>polygon</type>,
        for all combinations
        of <type>point</type> with another geometric type, and for
        these additional pairs of types:
        (<type>box</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (and the commutator cases).
-->
オブジェクト間の距離を計算します。
7つのすべての幾何型、<type>point</type>と他のすべての幾何型との組み合わせ、そして次の型の組み合わせで利用できます。
(<type>box</type>、<type>lseg</type>)、(<type>box</type>、<type>line</type>)、(<type>lseg</type>、<type>line</type>)、(<type>polygon</type>、<type>circle</type>)(そして可換の組み合わせ)。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first object contain second?
        Available for these pairs of types:
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
-->
最初のオブジェクトは2番目のオブジェクトを含んでいるか？
次の型の組み合わせで利用できます。
        (<literal>box</literal>、<literal>point</literal>)、
        (<literal>box</literal>、<literal>box</literal>)、
        (<literal>path</literal>、<literal>point</literal>)、
        (<literal>polygon</literal>、<literal>point</literal>)、
        (<literal>polygon</literal>、<literal>polygon</literal>)、
        (<literal>circle</literal>、<literal>point</literal>)、
        (<literal>circle</literal>、<literal>circle</literal>)。
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object contained in or on second?
        Available for these pairs of types:
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
-->
最初のオブジェクトは2番目のオブジェクトに含まれているかあるいはその上にあるか？
次の型の組み合わせで利用できます。
        (<literal>point</literal>、 <literal>box</literal>)、
        (<literal>point</literal>、 <literal>lseg</literal>)、
        (<literal>point</literal>、 <literal>line</literal>)、
        (<literal>point</literal>、 <literal>path</literal>)、
        (<literal>point</literal>、 <literal>polygon</literal>)、
        (<literal>point</literal>、 <literal>circle</literal>)、
        (<literal>box</literal>、 <literal>box</literal>)、
        (<literal>lseg</literal>、 <literal>box</literal>)、
        (<literal>lseg</literal>、 <literal>line</literal>)、
        (<literal>polygon</literal>、 <literal>polygon</literal>)、
        (<literal>circle</literal>、 <literal>circle</literal>)。
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do these objects overlap?  (One point in common makes this true.)
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
これらのオブジェクトは重なり合っているか？
（共通の点があれば真となります。）
<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object strictly left of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
-->
最初のオブジェクトは完全に2番目のオブジェクトの左にあるか？
<type>point</type>、<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object strictly right of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
-->
最初のオブジェクトは完全に2番目のオブジェクトの右にあるか？
<type>point</type>、<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first object not extend to the right of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは2番目のオブジェクトの右にはみ出していないか？
<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first object not extend to the left of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは2番目のオブジェクトの左にはみ出していないか？
<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object strictly below second?
        Available for <type>point</type>, <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは完全に2番目のオブジェクトの下にあるか？
<type>point</type>、<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object strictly above second?
        Available for <type>point</type>, <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは完全に2番目のオブジェクトの上にあるか？
<type>point</type>、<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first object not extend above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは2番目のオブジェクトの上にはみ出していないか？
<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first object not extend below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
-->
最初のオブジェクトは2番目のオブジェクトの下にはみ出していないか？
<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object below second (allows edges to touch)?
-->
最初のオブジェクトは2番目のオブジェクトの下か？
（辺が接しているのを許容します）
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first object above second (allows edges to touch)?
-->
最初のオブジェクトは2番目のオブジェクトの上か？
（辺が接しているのを許容します）
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do these objects intersect?
        Available for these pairs of types:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
-->
これらのオブジェクトは交差しているか？
次の型の組み合わせで利用できます。
        (<type>box</type>、 <type>box</type>)、
        (<type>lseg</type>、 <type>box</type>)、
        (<type>lseg</type>、 <type>lseg</type>)、
        (<type>lseg</type>、 <type>line</type>)、
        (<type>line</type>、 <type>box</type>)、
        (<type>line</type>、 <type>line</type>)、
        (<type>path</type>、 <type>path</type>)。
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is line horizontal?
-->
線は水平か？
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are points horizontally aligned (that is, have same y coordinate)?
-->
点は水平に並んでいるか？
（つまりy座標が同じであるということです。）
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is line vertical?
-->
線は垂直か？
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are points vertically aligned (that is, have same x coordinate)?
-->
点は垂直に並んでいるか？
（つまりx座標が同じであるということです。）
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are lines perpendicular?
-->
（指定された）2つの線は垂直か？
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are lines parallel?
-->
線は平行か？
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are these objects the same?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
-->
オブジェクトは同じか？
<type>point</type>、<type>box</type>、<type>polygon</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <caution>
    <para>
<!--
     Note that the <quote>same as</quote> operator, <literal>~=</literal>,
     represents the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of the geometric types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares for equal <emphasis>areas</emphasis> only.
     The other scalar comparison operators (<literal>&lt;=</literal> and so
     on), where available for these types, likewise compare areas.
-->
<quote>同じを示す</quote><literal>~=</literal>演算子は<type>point</type>、<type>box</type>、<type>polygon</type>、および<type>circle</type>型に対し通常の等価概念を示すことに注意してください。これらのいくつかの型は<literal>=</literal>演算子を持ちますが、<literal>=</literal>は<emphasis>面積</emphasis>の等しさのみを比較します。これらの型で利用可能であれば、その他のスカラー比較演算子（<literal>&lt;=</literal>など）は同様に面積を比較します。
    </para>
   </caution>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 14, the point
     is strictly below/above comparison operators <type>point</type>
     <literal>&lt;&lt;|</literal> <type>point</type> and <type>point</type>
     <literal>|&gt;&gt;</literal> <type>point</type> were respectively
     called <literal>&lt;^</literal> and <literal>&gt;^</literal>.  These
     names are still available, but are deprecated and will eventually be
     removed.
-->
<productname>PostgreSQL</productname>の14より前では、点の下／上の厳密比較演算子<type>point</type> <literal>&lt;&lt;|</literal> <type>point</type>および<type>point</type> <literal>|&gt;&gt;</literal> <type>point</type>は、それぞれ<literal>&lt;^</literal>および<literal>&gt;^</literal>という名前でした。
これらの名前はまだ利用できますが、削除予定であり最終的にはなくなるでしょう。
    </para>
   </note>

   <table id="functions-geometry-func-table">
 <!--
    <title>Geometric Functions</title>
-->
    <title>幾何データ型関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes area.
        Available for <type>box</type>, <type>path</type>, <type>circle</type>.
        A <type>path</type> input must be closed, else NULL is returned.
        Also, if the <type>path</type> is self-intersecting, the result may be
        meaningless.
-->
面積を計算します。
<type>box</type>、<type>path</type>、<type>circle</type>で利用可能です。
入力<type>path</type>は閉じていなければなりません。さもなければNULLが返ります。
また<type>path</type>が自分自身と交わっていれば、結果は無意味なものになります。
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes center point.
        Available for <type>box</type>, <type>circle</type>.
-->
中心点を計算します。
<type>box</type>、<type>circle</type>で利用可能です。
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
<!--
        Extracts box's diagonal as a line segment
        (same as <function>lseg(box)</function>).
-->
矩形の対角線を線分として取り出します。
(<function>lseg(box)</function>と同じです。)
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes diameter of circle.
-->
円の直径を計算します。
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes vertical size of box.
-->
矩形の高さを計算します。
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is path closed?
-->
閉経路か？
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is path open?
-->
開経路か？
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
-->
全長を計算します。
<type>lseg</type>、<type>path</type>で利用可能です。
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
-->
点の数を返します
<type>path</type>、<type>polygon</type>で利用可能です。
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
<!--
        Converts path to closed form.
-->
経路を閉じた状態に変換します。
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
<!--
        Converts path to open form.
-->
経路を開いた状態に変換します。
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes radius of circle.
-->
円の半径を計算します。
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes slope of a line drawn through the two points.
-->
2つの点で描いた直線の傾きを計算します。
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes horizontal size of box.
-->
矩形の幅を計算します。
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--
    <title>Geometric Type Conversion Functions</title>
-->
    <title>幾何型変換関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>
     <tbody>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Computes box inscribed within the circle.
-->
円に内接する矩形を計算します。
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Converts point to empty box.
-->
点を空の矩形に変換します。
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Converts any two corner points to box.
-->
2つの対角する点を矩形に変換します。
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Computes bounding box of polygon.
-->
多角形の外接矩形を計算します。
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
<!--
        Computes bounding box of two boxes.
-->
2つの矩形の外接矩形を計算します。
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
<!--
        Computes smallest circle enclosing box.
-->
矩形を含む最小の円を計算します。
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
<!--
        Constructs circle from center and radius.
-->
中心と半径から円を作成します。
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
<!--
        Converts polygon to circle.  The circle's center is the mean of the
        positions of the polygon's points, and the radius is the average
        distance of the polygon's points from that center.
-->
多角形を円に変換します。
円の中心は多角形の点の位置の平均で、半径は中心から多角形の点の平均距離です。
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
<!--
        Converts two points to the line through them.
-->
2点を通過する直線に変換します。
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
<!--
        Extracts box's diagonal as a line segment.
-->
矩形の対角線を線分として取り出します。
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
<!--
        Constructs line segment from two endpoints.
-->
2つの点から線分を作ります。
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
<!--
        Converts polygon to a closed path with the same list of points.
-->
同じ点のリストで多角形を閉経路に変換します。
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Constructs point from its coordinates.
-->
座標から点を作ります。
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes center of box.
-->
矩形の中心点を計算します。
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes center of circle.
-->
円の中心点を計算します。
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes center of line segment.
-->
線分の中心を計算します。
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
<!--
        Computes center of polygon (the mean of the
        positions of the polygon's points).
-->
多角形の中心を計算します。
（多角形の点の位置の平均です。）
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
<!--
        Converts box to a 4-point polygon.
-->
矩形を4点の多角形に変換します。
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
<!--
        Converts circle to a 12-point polygon.
-->
円を12点の多角形に変換します。
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
<!--
        Converts circle to an <replaceable>n</replaceable>-point polygon.
-->
円を<replaceable>n</replaceable>点の多角形に変換します。
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
<!--
        Converts closed path to a polygon with the same list of points.
-->
同じ点のリストで閉経路を多角形に変換します。
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

    <para>
<!--
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
-->
あたかもpointは添字0、1を有する配列であるかのように、<type>point</type>の２つの構成要素にアクセスすることができます。
例えば、<literal>t.p</literal>が<type>point</type>列の場合、<literal>SELECT p[0] FROM t</literal>という式でX座標を抽出できます。また、<literal>UPDATE t SET p[1] = ...</literal>でY座標を変更できます。
同様に、<type>box</type>型または<type>lseg</type>型の値も、2つの<type>point</type>型の値の配列のように扱えます。
    </para>

  </sect1>


 <sect1 id="functions-net">
<!--
  <title>Network Address Functions and Operators</title>
-->
  <title>ネットワークアドレス関数と演算子</title>

  <para>
<!--
   The IP network address types, <type>cidr</type> and <type>inet</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized operators and functions shown in
   <xref linkend="cidr-inet-operators-table"/> and
   <xref linkend="cidr-inet-functions-table"/>.
-->
IPネットワークアドレス型である<type>cidr</type>と<type>inet</type>は<xref linkend="functions-comparison-op-table"/>に示す通常の比較演算子に加え、<xref linkend="cidr-inet-operators-table"/>と<xref linkend="cidr-inet-functions-table"/>で示す特定目的の演算子と関数をサポートしています。
  </para>

  <para>
<!--
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly;
   therefore, the operators and functions shown below as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is
   because the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value
   to <type>cidr</type>.  When this is done, any bits to the right of the
   netmask are silently zeroed to create a valid <type>cidr</type> value.
-->
すべての<type>cidr</type>値は暗黙的に<type>inet</type>にキャストできます。ですから以下で示す<type>inet</type>で使える演算子と関数は<type>cidr</type>でも使えます。
（<type>inet</type>と<type>cidr</type>用の別々の関数があるのは、この両者で振る舞いが異なっているべきである場合があるからです。）
また<type>inet</type>値を<type>cidr</type>にキャストすることが許されています。
これが行われると、ネットマスクの右側のすべてのビットは有効な<type>cidr</type>値を作るために暗黙的にゼロになります。
  </para>

   <table id="cidr-inet-operators-table">
<!--
    <title>IP Address Operators</title>
-->
    <title>IPアドレス演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is subnet strictly contained by subnet?
        This operator, and the next four, test for subnet inclusion.  They
        consider only the network parts of the two addresses (ignoring any
        bits to the right of the netmasks) and determine whether one network
        is identical to or a subnet of the other.
-->
サブネットが完全にサブネットに含まれているか？
この演算子と次の4つの演算子はサブネットの包含をテストします。
それらは2つのアドレスのネットワーク部分だけを考慮し（ネットマスクの右のビットは無視されます）、ネットワークが他のネットワークと同一か、あるいはサブネットであるかどうかを決定します。
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is subnet contained by or equal to subnet?
-->
サブネットがサブネットに含まれているか、あるいは同じか？
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does subnet strictly contain subnet?
-->
サブネットが完全にサブネットを含んでいるか？
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does subnet contain or equal subnet?
-->
サブネットがサブネットを含んでいるか、あるいは同じか？
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does either subnet contain or equal the other?
-->
サブネットが他を含んでいるか、あるいは同じか？
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes bitwise NOT.
-->
ビット否定を計算します。
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes bitwise AND.
-->
ビット積を計算します。
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes bitwise OR.
-->
ビット和を計算します。
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Adds an offset to an address.
-->
オフセットをアドレスに加算します。
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Adds an offset to an address.
-->
オフセットをアドレスに加算します。
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Subtracts an offset from an address.
-->
アドレスからオフセットを減算します。
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the difference of two addresses.
-->
2つのアドレスの差を計算します。
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="cidr-inet-functions-table">
<!--
    <title>IP Address Functions</title>
-->
    <title>IPアドレス関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Creates an abbreviated display format as text.
        (The result is the same as the <type>inet</type> output function
        produces; it is <quote>abbreviated</quote> only in comparison to the
        result of an explicit cast to <type>text</type>, which for historical
        reasons will never suppress the netmask part.)
-->
表示用テキスト省略形を作成します。
（結果は<type>inet</type>出力関数が生成するものと同じです。明示的に<type>text</type>にキャストしたもの（歴史的な理由でネットマスク部分が抑止されていません）と比べると<quote>省略</quote>されているだけです。
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Creates an abbreviated display format as text.
        (The abbreviation consists of dropping all-zero octets to the right
        of the netmask; more examples are in
        <xref linkend="datatype-net-cidr-table"/>.)
-->
表示用テキスト省略形を作成します。
（ネットマスクの右側のすべてのゼロオクテットを削除することによって省略形にします。<xref linkend="datatype-net-cidr-table"/>に他の例があります。）
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes the broadcast address for the address's network.
-->
アドレスのネットワーク部のネットワークブロードキャストアドレスを計算します。
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the address's family: <literal>4</literal> for IPv4,
        <literal>6</literal> for IPv6.
-->
アドレスファミリーを返します。IPv4なら<literal>4</literal>で、IPv6なら<literal>6</literal>です。
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the IP address as text, ignoring the netmask.
-->
IPアドレスをテキストとして返します。ネットマスクは無視されます。
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes the host mask for the address's network.
-->
アドレスのネットワークに対するホストマスクを計算します。
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
<!--
        Computes the smallest network that includes both of the given networks.
-->
与えられたネットワークを両方含む最小のネットワークを計算します。
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Tests whether the addresses belong to the same IP family.
-->
アドレスが同じIPファミリーに属しているかどうかを判定します。
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the netmask length in bits.
-->
ネットマスクのビット長を返します。
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Computes the network mask for the address's network.
-->
アドレスのネットワークに対するネットワークマスクを計算します。
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
<!--
        Returns the network part of the address, zeroing out
        whatever is to the right of the netmask.
        (This is equivalent to casting the value to <type>cidr</type>.)
-->
ネットマスクの右側をすべてゼロにしてアドレスのネットワーク部を返します。
（これは値を<type>cidr</type>にキャストするのと同じです。）
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
<!--
        Sets the netmask length for an <type>inet</type> value.
        The address part does not change.
-->
ネットマスク長を<type>inet</type>値に設定します。
アドレスの部分は変更しません。
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
<!--
        Sets the netmask length for a <type>cidr</type> value.
        Address bits to the right of the new netmask are set to zero.
-->
ネットマスク長を<type>cidr</type>値に設定します。
新しいネットマスクの右側のアドレスビットは0に設定されます。
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the unabbreviated IP address and netmask length as text.
        (This has the same result as an explicit cast to <type>text</type>.)
-->
省略形ではないIPアドレスとネットマスク長をテキストとして返します。
（これは<type>text</type>に明示的にキャストするのと同じ効果があります。）
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <tip>
   <para>
<!--
    The <function>abbrev</function>, <function>host</function>,
    and <function>text</function> functions are primarily intended to offer
    alternative display formats for IP addresses.
-->
関数<function>abbrev</function>、<function>host</function>、および<function>text</function>、は主として、代替のIPアドレスの整形表示を提供する目的のものです。
   </para>
  </tip>

  <para>
<!--
   The MAC address types, <type>macaddr</type> and <type>macaddr8</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized functions shown in
   <xref linkend="macaddr-functions-table"/>.
   In addition, they support the bitwise logical operators
   <literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>
   (NOT, AND and OR), just as shown above for IP addresses.
-->
MACアドレス型である<type>macaddr</type>と<type>macaddr8</type>は、<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子と<xref linkend="macaddr-functions-table"/>で示す特定目的のための関数をサポートします。
加えて上記のIPアドレス用に示したのと同様に、ビットごとの論理演算子<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>(NOT、AND、OR)をサポートします。
  </para>

   <table id="macaddr-functions-table">
<!--
    <title>MAC Address Functions</title>
-->
    <title>MACアドレス関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
<!--
        Sets the last 3 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
-->
アドレスの終わりの３バイトをゼロに設定します。
残りの前の部分は（<productname>PostgreSQL</productname>には含まれないデータを使って）特定の製造業者に関連付けることもできます。
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
<!--
        Sets the last 5 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
-->
アドレスの終わりの5バイトをゼロに設定します。
残りの前の部分は（<productname>PostgreSQL</productname>には含まれないデータを使って）特定の製造業者に関連付けることもできます。
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
<!--
        Sets the 7th bit of the address to one, creating what is known as
        modified EUI-64, for inclusion in an IPv6 address.
-->
7番目のビットを1にし、修正EUI-64と呼ばれる形式にして、IPv6アドレスに含められるようにします。
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


 <sect1 id="functions-textsearch">
<!--
  <title>Text Search Functions and Operators</title>
-->
  <title>テキスト検索関数と演算子</title>

   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
   <indexterm zone="datatype-textsearch">
    <primary>全文テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
   <indexterm zone="datatype-textsearch">
    <primary>テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

  <para>
<!--
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
-->
<xref linkend="textsearch-operators-table"/>、<xref linkend="textsearch-functions-table"/>および<xref linkend="textsearch-functions-debug-table"/>は全文検索用に提供されている関数と演算子を要約しています。<productname>PostgreSQL</productname>のテキスト検索機能の詳細は<xref linkend="textsearch"/>を参照してください。
  </para>

   <table id="textsearch-operators-table">
<!--
    <title>Text Search Operators</title>
-->
    <title>テキスト検索演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does <type>tsvector</type> match <type>tsquery</type>?
        (The arguments can be given in either order.)
-->
<type>tsvector</type>が<type>tsquery</type>の条件に合うか？
（引数は任意の順で与えることができます。）
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does text string, after implicit invocation
        of <function>to_tsvector()</function>, match <type>tsquery</type>?
-->
テキスト文字列は<function>to_tsvector()</function>の暗黙的な呼び出し後に<type>tsquery</type>の条件に合うか？
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        This is a deprecated synonym for <literal>@@</literal>.
-->
<literal>@@</literal>に対する廃止予定の同義語です。
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Concatenates two <type>tsvector</type>s.  If both inputs contain
        lexeme positions, the second input's positions are adjusted
        accordingly.
-->
2つの<type>tsvector</type>を連結します。
両方の入力が語彙素の位置を含んでいるなら2番目の入力の位置はそれにしたがって調整されます。
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        ANDs two <type>tsquery</type>s together, producing a query that
        matches documents that match both input queries.
-->
2つの<type>tsquery</type>の論理積を取り、両方の入力問い合わせにマッチする文書にマッチする問い合わせを生成します。
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        ORs two <type>tsquery</type>s together, producing a query that
        matches documents that match either input query.
-->
2つの<type>tsquery</type>の論理和を取り、どちらかの入力問い合わせにマッチする文書にマッチする問い合わせを生成します。
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Negates a <type>tsquery</type>, producing a query that matches
        documents that do not match the input query.
-->
<type>tsquery</type>の否定を取り、入力問い合わせにマッチしない文書にマッチする問い合わせを生成します。
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Constructs a phrase query, which matches if the two input queries
        match at successive lexemes.
-->
2つの入力問い合わせが連続する語彙素にマッチする場合にマッチする語句問い合わせを作成します。
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does first <type>tsquery</type> contain the second?  (This considers
        only whether all the lexemes appearing in one query appear in the
        other, ignoring the combining operators.)
-->
最初の<type>tsquery</type>は2番目を含んでいるか？
（これは結合演算子を無視して、単に一方の問い合わせ中のすべての語彙素が他方に現れるかどうかだけを考慮します。）
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is first <type>tsquery</type> contained in the second?  (This
        considers only whether all the lexemes appearing in one query appear
        in the other, ignoring the combining operators.)
-->
最初の<type>tsquery</type>は2番目に含まれているか？
（これは結合演算子を無視して、単に一方の問い合わせ中のすべての語彙素が他方に現れるかどうかだけを考慮します。）
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <para>
<!--
     In addition to these specialized operators, the usual comparison
     operators shown in <xref linkend="functions-comparison-op-table"/> are
     available for types <type>tsvector</type> and <type>tsquery</type>.
     These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
-->
表に示された演算子に加え、<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子型<type>tsvector</type>および<type>tsquery</type>に対して利用できます。
これらはテキスト検索に対してそれほど有用ではありませんが、例えばこれらの型の列に一意インデックスを作成することを可能にします。
    </para>

   <table id="textsearch-functions-table">
<!--
    <title>Text Search Functions</title>
-->
    <title>テキスト検索関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Converts an array of lexemes to a <type>tsvector</type>.
        The given strings are used as-is without further processing.
-->
語彙素の配列を<type>tsvector</type>に変換します。
与えられた文字列は特に処理は施されずにそのまま利用されます。
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
<!--
        Returns the OID of the current default text search configuration
        (as set by <xref linkend="guc-default-text-search-config"/>).
-->
（<xref linkend="guc-default-text-search-config"/>で設定された）現在のテキスト検索設定のOIDを返します。
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of lexemes in the <type>tsvector</type>.
-->
<type>tsvector</type>にある語彙素の数を返します。
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of lexemes plus operators in
        the <type>tsquery</type>.
-->
<type>tsquery</type>にある語彙素の数と演算子の数の和を返します。
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches documents containing all non-stopwords in the text.
-->
指定されたデフォルト設定にしたがって単語を正規化してテキストを<type>tsquery</type>に変換します。
文字列中の句読点はすべて無視されます。（句読点は問い合わせ演算子を決定しません。）
結果の問い合わせはテキスト中の非ストップワードをすべて含む文書にマッチします。
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches phrases containing all non-stopwords in the text.
-->
指定されたデフォルト設定にしたがって単語を正規化してテキストを<type>tsquery</type>に変換します。
文字列中の句読点はすべて無視されます。（句読点は問い合わせ演算子を決定しません。）
結果の問い合わせはテキスト中の非ストップワードをすべて含む句にマッチします。
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Converts text to a <type>tsquery</type>, normalizing words according
        to the specified or default configuration.  Quoted word sequences are
        converted to phrase tests.  The word <quote>or</quote> is understood
        as producing an OR operator, and a dash produces a NOT operator;
        other punctuation is ignored.
        This approximates the behavior of some common web search tools.
-->
指定されたデフォルト設定にしたがって単語を正規化してテキストを<type>tsquery</type>に変換します。
引用符で囲まれた一連の語は句の検査に変換されます。
<quote>or</quote>はOR演算子を生成するものとして扱われ、ダッシュはNOT演算子として扱われます。
それ以外の句読点は無視されます。
これにより通常のweb検索ツールに近い振る舞いをします。
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Produces a representation of the indexable portion of
        a <type>tsquery</type>.  A result that is empty or
        just <literal>T</literal> indicates a non-indexable query.
-->
<type>tsquery</type>のインデックス付可能な部分の表現を生成します。
空あるいは<literal>T</literal>はインデックス付できる部分が無い問い合わせであることを意味します。
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Assigns the specified <parameter>weight</parameter> to each element
        of the <parameter>vector</parameter>.
-->
<parameter>vector</parameter>の各要素に指定した<parameter>weight</parameter>を割り当てます。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Assigns the specified <parameter>weight</parameter> to elements
        of the <parameter>vector</parameter> that are listed
        in <parameter>lexemes</parameter>.
-->
        <parameter>vector</parameter>の各要素に<parameter>lexemes</parameter>で列挙した<parameter>weight</parameter>を割り当てます。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Removes positions and weights from the <type>tsvector</type>.
-->
位置と重みを<type>tsvector</type>から削除します。
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  The words must be combined
        by valid <type>tsquery</type> operators.
-->
指定されたデフォルト設定にしたがって単語を正規化してテキストを<type>tsquery</type>に変換します。
単語は有効な<type>tsquery</type>演算子と組み合わされていなければなりません。
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Converts text to a <type>tsvector</type>, normalizing words according
        to the specified or default configuration.  Position information is
        included in the result.
-->
指定されたデフォルト設定にしたがって単語を正規化してテキストを<type>tsvector</type>に変換します。
位置情報が結果に含まれます。
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Converts each string value in the JSON document to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of string
        values.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>; observe the difference in the examples.)
-->
指定されたデフォルト設定にしたがって正規化してJSON文書中の文字列値を<type>tsvector</type>に変換します。
そして結果は文書中の順序にしたがって結合されます。
位置情報は、あたかも文字列値の各々の対の間にストップワードが存在するかのように生成されます。
（入力が<type>jsonb</type>の場合、JSONオブジェクトのフィールドの<quote>ドキュメント順</quote>は実装依存であることに注意してください。例中の差異を見てください。）
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Selects each item in the JSON document that is requested by
        the <parameter>filter</parameter> and converts each one to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of selected
        items.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>.)
        The <parameter>filter</parameter> must be a <type>jsonb</type>
        array containing zero or more of these keywords:
        <literal>"string"</literal> (to include all string values),
        <literal>"numeric"</literal> (to include all numeric values),
        <literal>"boolean"</literal> (to include all boolean values),
        <literal>"key"</literal> (to include all keys), or
        <literal>"all"</literal> (to include all the above).
        As a special case, the <parameter>filter</parameter> can also be a
        simple JSON value that is one of these keywords.
-->
<parameter>filter</parameter>によって要求された項目をJSON文書から検索し、指定されたデフォルト設定にしたがって正規化して<type>tsvector</type>に変換します。
そして結果は文書中の順序にしたがって結合されます。
位置情報は、あたかも文字列値の各々の対の間にストップワードが存在するかのように生成されます。
（入力が<type>jsonb</type>の場合、JSONオブジェクトのフィールドの<quote>ドキュメント順</quote>は実装依存であることに注意してください。例中の差異を見てください。）
<parameter>filter</parameter>は0個以上の以下のキーワードを含む<type>jsonb</type>の配列でなければなりません：
<literal>"string"</literal> (すべての文字列値を含めます)、<literal>"numeric"</literal> (すべての数値を含めます)、<literal>"boolean"</literal> (すべての論理値を含めます)、<literal>"key"</literal> (すべてのキーを含めます)、<literal>"all"</literal> (すべてを含めます)。
特別な場合として、<parameter>filter</parameter>はこれらのキーワードのどれかである単純なJSON値とすることもできます。
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Removes any occurrence of the given <parameter>lexeme</parameter>
        from the <parameter>vector</parameter>.
-->
<parameter>vector</parameter>から与えられた<parameter>lexeme</parameter>を削除します。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Removes any occurrences of the lexemes
        in <parameter>lexemes</parameter>
        from the <parameter>vector</parameter>.
-->
<parameter>vector</parameter>から<parameter>lexemes</parameter>中のすべての語彙素を削除します。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
<!--
        Selects only elements with the given <parameter>weights</parameter>
        from the <parameter>vector</parameter>.
-->
<parameter>vector</parameter>から<parameter>weights</parameter>を持つ要素だけを検索します。
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Displays, in an abbreviated form, the match(es) for
        the <parameter>query</parameter> in
        the <parameter>document</parameter>, which must be raw text not
        a <type>tsvector</type>.  Words in the document are normalized
        according to the specified or default configuration before matching to
        the query.  Use of this function is discussed in
        <xref linkend="textsearch-headline"/>, which also describes the
        available <parameter>options</parameter>.
-->
<parameter>document</parameter>中の<parameter>query</parameter>にマッチするものを省略形で表示します。
<parameter>document</parameter>は<type>tsvector</type>ではなくて生のテキストでなければなりません。
問い合わせのマッチ処理を行う前に、指定した、あるいはデフォルトの設定にしたがって単語が正規化されます。
<xref linkend="textsearch-headline"/>にこの関数の使い方が記述されています。可能な<parameter>options</parameter>についても言及されています。
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Displays, in an abbreviated form, match(es) for
        the <parameter>query</parameter> that occur in string values
        within the JSON <parameter>document</parameter>.
        See <xref linkend="textsearch-headline"/> for more details.
-->
JSON <parameter>document</parameter>中に出現する文字列値に<parameter>query</parameter>がマッチしたものを省略形で表示します。
詳細は<xref linkend="textsearch-headline"/>を見てください。
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
<!--
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>.  See
        <xref linkend="textsearch-ranking"/> for details.
-->
<parameter>vector</parameter>が<parameter>query</parameter>にどれほどマッチするかのスコアを計算します。
詳細は<xref linkend="textsearch-ranking"/>を見てください。
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
<!--
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>, using a cover density
        algorithm.  See <xref linkend="textsearch-ranking"/> for details.
-->
被覆密度アルゴリズムを用いて<parameter>vector</parameter>が<parameter>query</parameter>にどれほどマッチするかのスコアを計算します。
詳細は<xref linkend="textsearch-ranking"/>を見てください。
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Replaces occurrences of <parameter>target</parameter>
        with <parameter>substitute</parameter>
        within the <parameter>query</parameter>.
        See <xref linkend="textsearch-query-rewriting"/> for details.
-->
<parameter>query</parameter>中に出現する<parameter>target</parameter>を<parameter>substitute</parameter>に置き換えます。
詳細は<xref linkend="textsearch-query-rewriting"/>を見てください。
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Replaces portions of the <parameter>query</parameter> according to
        target(s) and substitute(s) obtained by executing
        a <command>SELECT</command> command.
        See <xref linkend="textsearch-query-rewriting"/> for details.
-->
<command>SELECT</command>を実行して取得したターゲットと代替を使用して<parameter>query</parameter>の一部を置き換えます。
詳細は<xref linkend="textsearch-query-rewriting"/>を見てください。
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter>
        and <parameter>query2</parameter> at successive lexemes (same
        as <literal>&lt;-&gt;</literal> operator).
-->
連続する語彙素で<parameter>query1</parameter>と<parameter>query2</parameter>のマッチを検索する語句問い合わせを作成します。
（<literal>&lt;-&gt;</literal>演算子と同じです。）
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
<!--
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter> and
        <parameter>query2</parameter> that occur exactly
        <parameter>distance</parameter> lexemes apart.
-->
語彙素が正確に<parameter>distance</parameter>だけ離れている<parameter>query1</parameter>と<parameter>query2</parameter>へのマッチを検索する語句問い合わせを作成します。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Converts a <type>tsvector</type> to an array of lexemes.
-->
<type>tsvector</type>を語彙素の配列に変換します。
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Expands a <type>tsvector</type> into a set of rows, one per lexeme.
-->
1行につき1語彙素で<type>tsvector</type>を行の集合に変換します。
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
-->
オプションの<type>regconfig</type>引数を受け付ける全てのテキスト検索関数は、その引数が省略された場合<xref linkend="guc-default-text-search-config"/>で指定された設定を使用します。
   </para>
  </note>

  <para>
<!--
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are primarily helpful for development and
   debugging of new text search configurations.
-->
<xref linkend="textsearch-functions-debug-table"/>の関数は、日常のテキスト検索操作では通常使用されないので、別の表にしました。
これらは主に新しいテキスト検索設定の開発およびデバッグに役立ちます。
  </para>

   <table id="textsearch-functions-debug-table">
<!--
    <title>Text Search Debugging Functions</title>
-->
    <title>テキスト検索デバッグ関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
<!--
        Extracts and normalizes tokens from
        the <parameter>document</parameter> according to the specified or
        default text search configuration, and returns information about how
        each token was processed.
        See <xref linkend="textsearch-configuration-testing"/> for details.
-->
指定した、あるいはデフォルトの設定にしたがって<parameter>document</parameter>から正規化されたトークンを取り出し、各トークンがどのように処理されたかの情報を返します。
詳細は<xref linkend="textsearch-configuration-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Returns an array of replacement lexemes if the input token is known to
        the dictionary, or an empty array if the token is known to the
        dictionary but it is a stop word, or NULL if it is not a known word.
        See <xref linkend="textsearch-dictionary-testing"/> for details.
-->
入力トークンが辞書にあれば代替の語彙素の配列、辞書にあるがストップワードである場合には空の配列、未知の単語ならNULLを返します。
詳細は<xref linkend="textsearch-dictionary-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Extracts tokens from the <parameter>document</parameter> using the
        named parser.
        See <xref linkend="textsearch-parser-testing"/> for details.
-->
名前で指定したパーサを使って<parameter>document</parameter>からトークンを取り出します。
詳細は<xref linkend="textsearch-parser-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Extracts tokens from the <parameter>document</parameter> using a
        parser specified by OID.
        See <xref linkend="textsearch-parser-testing"/> for details.
-->
OIDで指定されたパーサを使って<parameter>document</parameter>からトークンを取り出します。
詳細は<xref linkend="textsearch-parser-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Returns a table that describes each type of token the named parser can
        recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
-->
名前で指定したパーサが認識できるトークンの型を記述するテーブルを返します。
詳細は<xref linkend="textsearch-parser-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Returns a table that describes each type of token a parser specified
        by OID can recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
-->
OIDで指定したパーサが認識できるトークンの型を記述するテーブルを返します。
詳細は<xref linkend="textsearch-parser-testing"/>を見てください。
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
<!--
        Executes the <parameter>sqlquery</parameter>, which must return a
        single <type>tsvector</type> column, and returns statistics about each
        distinct lexeme contained in the data.
        See <xref linkend="textsearch-statistics"/> for details.
-->
単一の<type>tsvector</type>列を返さなければならない<parameter>sqlquery</parameter>を実行し、データに含まれる別個の語彙素に関する統計情報を返します。
詳細は<xref linkend="textsearch-statistics"/>をご覧ください。
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

 </sect1>

 <sect1 id="functions-uuid">
<!--
  <title>UUID Functions</title>
-->
  <title>UUID関数</title>

  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>generating</secondary>
  </indexterm>
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>生成</secondary>
  </indexterm>

  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> includes one function to generate a UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
<!--
   This function returns a version 4 (random) UUID.  This is the most commonly
   used type of UUID and is appropriate for most applications.
-->
この関数はバージョン4(ランダム)UUIDを返します。
これはUUIDのもっとも一般的な使い方で、大抵のアプリケーションに適しています。
  </para>

  <para>
<!--
   The <xref linkend="uuid-ossp"/> module provides additional functions that
   implement other standard algorithms for generating UUIDs.
-->
<xref linkend="uuid-ossp"/>モジュールはUUID生成のための他の標準アルゴリズムを実装した追加の関数を提供します。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> also provides the usual comparison
   operators shown in <xref linkend="functions-comparison-op-table"/> for
   UUIDs.
-->
<productname>PostgreSQL</productname>は<xref linkend="functions-comparison-op-table"/>で示すUUIDのための通常の比較演算子を提供しています。
  </para>
 </sect1>

 <sect1 id="functions-xml">

<!--
  <title>XML Functions</title>
-->
  <title>XML関数</title>

  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>

  <para>
<!--
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
-->
この節で説明される関数および擬似関数式は、<type>xml</type>型の値に対して機能します。
<type>xml</type>型についての情報は<xref linkend="datatype-xml"/>を参照してください。
<type>xml</type>型のやりとりを変換する<function>xmlparse</function>および<function>xmlserialize</function>擬似関数式はこの節ではなく、そこに記載されています。
  </para>

  <para>
<!--
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure &#045;&#045;with-libxml</command>.
-->
これらの関数の大半は<productname>PostgreSQL</productname>が<command>configure --with-libxml</command>でビルドされていることを必要としています。
  </para>

  <sect2 id="functions-producing-xml">
<!--
   <title>Producing XML Content</title>
-->
   <title>XML内容の生成</title>

   <para>
<!--
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
-->
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;&#045;</literal></quote> or end with a
     <quote><literal>-</literal></quote>, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
-->
関数<function>xmlcomment</function>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
テキストは<quote><literal>--</literal></quote>を含むこと、または<quote><literal>-</literal></quote>で終結することはできません。さもないと結果として構築されるXMLコメントは有効になりません。
引数がNULLならば結果もNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
-->
関数<function>xmlconcat</function>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
<!--
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
-->
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXML version宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<quote>yes</quote>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<quote>no</quote>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
     The <replaceable>name</replaceable>
     and <replaceable>attname</replaceable> items shown in the syntax are
     simple identifiers, not values.  The <replaceable>attvalue</replaceable>
     and <replaceable>content</replaceable> items are expressions, which can
     yield any <productname>PostgreSQL</productname> data type.  The
     argument(s) within <literal>XMLATTRIBUTES</literal> generate attributes
     of the XML element; the <replaceable>content</replaceable> value(s) are
     concatenated to form its content.
-->
<function>xmlelement</function>式は与えられた名前、属性、および内容を持つXML要素を生成します。
構文中に示す<replaceable>name</replaceable>と<replaceable>attname</replaceable>項目は単純な識別子で値ではありません。
<replaceable>attvalue</replaceable>と<replaceable>content</replaceable>項目は式で、<productname>PostgreSQL</productname>の任意のデータ型を出力できます。
<literal>XMLATTRIBUTES</literal>中の引数はXML要素の属性を生成します。<replaceable>content</replaceable>値は結合して内容を構成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
有効なXML名ではない要素名と属性名は、シーケンス<literal>_x<replaceable>HHHH</replaceable>_</literal>により障害となる文字を置換することでエスケープされます。ここで、<replaceable>HHHH</replaceable>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
<!--
     But these are not:
-->
しかし、以下の例は有効ではありません。
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<type>xml</type>型であれば、複合XML文書が構築されます。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

<!--
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
-->
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<type>bytea</type>）は、設定パラメータ<xref linkend="guc-xmlbinary"/>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for <function>xmlelement</function>,
     each <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expressions can have any data
     type.
-->
<function>xmlforest</function>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
<function>xmlelement</function>では、各<replaceable>name</replaceable>は単純な識別子でなければなりませんが、<replaceable>content</replaceable>式はどんな型のデータも持つことができます。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------&zwsp;-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

<!--
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </para>

    <para>
<!--
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
-->
有効なXML名ではない要素名は上の<function>xmlelement</function>で説明した通りエスケープされます。
同様にして、既に<type>xml</type>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </para>

    <para>
<!--
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
-->
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<function>xmlelement</function>内に<function>xmlforest</function>式をラップすることが有用なことがあります。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The <function>xmlpi</function> expression creates an XML
     processing instruction.
     As for <function>xmlelement</function>,
     the <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expression can have any data type.
     The <replaceable>content</replaceable>, if present, must not contain the
     character sequence <literal>?&gt;</literal>.
-->
<function>xmlpi</function>式はXML処理命令を作成します。
<function>xmlelement</function>では、各<replaceable>name</replaceable>は単純な識別子でなければなりませんが、<replaceable>content</replaceable>式はどんな型のデータも持つことができます。
<replaceable>content</replaceable>が存在するときは、それは<literal>?&gt;</literal>という文字シーケンスを含んではいけません。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
-->
<function>xmlroot</function>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
-->
ここで説明している他の関数とは異なり、<function>xmlagg</function>関数は集約関数です。
これは<function>xmlconcat</function>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<xref linkend="functions-aggregate"/>を参照してください。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:
-->
連結の順序を決定するため、<xref linkend="syntax-aggregates"/>に記述されているように<literal>ORDER BY</literal>句を集計呼び出しに追加することができます。
以下は例です。

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは依然として有用かもしれません。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--
    <title>XML Predicates</title>
-->
    <title>XML述語</title>

    <para>
<!--
     The expressions described in this section check properties
     of <type>xml</type> values.
-->
この節で記述されている式は、<type>xml</type>値の属性をチェックします。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

    <para>
<!--
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
-->
式<literal>IS DOCUMENT</literal>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<xref linkend="datatype-xml"/>を参照してください。
    </para>
   </sect3>

   <sect3>
    <title><literal>IS NOT DOCUMENT</literal></title>

    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

    <para>
<!--
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
-->
式<literal>IS NOT DOCUMENT</literal>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
-->
関数<function>xmlexists</function>は渡されたXML値をコンテキスト項目としてXPath 1.0式（第一引数）を評価します。
この関数は評価が空のノード集合を生成する場合には偽を返し、それ以外の値を返すならば真を返します。
もしどれかの引数がNULLであった場合はNULLを返します。
コンテキスト項目として渡される非NULLの値は、内容の断片や非XML値ではなく、XML文書でなければなりません。
    </para>

    <para>
<!--
     Example:
-->
例:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
<!--
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
-->
<productname>PostgreSQL</productname>は<literal>BY REF</literal>句と<literal>BY VALUE</literal>句を受け付けますが、<xref linkend="functions-xml-limits-postgresql"/>で議論されているように無視します。
    </para>

    <para>
<!--
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
SQL標準では<function>xmlexists</function>関数はXML問い合わせ言語における式を評価しますが、<xref linkend="functions-xml-limits-xpath1"/>で議論されているように、<productname>PostgreSQL</productname>はXPath 1.0の式だけを受け付けます。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>

    <para>
<!--
     These functions check whether a <type>text</type> string represents
     well-formed XML, returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
-->
これらの関数は<type>text</type>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<function>xml_is_well_formed_document</function>は文書が整形式かをチェックし、一方<function>xml_is_well_formed_content</function>は内容が整形式かをチェックします。
<function>xml_is_well_formed</function>は、<xref linkend="guc-xmloption"/>パラメータ値が<literal>DOCUMENT</literal>に設定されていれば前者を、<literal>CONTENT</literal>が設定されていれば後者のチェックを実施します。
これは、<function>xml_is_well_formed</function>は単純な<type>xml</type>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<function>XMLPARSE</function>の対応による変換が成功するかの判断に有用であることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

<!--
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--
   <title>Processing XML</title>
-->
   <title>XMLの処理</title>

   <para>
<!--
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
-->
データ型<type>xml</type>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<function>xpath</function>および<function>xpath_exists</function>と、テーブル関数<function>XMLTABLE</function>を提供しています。
   </para>

   <sect3 id="functions-xml-processing-xpath">
    <title><literal>xpath</literal></title>

    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <parameter>xpath</parameter> (given as text)
     against the XML value
     <parameter>xml</parameter>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
-->
関数<function>xpath</function>は、XML値<parameter>xml</parameter>に対し、XPath 1.0式<parameter>xpath</parameter>(テキストとして指定)を評価します。
そして、XPath式で作成されたノード集合に対応するXML値の配列を返します。
もし、XPath式がノード集合ではなくスカラー値を返す場合、単一要素の配列が返されます。
    </para>

    <para>
<!--
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
-->
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </para>

    <para>
<!--
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
-->
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<type>text</type>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<function>xpath</function>関数の両方の文脈の中で、別名は<emphasis>ローカル</emphasis>です）。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
    </para>

    <para>
<!--
     To deal with default (anonymous) namespaces, do something like this:
-->
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
    <title><literal>xpath_exists</literal></title>

    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>

<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

    <para>
<!--
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
-->
関数<function>xpath_exists</function>は、<function>xpath</function>関数の特別な形式です。
この関数は、XPath 1.0を満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうか（具体的には空のノード集合以外の値を返すかどうか）を論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<literal>XMLEXISTS</literal>述語と同じです。
    </para>

    <para>
<!--
     Example:
-->
例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
    <title><literal>xmltable</literal></title>

    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
    </indexterm>
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>テーブル関数</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>

    <para>
<!--
     The <function>xmltable</function> expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's <literal>FROM</literal> clause.
-->
<function>xmltable</function>式は、与えられたXML値、行を抽出するXPathフィルタ、オプションの列定義の集合に基づいてテーブルを生成します。
関数と構文的に似ていますが、これは問い合わせ中の<literal>FROM</literal>句におけるテーブルとしてのみ使用できます。
    </para>

    <para>
<!--
     The optional <literal>XMLNAMESPACES</literal> clause gives a
     comma-separated list of namespace definitions, where
     each <replaceable>namespace_uri</replaceable> is a <type>text</type>
     expression and each <replaceable>namespace_name</replaceable> is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
-->
オプションの<literal>XMLNAMESPACES</literal>句はカンマで区切られた名前空間のリストを与えます。
各々の<replaceable>namespace_uri</replaceable>は<type>text</type>式で、<replaceable>namespace_name</replaceable>は単純な識別子です。
これは文書とその別名で使用されるXML名前空間を指定します。
デフォルトの名前空間指定は現在のところサポートされていません。
    </para>

    <para>
<!--
     The required <replaceable>row_expression</replaceable> argument is an
     XPath 1.0 expression (given as <type>text</type>) that is evaluated,
     passing the XML value <replaceable>document_expression</replaceable> as
     its context item, to obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
-->
必須の<replaceable>row_expression</replaceable>引数は評価されるXPath 1.0式(<type>text</type>で与えます)で、XMLノード集合を得るために<replaceable>document_expression</replaceable>をそのコンテキスト項目として渡します。
このノードは<function>xmltable</function>が出力行に変換します。
<replaceable>document_expression</replaceable>がNULLであるか、<replaceable>row_expression</replaceable>が空のノード集合あるいはノード集合以外の値を生成するなら行は出力されません。
    </para>

    <para>
<!--
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
-->
<replaceable>document_expression</replaceable>は<replaceable>row_expression</replaceable>のためのコンテキスト項目を提供します。
それは整形式XMLの文書でなければならず、フラグメントやフォレストは受け付けられません。
<xref linkend="functions-xml-limits-postgresql"/>で議論されているように、<literal>BY REF</literal>句と<literal>BY VALUE</literal>句は受け付けられますが、無視されます。
    </para>

    <para>
<!--
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
SQL標準では<function>xmltable</function>関数はXML問い合わせ言語の式を評価しますが、<xref linkend="functions-xml-limits-xpath1"/>で議論されているように<productname>PostgreSQL</productname>ではXPath 1.0式だけを受け付けます。
    </para>

    <para>
<!--
     The required <literal>COLUMNS</literal> clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless <literal>FOR ORDINALITY</literal> is specified, in which case
     type <type>integer</type> is implicit).  The path, default and
     nullability clauses are optional.
-->
必須の<literal>COLUMNS</literal>句は、出力テーブルに現れる列を指定します。
形式については上記の構文サマリーを参照してください。
各列には名前が必須で、データ型についても同様です。（<literal>FOR ORDINALITY</literal>が指定された場合を除きます。その場合は暗黙的に<type>integer</type>が想定されます。）
パス、デフォルト値、NULLを許すかどうかの句は省略できます。
    </para>

    <para>
<!--
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
-->
<literal>FOR ORDINALITY</literal>と印がつけられた列には、<replaceable>row_expression</replaceable>の結果ノード集合から取得されたノードの順序に対応する1から始まる行番号が入ります。
<literal>FOR ORDINALITY</literal>の印が付けられるのは最大でも1列です。
    </para>

    <note>
     <para>
<!--
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
-->
XPath 1.0はノード集合内のノードの順序を指定しません。ですから、結果が特定の順序になっていることに依存するコードは実装依存となります。
詳細は<xref linkend="xml-xpath-1-specifics"/>をご覧ください。
     </para>
    </note>

    <para>
<!--
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
-->
列の<replaceable>column_expression</replaceable>はXPath 1.0式で、<replaceable>row_expression</replaceable>の結果における現在のノードをそのコンテキスト項目として<replaceable>row_expression</replaceable>の結果に対応する各行について評価されて、列の値を得ます。
<replaceable>column_expression</replaceable> が与えられなかった場合は、暗黙的なパスとして列名が使用されます。
    </para>

    <para>
<!--
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
-->
列のXPath式が非XML値（XPath 1.0における文字列、論理値、倍精度浮動小数点数に限られます）を返し、その列が<type>xml</type>以外のPostgreSQL型なら、あたかも値の文字列表現をPostgreSQL型にアサインしたように列に値がセットされます。
（値が論理値の場合、出力列型が数値カテゴリに属するならその文字列表現は<literal>1</literal>または<literal>0</literal>になり、それ外なら<literal>true</literal>または<literal>false</literal>になります。）
    </para>

    <para>
<!--
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
-->
列のXPath表現が空ではないXMLノードの集合を返し、列のPostgreSQL型が<type>xml</type>である場合には、式が文書あるいはフォームの内容なら、列には正確に式の結果がアサインされます。
     <footnote>
      <para>
<!--
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
-->
トップレベルにおいて複数の要素ノードを含むか、あるいは要素の外側の非空白テキストであるような結果は、コンテントフォームの例です。
XPathの結果はそのどちらでもないフォームであることがあり得ます。
たとえば、それを含む要素から選択された属性ノードを返す場合です。
XPath 1.0の<function>string</function>関数で定義されているように、そうした結果は、許可されないノードを文字列値で置き換えたコンテントフォームに設定されます。
      </para>
     </footnote>
    </para>

    <para>
<!--
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
-->
<type>xml</type>出力列にアサインされた非XMLの結果は、結果の値が文字列値となる単一のテキストノードであるコンテントを生成します。
それ以外の型の列にアサインされたXMLの結果は複数のノードを持たないかも知れませんし、エラーを生じするかも知れません。
正確に一つのノードだけが存在するなら、列にはあたかもノードの文字列値（XPath 1.0 <function>string</function>関数の定義されているように） がPostgreSQL型にアサインされたように設定されます。
    </para>

    <para>
<!--
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
-->
ある要素と、その子孫に含まれるすべてのテキストノードをドキュメントの順に結合したものがXML要素の文字列値です。
テキストノードの子孫を持たない要素の文字列値は空文字列です。（ <literal>NULL</literal>ではありません。）
すべての<literal>xsi:nil</literal>属性は無視されます。
非テキスト要素の間にある空白のみからなる<literal>text()</literal>2つのノードは保存され、<literal>text()</literal>の先頭の空白は平坦化されないことに注意してください。
XPath 1.0 <function>string</function>関数が、他のXMLノード型と非XML値の文字列値を定義するルールのために参照されるかも知れません。
    </para>

    <para>
<!--
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
-->
ここで示した変換ルールは、<xref linkend="functions-xml-limits-casts"/>で議論されているように、正確にSQL標準に従っているわけではありません。
    </para>

    <para>
<!--
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
-->
パス式がある行に対して空のノード集合（典型的にはマッチしなかった場合）を返した時は、<replaceable>default_expression</replaceable>が指定されている場合を除き、列には<literal>NULL</literal>が設定されます。
そしてその式を評価した結果から生じる値が使用されます。
    </para>

    <para>
<!--
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
-->
<function>xmltable</function>が呼び出されて直ちに評価されるのと異なり、<replaceable>default_expression</replaceable>はその列に対してデフォルトが必要になるたびに評価されます。
式が安定（stable）または不変（immutable）とみなされる場合、評価は繰り返し行われないかもしれません。
これは<replaceable>default_expression</replaceable>の中で<function>nextval</function>のような揮発性関数を使用できることを意味します。
    </para>

    <para>
<!--
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT
     NULL</literal> column does not match anything and there is
     no <literal>DEFAULT</literal> or
     the <replaceable>default_expression</replaceable> also evaluates to null,
     an error is reported.
-->
列には<literal>NOT NULL</literal>の印をつけることができます。
<literal>NOT NULL</literal>の列の<replaceable>column_expression</replaceable>が何にもマッチせず、<literal>DEFAULT</literal>がない、あるいは<replaceable>default_expression</replaceable>の評価結果もNULLになるという場合はエラーが報告されます。
    </para>

    <para>
<!--
     Examples:
-->
例:
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

<!--
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
-->
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-------------------------
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>

    <para>
<!--
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
-->
以下の例では、<literal>XMLNAMESPACES</literal>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--
   <title>Mapping Tables to XML</title>
-->
   <title>XMLにテーブルをマップ</title>

   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>

   <para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

   <para>
<!--
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>table</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualification and
    double quotes (see <xref linkend="datatype-oid"/> for details).
    <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
-->
<function>table_to_xml</function>は、パラメータ<parameter>table</parameter>として渡された名前付きのテーブルの内容をマップします。
<type>regclass</type>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。（詳細は<xref linkend="datatype-oid"/>を参照してください。）
<function>query_to_xml</function>は、パラメータ<parameter>query</parameter>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<function>cursor_to_xml</function>は、パラメータ<parameter>cursor</parameter>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </para>

   <para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
<parameter>tableforest</parameter>が偽であれば、結果のXML文書は以下のようになります。
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

<!--
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
<parameter>tableforest</parameter>が真であれば、結果は以下のようなXML文書の断片です。
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

<!--
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<literal>table</literal>が使用され、２番目の書式では<literal>row</literal>が使用されます。
   </para>

   <para>
<!--
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
-->
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<function>cursor_to_xml</function>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<function>xmlelement</function>は結果を好みにかえるために使用することができます。
   </para>

   <para>
<!--
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
-->
データの値は上記関数<function>xmlelement</function>で説明したのと同じ方法でマップされます。
   </para>

   <para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
パラメータ<parameter>nulls</parameter>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
<!--
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
-->
ここで<literal>xsi</literal>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </para>

   <para>
<!--
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
-->
パラメータ<parameter>targetns</parameter>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </para>

   <para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
<!--
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
-->
一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </para>

   <para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

   <para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--
    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have <literal>USAGE</literal> (lookup) privilege for.
-->
これらの関数は現在のユーザが読めないテーブルは無視します。
加えてデータベース中全体に渡る関数は現在のユーザが<literal>USAGE</literal>（検索）権限を持たないスキーマを無視します。
   </para>

   <para>
<!--
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </para>

   <para>
<!--
    The result of a schema content mapping looks like this:
-->
スキーマ内容マッピングの結果は以下のようになります。

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!--
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
-->
ここで、テーブルマッピング書式は上で説明したとおり<parameter>tableforest</parameter>パラメータに依存します。
   </para>

   <para>
<!--
    The result of a database content mapping looks like this:
-->
データベース内容マッピング書式は以下のようになります。

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!--
    where the schema mapping is as above.
-->
ここで、スキーママッピングは上記のとおりです。
   </para>

   <para>
<!--
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
-->
これらの関数で作成された出力を使用する１つの例として、<xref linkend="xslt-xml-html"/>は、テーブルデータの表形式への翻訳を含む<function>table_to_xml_and_xmlschema</function>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </para>

   <example id="xslt-xml-html">
<!--
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
-->
    <title>SQL/XML出力をHTMLに変換するXSLTスタイルシート</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </example>
  </sect2>
 </sect1>

<!-- split-func2-end -->
