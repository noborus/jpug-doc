<!-- doc/src/sgml/brin.sgml -->

<sect1 id="brin">
<!--
<title>BRIN Indexes</title>
-->
<title>BRINインデックス</title>

   <indexterm>
    <primary>index</primary>
    <secondary>BRIN</secondary>
   </indexterm>

<sect2 id="brin-intro">
<!--
 <title>Introduction</title>
-->
 <title>はじめに</title>

 <para>
<!--
  <acronym>BRIN</acronym> stands for Block Range Index.
  <acronym>BRIN</acronym> is designed for handling very large tables
  in which certain columns have some natural correlation with their
  physical location within the table.
-->
<acronym>BRIN</acronym>は「ブロックレンジインデックス」(Block Range Index)の略です。
<acronym>BRIN</acronym>は、ある列がテーブル内の物理的な位置と自然な相関があるような、非常に大規模なテーブルのために設計されています。
 </para>

 <para>
<!--
  <acronym>BRIN</acronym> works in terms of <firstterm>block ranges</firstterm>
  (or <quote>page ranges</quote>).
  A block range is a group of pages that are physically
  adjacent in the table; for each block range, some summary info is stored
  by the index.
  For example, a table storing a store's sale orders might have
  a date column on which each order was placed, and most of the time
  the entries for earlier orders will appear earlier in the table as well;
  a table storing a ZIP code column might have all codes for a city
  grouped together naturally.
-->
<acronym>BRIN</acronym>は<firstterm>ブロックレンジ(block range)</firstterm>（または<quote>ページレンジ(page range)</quote>）として動作します。
<firstterm>ブロックレンジ(block range)</firstterm>は、テーブル内で物理的に隣接するページのグループです。それぞれのブロックレンジに対して、ある種の要約情報がインデックス内に格納されます。
たとえば、店舗の受注情報を格納するテーブルは、各々の受注時期を格納する日付列を持つでしょう。大抵の場合、より前の受注エントリは、テーブルのより前の方にあるでしょう。
郵便番号を管理するテーブルでは、ある市に属する郵便番号が自然にグループ化されることになるでしょう。
 </para>

 <para>
<!--
  <acronym>BRIN</acronym> indexes can satisfy queries via regular bitmap
  index scans, and will return all tuples in all pages within each range if
  the summary info stored by the index is <firstterm>consistent</firstterm> with the
  query conditions.
  The query executor is in charge of rechecking these tuples and discarding
  those that do not match the query conditions &mdash; in other words, these
  indexes are lossy.
  Because a <acronym>BRIN</acronym> index is very small, scanning the index
  adds little overhead compared to a sequential scan, but may avoid scanning
  large parts of the table that are known not to contain matching tuples.
-->
<acronym>BRIN</acronym>インデックスは、通常のビットマップインデックススキャンを通じて要求されるクエリに使用することができます。
すなわち、インデックス内のレンジ要約情報が検索条件と<firstterm>一致</firstterm>すれば、<acronym>BRIN</acronym>インデックスは、レンジ内の全タプルを返します。
クエリエグゼキュータの役割は、検索条件を再チェックし、条件に合致しないタプルを捨てることです。
つまり言い換えると、<acronym>BRIN</acronym>インデックスには損失性があります。
<acronym>BRIN</acronym>インデックスは非常に小さいため、それに対するスキャンはシーケンシャルスキャンに比べると小さなオーバーヘッドしか与えません。しかし、あらかじめ条件に合致しないと分かっているテーブルの多くの部分をスキャンすることを避けることができます。
 </para>

 <para>
<!--
  The specific data that a <acronym>BRIN</acronym> index will store,
  as well as the specific queries that the index will be able to satisfy,
  depend on the operator class selected for each column of the index.
  Data types having a linear sort order can have operator classes that
  store the minimum and maximum value within each block range, for instance;
  geometrical types might store the bounding box for all the objects
  in the block range.
-->
<acronym>BRIN</acronym>インデックスに格納される特定のデータと、そのインデックスが対応できる特定のクエリは、インデックスに対応する各々の列に与えられた演算子クラスに依存します。
線形のソート順を持つデータ型は、ブロックレンジ内の最小値と最大値と格納する演算子クラスを持つことができます。
たとえば、幾何データ型は、ブロックレンジ内のすべてのオブジェクトを含む外接矩形を持つことでしょう。
 </para>

 <para>
<!--
  The size of the block range is determined at index creation time by
  the <literal>pages_per_range</literal> storage parameter.  The number of index
  entries will be equal to the size of the relation in pages divided by
  the selected value for <literal>pages_per_range</literal>.  Therefore, the smaller
  the number, the larger the index becomes (because of the need to
  store more index entries), but at the same time the summary data stored can
  be more precise and more data blocks can be skipped during an index scan.
-->
ブロックレンジの大きさは、ストレージパラメータ<literal>pages_per_range</literal>でインデックス作成時に決定されます。
インデックスエントリの数は、リレーションのページ数を<literal>pages_per_range</literal>に設定した数で割ったものと等しくなります。
ですから、<literal>pages_per_range</literal>の設定値が小さいほど、インデックスは大きくなります(より多くのインデックスエントリを格納する必要があるので)が、反面、格納されたサマリデータはより精密になり、インデックススキャンの際により多くのデータブロックをスキップすることができるようになります。
 </para>

 <sect3 id="brin-operation">
<!--
  <title>Index Maintenance</title>
-->
  <title>インデックスの保守</title>

  <para>
<!--
   At the time of creation, all existing heap pages are scanned and a
   summary index tuple is created for each range, including the
   possibly-incomplete range at the end.
   As new pages are filled with data, page ranges that are already
   summarized will cause the summary information to be updated with data
   from the new tuples.
   When a new page is created that does not fall within the last
   summarized range, the range that the new page belongs to
   does not automatically acquire a summary tuple;
   those tuples remain unsummarized until a summarization run is
   invoked later, creating the initial summary for that range.
-->
インデックスを作成した当初は、すべてのヒープページがスキャンされ、終端が不完全なものも含め、各々のレンジに対してサマリインデックスタプルが作成されます。
新しいページにデータが登録されると、新しいタプルのデータを元に、すでにサマリ済みのページレンジのサマリ情報が更新されます。
最終サマリレンジに適合しない新しいページが作成されると、そのレンジに対して自動的にはサマリタプルが作成されません。
これらのタプルは、後でサマリ処理が走って初期サマリ情報が作成されるまではサマリされません。
  </para>

  <para>
<!--
   There are several ways to trigger the initial summarization of a page range.
   If the table is vacuumed, either manually or by
   <link linkend="autovacuum">autovacuum</link>, all existing unsummarized
   page ranges are summarized.
   Also, if the index's
   <xref linkend="index-reloption-autosummarize"/> parameter is enabled,
   which it isn't by default,
   whenever autovacuum runs in that database, summarization will occur for all
   unsummarized page ranges that have been filled,
   regardless of whether the table itself is processed by autovacuum; see below.
-->
ページレンジの初期サマリ処理を起動する複数の方法があります。
手動あるいは<link linkend="autovacuum">autovacuum</link>のどちらでも良いですが、テーブルがバキュームされるとすべてのまだサマライズされていないページレンジがサマライズされます。
また、インデックスの<xref linkend="index-reloption-autosummarize"/>パラメータが有効なら、これはデフォルトでは有効ではありませんが、そのデータベースに対してバキュームが実行されると、自動バキュームによってそのテーブル自体が処理されるかどうかにかかわらず、すべての挿入された未サマリページレンジに対してサマリ処理が実行されます。
以下を見てください。
  </para>

  <para>
<!--
   Lastly, the following functions can be used (while these functions run,
   <xref linkend="guc-search-path"/> is temporarily changed to
   <literal>pg_catalog, pg_temp</literal>):
-->
最後に、次の関数を使用できます（これらの関数の実行中、<xref linkend="guc-search-path"/>は一時的に<literal>pg_catalog, pg_temp</literal>に変更されます）。
   <simplelist>
    <member>
<!--
     <function>brin_summarize_new_values(regclass)</function>
     which summarizes all unsummarized ranges;
-->
すべての未サマリレンジをサマライズする<function>brin_summarize_new_values(regclass)</function>
    </member>
    <member>
<!--
     <function>brin_summarize_range(regclass, bigint)</function>
     which summarizes only the range containing the given page,
     if it is unsummarized.
-->
もしまだサマライズされていなければ、指定されたページを含む指定されたレンジのみをサマライズする<function>brin_summarize_range(regclass, bigint)</function>
    </member>
   </simplelist>
  </para>

  <para>
<!--
   When autosummarization is enabled, a request is sent to
   <literal>autovacuum</literal> to execute a targeted summarization
   for a block range when an insertion is detected for the first item
   of the first page of the next block range,
   to be fulfilled the next time an autovacuum
   worker finishes running in the
   same database.  If the request queue is full, the request is not recorded
   and a message is sent to the server log:
-->
自動サマリ機能が有効な場合、次のブロックレンジの最初のページの最初の項目の挿入が検出されると、同じデータベースで実行中の自動バキュームワーカーの次の実行の終了時に処理されるブロックレンジをターゲットとするサマリ機能を実行する要求が<literal>autovacuum</literal>に送信されます。
もしリクエストキューが満杯ならばそのリクエストは記録されず、次のメッセージがサーバのログに送信されます。
<screen>
LOG:  request for BRIN range summarization for index "brin_wi_idx" page 128 was not recorded
</screen>
<!--
   When this happens, the range will remain unsummarized until the next
   regular vacuum run on the table, or one of the functions mentioned above
   are invoked.
-->
この状態が発生すると、テーブルの次の通常バキュームが実行されるか、上で述べた関数のどれかが実行されるまでは、そのレンジはサマライズされない状態にとどまります。
  </para>

  <para>
<!--
   Conversely, a range can be de-summarized using the
   <function>brin_desummarize_range(regclass, bigint)</function> function,
   which is useful when the index tuple is no longer a very good
   representation because the existing values have changed.
   See <xref linkend="functions-admin-index"/> for details.
-->
反対に、レンジは<function>brin_desummarize_range(regclass, bigint)</function>関数で非サマリ化できます。
これは、既存の値が変更されたためにインデックスタプルがもはや値の表現としては適当でなくなった場合に有効です。
詳細は<xref linkend="functions-admin-index"/>を見てください。
  </para>

 </sect3>
</sect2>

<sect2 id="brin-builtin-opclasses">
<!--
 <title>Built-in Operator Classes</title>
-->
 <title>組み込み演算子クラス</title>

 <para>
<!--
  The core <productname>PostgreSQL</productname> distribution
  includes the <acronym>BRIN</acronym> operator classes shown in
  <xref linkend="brin-builtin-opclasses-table"/>.
-->
<productname>PostgreSQL</productname>のコア配布物には、<xref linkend="brin-builtin-opclasses-table"/>で示される<acronym>BRIN</acronym>演算子クラスが含まれます。
 </para>

 <para>
<!--
  The <firstterm>minmax</firstterm>
  operator classes store the minimum and the maximum values appearing
  in the indexed column within the range.  The <firstterm>inclusion</firstterm>
  operator classes store a value which includes the values in the indexed
  column within the range.  The <firstterm>bloom</firstterm> operator
  classes build a Bloom filter for all values in the range.  The
  <firstterm>minmax-multi</firstterm> operator classes store multiple
  minimum and maximum values, representing values appearing in the indexed
  column within the range.
-->
<firstterm>minmax</firstterm>演算子クラスは、インデックスが貼られた列の範囲内に現れる最小値と最大値を格納します。
<firstterm>inclusion</firstterm>演算子クラスは、インデックスが貼られた列の範囲内に含まれる値を格納します。
<firstterm>bloom</firstterm>演算子クラスは、その範囲内のすべての値に対してブルームフィルタを構築します。
<firstterm>minmax-multi</firstterm>演算子クラスは、インデックスが貼られた列の範囲内に現れる複数の最小値と最大値、代表値を格納します。
 </para>

 <table id="brin-builtin-opclasses-table">
<!--
  <title>Built-in <acronym>BRIN</acronym> Operator Classes</title>
-->
  <title>組み込み<acronym>BRIN</acronym>演算子クラス</title>
  <tgroup cols="2">
   <thead>
    <row>
<!--
     <entry>Name</entry>
     <entry>Indexable Operators</entry>
-->
     <entry>名前</entry>
     <entry>インデックス可能な演算子</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry valign="middle" morerows="4"><literal>bit_minmax_ops</literal></entry>
     <entry><literal>= (bit,bit)</literal></entry>
    </row>
    <row><entry><literal>&lt; (bit,bit)</literal></entry></row>
    <row><entry><literal>&gt; (bit,bit)</literal></entry></row>
    <row><entry><literal>&lt;= (bit,bit)</literal></entry></row>
    <row><entry><literal>&gt;= (bit,bit)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="12"><literal>box_inclusion_ops</literal></entry>
     <entry><literal>@&gt; (box,point)</literal></entry>
    </row>
    <row><entry><literal>&lt;&lt; (box,box)</literal></entry></row>
    <row><entry><literal>&amp;&lt; (box,box)</literal></entry></row>
    <row><entry><literal>&amp;&gt; (box,box)</literal></entry></row>
    <row><entry><literal>&gt;&gt; (box,box)</literal></entry></row>
    <row><entry><literal>&lt;@ (box,box)</literal></entry></row>
    <row><entry><literal>@&gt; (box,box)</literal></entry></row>
    <row><entry><literal>~= (box,box)</literal></entry></row>
    <row><entry><literal>&amp;&amp; (box,box)</literal></entry></row>
    <row><entry><literal>&lt;&lt;| (box,box)</literal></entry></row>
    <row><entry><literal>&amp;&lt;| (box,box)</literal></entry></row>
    <row><entry><literal>|&amp;&gt; (box,box)</literal></entry></row>
    <row><entry><literal>|&gt;&gt; (box,box)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>bpchar_bloom_ops</literal></entry>
     <entry><literal>= (character,character)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>bpchar_minmax_ops</literal></entry>
     <entry><literal>= (character,character)</literal></entry>
    </row>
    <row><entry><literal>&lt; (character,character)</literal></entry></row>
    <row><entry><literal>&lt;= (character,character)</literal></entry></row>
    <row><entry><literal>&gt; (character,character)</literal></entry></row>
    <row><entry><literal>&gt;= (character,character)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>bytea_bloom_ops</literal></entry>
     <entry><literal>= (bytea,bytea)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>bytea_minmax_ops</literal></entry>
     <entry><literal>= (bytea,bytea)</literal></entry>
    </row>
    <row><entry><literal>&lt; (bytea,bytea)</literal></entry></row>
    <row><entry><literal>&lt;= (bytea,bytea)</literal></entry></row>
    <row><entry><literal>&gt; (bytea,bytea)</literal></entry></row>
    <row><entry><literal>&gt;= (bytea,bytea)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>char_bloom_ops</literal></entry>
     <entry><literal>= ("char","char")</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>char_minmax_ops</literal></entry>
     <entry><literal>= ("char","char")</literal></entry>
    </row>
    <row><entry><literal>&lt; ("char","char")</literal></entry></row>
    <row><entry><literal>&lt;= ("char","char")</literal></entry></row>
    <row><entry><literal>&gt; ("char","char")</literal></entry></row>
    <row><entry><literal>&gt;= ("char","char")</literal></entry></row>

    <row>
     <entry valign="middle"><literal>date_bloom_ops</literal></entry>
     <entry><literal>= (date,date)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>date_minmax_ops</literal></entry>
     <entry><literal>= (date,date)</literal></entry>
    </row>
    <row><entry><literal>&lt; (date,date)</literal></entry></row>
    <row><entry><literal>&lt;= (date,date)</literal></entry></row>
    <row><entry><literal>&gt; (date,date)</literal></entry></row>
    <row><entry><literal>&gt;= (date,date)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>date_minmax_multi_ops</literal></entry>
     <entry><literal>= (date,date)</literal></entry>
    </row>
    <row><entry><literal>&lt; (date,date)</literal></entry></row>
    <row><entry><literal>&lt;= (date,date)</literal></entry></row>
    <row><entry><literal>&gt; (date,date)</literal></entry></row>
    <row><entry><literal>&gt;= (date,date)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>float4_bloom_ops</literal></entry>
     <entry><literal>= (float4,float4)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>float4_minmax_ops</literal></entry>
     <entry><literal>= (float4,float4)</literal></entry>
    </row>
    <row><entry><literal>&lt; (float4,float4)</literal></entry></row>
    <row><entry><literal>&gt; (float4,float4)</literal></entry></row>
    <row><entry><literal>&lt;= (float4,float4)</literal></entry></row>
    <row><entry><literal>&gt;= (float4,float4)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>float4_minmax_multi_ops</literal></entry>
     <entry><literal>= (float4,float4)</literal></entry>
    </row>
    <row><entry><literal>&lt; (float4,float4)</literal></entry></row>
    <row><entry><literal>&gt; (float4,float4)</literal></entry></row>
    <row><entry><literal>&lt;= (float4,float4)</literal></entry></row>
    <row><entry><literal>&gt;= (float4,float4)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>float8_bloom_ops</literal></entry>
     <entry><literal>= (float8,float8)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>float8_minmax_ops</literal></entry>
     <entry><literal>= (float8,float8)</literal></entry>
    </row>
    <row><entry><literal>&lt; (float8,float8)</literal></entry></row>
    <row><entry><literal>&lt;= (float8,float8)</literal></entry></row>
    <row><entry><literal>&gt; (float8,float8)</literal></entry></row>
    <row><entry><literal>&gt;= (float8,float8)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>float8_minmax_multi_ops</literal></entry>
     <entry><literal>= (float8,float8)</literal></entry>
    </row>
    <row><entry><literal>&lt; (float8,float8)</literal></entry></row>
    <row><entry><literal>&lt;= (float8,float8)</literal></entry></row>
    <row><entry><literal>&gt; (float8,float8)</literal></entry></row>
    <row><entry><literal>&gt;= (float8,float8)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="5"><literal>inet_inclusion_ops</literal></entry>
     <entry><literal>&lt;&lt; (inet,inet)</literal></entry>
    </row>
    <row><entry><literal>&lt;&lt;= (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt;&gt; (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt;&gt;= (inet,inet)</literal></entry></row>
    <row><entry><literal>= (inet,inet)</literal></entry></row>
    <row><entry><literal>&amp;&amp; (inet,inet)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>inet_bloom_ops</literal></entry>
     <entry><literal>= (inet,inet)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>inet_minmax_ops</literal></entry>
     <entry><literal>= (inet,inet)</literal></entry>
    </row>
    <row><entry><literal>&lt; (inet,inet)</literal></entry></row>
    <row><entry><literal>&lt;= (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt; (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt;= (inet,inet)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>inet_minmax_multi_ops</literal></entry>
     <entry><literal>= (inet,inet)</literal></entry>
    </row>
    <row><entry><literal>&lt; (inet,inet)</literal></entry></row>
    <row><entry><literal>&lt;= (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt; (inet,inet)</literal></entry></row>
    <row><entry><literal>&gt;= (inet,inet)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>int2_bloom_ops</literal></entry>
     <entry><literal>= (int2,int2)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>int2_minmax_ops</literal></entry>
     <entry><literal>= (int2,int2)</literal></entry>
    </row>
    <row><entry><literal>&lt; (int2,int2)</literal></entry></row>
    <row><entry><literal>&gt; (int2,int2)</literal></entry></row>
    <row><entry><literal>&lt;= (int2,int2)</literal></entry></row>
    <row><entry><literal>&gt;= (int2,int2)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>int2_minmax_multi_ops</literal></entry>
     <entry><literal>= (int2,int2)</literal></entry>
    </row>
    <row><entry><literal>&lt; (int2,int2)</literal></entry></row>
    <row><entry><literal>&gt; (int2,int2)</literal></entry></row>
    <row><entry><literal>&lt;= (int2,int2)</literal></entry></row>
    <row><entry><literal>&gt;= (int2,int2)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>int4_bloom_ops</literal></entry>
     <entry><literal>= (int4,int4)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>int4_minmax_ops</literal></entry>
     <entry><literal>= (int4,int4)</literal></entry>
    </row>
    <row><entry><literal>&lt; (int4,int4)</literal></entry></row>
    <row><entry><literal>&gt; (int4,int4)</literal></entry></row>
    <row><entry><literal>&lt;= (int4,int4)</literal></entry></row>
    <row><entry><literal>&gt;= (int4,int4)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>int4_minmax_multi_ops</literal></entry>
     <entry><literal>= (int4,int4)</literal></entry>
    </row>
    <row><entry><literal>&lt; (int4,int4)</literal></entry></row>
    <row><entry><literal>&gt; (int4,int4)</literal></entry></row>
    <row><entry><literal>&lt;= (int4,int4)</literal></entry></row>
    <row><entry><literal>&gt;= (int4,int4)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>int8_bloom_ops</literal></entry>
     <entry><literal>= (bigint,bigint)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>int8_minmax_ops</literal></entry>
     <entry><literal>= (bigint,bigint)</literal></entry>
    </row>
    <row><entry><literal>&lt; (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&gt; (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&lt;= (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&gt;= (bigint,bigint)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>int8_minmax_multi_ops</literal></entry>
     <entry><literal>= (bigint,bigint)</literal></entry>
    </row>
    <row><entry><literal>&lt; (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&gt; (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&lt;= (bigint,bigint)</literal></entry></row>
    <row><entry><literal>&gt;= (bigint,bigint)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>interval_bloom_ops</literal></entry>
     <entry><literal>= (interval,interval)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>interval_minmax_ops</literal></entry>
     <entry><literal>= (interval,interval)</literal></entry>
    </row>
    <row><entry><literal>&lt; (interval,interval)</literal></entry></row>
    <row><entry><literal>&lt;= (interval,interval)</literal></entry></row>
    <row><entry><literal>&gt; (interval,interval)</literal></entry></row>
    <row><entry><literal>&gt;= (interval,interval)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>interval_minmax_multi_ops</literal></entry>
     <entry><literal>= (interval,interval)</literal></entry>
    </row>
    <row><entry><literal>&lt; (interval,interval)</literal></entry></row>
    <row><entry><literal>&lt;= (interval,interval)</literal></entry></row>
    <row><entry><literal>&gt; (interval,interval)</literal></entry></row>
    <row><entry><literal>&gt;= (interval,interval)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>macaddr_bloom_ops</literal></entry>
     <entry><literal>= (macaddr,macaddr)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>macaddr_minmax_ops</literal></entry>
     <entry><literal>= (macaddr,macaddr)</literal></entry>
    </row>
    <row><entry><literal>&lt; (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&lt;= (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&gt; (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&gt;= (macaddr,macaddr)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>macaddr_minmax_multi_ops</literal></entry>
     <entry><literal>= (macaddr,macaddr)</literal></entry>
    </row>
    <row><entry><literal>&lt; (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&lt;= (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&gt; (macaddr,macaddr)</literal></entry></row>
    <row><entry><literal>&gt;= (macaddr,macaddr)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>macaddr8_bloom_ops</literal></entry>
     <entry><literal>= (macaddr8,macaddr8)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>macaddr8_minmax_ops</literal></entry>
     <entry><literal>= (macaddr8,macaddr8)</literal></entry>
    </row>
    <row><entry><literal>&lt; (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&lt;= (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&gt; (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&gt;= (macaddr8,macaddr8)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>macaddr8_minmax_multi_ops</literal></entry>
     <entry><literal>= (macaddr8,macaddr8)</literal></entry>
    </row>
    <row><entry><literal>&lt; (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&lt;= (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&gt; (macaddr8,macaddr8)</literal></entry></row>
    <row><entry><literal>&gt;= (macaddr8,macaddr8)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>name_bloom_ops</literal></entry>
     <entry><literal>= (name,name)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>name_minmax_ops</literal></entry>
     <entry><literal>= (name,name)</literal></entry>
    </row>
    <row><entry><literal>&lt; (name,name)</literal></entry></row>
    <row><entry><literal>&lt;= (name,name)</literal></entry></row>
    <row><entry><literal>&gt; (name,name)</literal></entry></row>
    <row><entry><literal>&gt;= (name,name)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>numeric_bloom_ops</literal></entry>
     <entry><literal>= (numeric,numeric)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>numeric_minmax_ops</literal></entry>
     <entry><literal>= (numeric,numeric)</literal></entry>
    </row>
    <row><entry><literal>&lt; (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&lt;= (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&gt; (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&gt;= (numeric,numeric)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>numeric_minmax_multi_ops</literal></entry>
     <entry><literal>= (numeric,numeric)</literal></entry>
    </row>
    <row><entry><literal>&lt; (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&lt;= (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&gt; (numeric,numeric)</literal></entry></row>
    <row><entry><literal>&gt;= (numeric,numeric)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>oid_bloom_ops</literal></entry>
     <entry><literal>= (oid,oid)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>oid_minmax_ops</literal></entry>
     <entry><literal>= (oid,oid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (oid,oid)</literal></entry></row>
    <row><entry><literal>&gt; (oid,oid)</literal></entry></row>
    <row><entry><literal>&lt;= (oid,oid)</literal></entry></row>
    <row><entry><literal>&gt;= (oid,oid)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>oid_minmax_multi_ops</literal></entry>
     <entry><literal>= (oid,oid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (oid,oid)</literal></entry></row>
    <row><entry><literal>&gt; (oid,oid)</literal></entry></row>
    <row><entry><literal>&lt;= (oid,oid)</literal></entry></row>
    <row><entry><literal>&gt;= (oid,oid)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>pg_lsn_bloom_ops</literal></entry>
     <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>pg_lsn_minmax_ops</literal></entry>
     <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
    </row>
    <row><entry><literal>&lt; (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&gt; (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&lt;= (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&gt;= (pg_lsn,pg_lsn)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>pg_lsn_minmax_multi_ops</literal></entry>
     <entry><literal>= (pg_lsn,pg_lsn)</literal></entry>
    </row>
    <row><entry><literal>&lt; (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&gt; (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&lt;= (pg_lsn,pg_lsn)</literal></entry></row>
    <row><entry><literal>&gt;= (pg_lsn,pg_lsn)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="13"><literal>range_inclusion_ops</literal></entry>
     <entry><literal>= (anyrange,anyrange)</literal></entry>
    </row>
    <row><entry><literal>&lt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&lt;= (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&gt;= (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&gt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&amp;&amp; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>@&gt; (anyrange,anyelement)</literal></entry></row>
    <row><entry><literal>@&gt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&lt;@ (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&lt;&lt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&gt;&gt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&amp;&lt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>&amp;&gt; (anyrange,anyrange)</literal></entry></row>
    <row><entry><literal>-|- (anyrange,anyrange)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>text_bloom_ops</literal></entry>
     <entry><literal>= (text,text)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>text_minmax_ops</literal></entry>
     <entry><literal>= (text,text)</literal></entry>
    </row>
    <row><entry><literal>&lt; (text,text)</literal></entry></row>
    <row><entry><literal>&lt;= (text,text)</literal></entry></row>
    <row><entry><literal>&gt; (text,text)</literal></entry></row>
    <row><entry><literal>&gt;= (text,text)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>tid_bloom_ops</literal></entry>
     <entry><literal>= (tid,tid)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>tid_minmax_ops</literal></entry>
     <entry><literal>= (tid,tid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (tid,tid)</literal></entry></row>
    <row><entry><literal>&gt; (tid,tid)</literal></entry></row>
    <row><entry><literal>&lt;= (tid,tid)</literal></entry></row>
    <row><entry><literal>&gt;= (tid,tid)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>tid_minmax_multi_ops</literal></entry>
     <entry><literal>= (tid,tid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (tid,tid)</literal></entry></row>
    <row><entry><literal>&gt; (tid,tid)</literal></entry></row>
    <row><entry><literal>&lt;= (tid,tid)</literal></entry></row>
    <row><entry><literal>&gt;= (tid,tid)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>timestamp_bloom_ops</literal></entry>
     <entry><literal>= (timestamp,timestamp)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>timestamp_minmax_ops</literal></entry>
     <entry><literal>= (timestamp,timestamp)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&lt;= (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&gt; (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&gt;= (timestamp,timestamp)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>timestamp_minmax_multi_ops</literal></entry>
     <entry><literal>= (timestamp,timestamp)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&lt;= (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&gt; (timestamp,timestamp)</literal></entry></row>
    <row><entry><literal>&gt;= (timestamp,timestamp)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>timestamptz_bloom_ops</literal></entry>
     <entry><literal>= (timestamptz,timestamptz)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>timestamptz_minmax_ops</literal></entry>
     <entry><literal>= (timestamptz,timestamptz)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&lt;= (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&gt; (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&gt;= (timestamptz,timestamptz)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>timestamptz_minmax_multi_ops</literal></entry>
     <entry><literal>= (timestamptz,timestamptz)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&lt;= (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&gt; (timestamptz,timestamptz)</literal></entry></row>
    <row><entry><literal>&gt;= (timestamptz,timestamptz)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>time_bloom_ops</literal></entry>
     <entry><literal>= (time,time)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>time_minmax_ops</literal></entry>
     <entry><literal>= (time,time)</literal></entry>
    </row>
    <row><entry><literal>&lt; (time,time)</literal></entry></row>
    <row><entry><literal>&lt;= (time,time)</literal></entry></row>
    <row><entry><literal>&gt; (time,time)</literal></entry></row>
    <row><entry><literal>&gt;= (time,time)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>time_minmax_multi_ops</literal></entry>
     <entry><literal>= (time,time)</literal></entry>
    </row>
    <row><entry><literal>&lt; (time,time)</literal></entry></row>
    <row><entry><literal>&lt;= (time,time)</literal></entry></row>
    <row><entry><literal>&gt; (time,time)</literal></entry></row>
    <row><entry><literal>&gt;= (time,time)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>timetz_bloom_ops</literal></entry>
     <entry><literal>= (timetz,timetz)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>timetz_minmax_ops</literal></entry>
     <entry><literal>= (timetz,timetz)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&lt;= (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&gt; (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&gt;= (timetz,timetz)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>timetz_minmax_multi_ops</literal></entry>
     <entry><literal>= (timetz,timetz)</literal></entry>
    </row>
    <row><entry><literal>&lt; (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&lt;= (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&gt; (timetz,timetz)</literal></entry></row>
    <row><entry><literal>&gt;= (timetz,timetz)</literal></entry></row>

    <row>
     <entry valign="middle"><literal>uuid_bloom_ops</literal></entry>
     <entry><literal>= (uuid,uuid)</literal></entry>
    </row>

    <row>
     <entry valign="middle" morerows="4"><literal>uuid_minmax_ops</literal></entry>
     <entry><literal>= (uuid,uuid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&gt; (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&lt;= (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&gt;= (uuid,uuid)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>uuid_minmax_multi_ops</literal></entry>
     <entry><literal>= (uuid,uuid)</literal></entry>
    </row>
    <row><entry><literal>&lt; (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&gt; (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&lt;= (uuid,uuid)</literal></entry></row>
    <row><entry><literal>&gt;= (uuid,uuid)</literal></entry></row>

    <row>
     <entry valign="middle" morerows="4"><literal>varbit_minmax_ops</literal></entry>
     <entry><literal>= (varbit,varbit)</literal></entry>
    </row>
    <row><entry><literal>&lt; (varbit,varbit)</literal></entry></row>
    <row><entry><literal>&gt; (varbit,varbit)</literal></entry></row>
    <row><entry><literal>&lt;= (varbit,varbit)</literal></entry></row>
    <row><entry><literal>&gt;= (varbit,varbit)</literal></entry></row>
   </tbody>
  </tgroup>
 </table>

  <sect3 id="brin-builtin-opclasses--parameters">
<!--
   <title>Operator Class Parameters</title>
-->
   <title>演算子クラスパラメータ</title>

   <para>
<!--
    Some of the built-in operator classes allow specifying parameters affecting
    behavior of the operator class.  Each operator class has its own set of
    allowed parameters.  Only the <literal>bloom</literal> and <literal>minmax-multi</literal>
    operator classes allow specifying parameters:
-->
いくつかの組み込み演算子クラスは演算子クラスの振舞いに影響するパラメータを指定できます。
それぞれの演算子クラスで、指定できる独自のパラメータ群があります。
<literal>bloom</literal>演算子クラスと<literal>minmax-multi</literal>演算子クラスのみ特定のパラメータが指定できます。
   </para>

   <para>
<!--
    bloom operator classes accept these parameters:
-->
bloom演算子クラスでは次のパラメータを受け取ります。
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>n_distinct_per_range</literal></term>
    <listitem>
    <para>
<!--
     Defines the estimated number of distinct non-null values in the block
     range, used by <acronym>BRIN</acronym> bloom indexes for sizing of the
     Bloom filter. It behaves similarly to <literal>n_distinct</literal> option
     for <xref linkend="sql-altertable"/>. When set to a positive value,
     each block range is assumed to contain this number of distinct non-null
     values. When set to a negative value, which must be greater than or
     equal to -1, the number of distinct non-null values is assumed to grow linearly with
     the maximum possible number of tuples in the block range (about 290
     rows per block). The default value is <literal>-0.1</literal>, and
     the minimum number of distinct non-null values is <literal>16</literal>.
-->
<acronym>BRIN</acronym>ブルームインデックスでブルームフィルタのサイズ設定に使用される、ブロックレンジ内の重複しない非NULL値の推定数を定義します。
これは、<xref linkend="sql-altertable"/>の<literal>n_distinct</literal>オプションと同様に動作します。
正の値に設定された場合、各ブロックレンジにはこの数の重複しない非NULL値が含まれているとみなされます。
負の値に設定された場合、重複しない非NULL値の数はブロックレンジ内でのタプルの最大数(ブロックあたり約290行)に比例して増加するとみなされ、-1以上である必要があります。
デフォルト値は<literal>-0.1</literal>で、重複しない非NULL値の最小数は<literal>16</literal>です。
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>false_positive_rate</literal></term>
    <listitem>
    <para>
<!--
     Defines the desired false positive rate used by <acronym>BRIN</acronym>
     bloom indexes for sizing of the Bloom filter. The values must be
     between 0.0001 and 0.25. The default value is 0.01, which is 1% false
     positive rate.
-->
ブルームフィルタのサイズ設定のために<acronym>BRIN</acronym>ブルームインデックスによって使用される、必要な偽陽性率を定義します。
値は0.0001から0.25の間でなければなりません。デフォルト値は0.01で、これは1%の偽陽性率です。
    </para>
    </listitem>
   </varlistentry>

   </variablelist>

   <para>
<!--
    minmax-multi operator classes accept these parameters:
-->
minmax-multi演算子クラスでは次のパラメータを受け取ります。
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>values_per_range</literal></term>
    <listitem>
    <para>
<!--
     Defines the maximum number of values stored by <acronym>BRIN</acronym>
     minmax indexes to summarize a block range. Each value may represent
     either a point, or a boundary of an interval. Values must be between
     8 and 256, and the default value is 32.
-->
ブロック範囲を集計するために<acronym>BRIN</acronym> minmaxインデックスによって格納される値の最大数を定義します。
各値は、点または区間の境界として表すこともできます。値は8から256の間である必要があり、デフォルト値は32です。
    </para>
    </listitem>
   </varlistentry>

   </variablelist>
  </sect3>

</sect2>

<sect2 id="brin-extensibility">
<!--
 <title>Extensibility</title>
-->
 <title>拡張性</title>

 <para>
<!--
  The <acronym>BRIN</acronym> interface has a high level of abstraction,
  requiring the access method implementer only to implement the semantics
  of the data type being accessed.  The <acronym>BRIN</acronym> layer
  itself takes care of concurrency, logging and searching the index structure.
-->
<acronym>BRIN</acronym>のインタフェースは高度に抽象化されており、アクセスメソッドを実装する人は、アクセスされるデータ型のセマンティクスを実装するだけで良いようになっています。
<acronym>BRIN</acronym>層は、同時実行性、ログ、インデックス構造の検索を担当します。
 </para>

 <para>
<!--
  All it takes to get a <acronym>BRIN</acronym> access method working is to
  implement a few user-defined methods, which define the behavior of
  summary values stored in the index and the way they interact with
  scan keys.
  In short, <acronym>BRIN</acronym> combines
  extensibility with generality, code reuse, and a clean interface.
-->
<acronym>BRIN</acronym>アクセスメソッドを動作させるために必要なのは、インデックスに格納された要約値の振る舞いと、それらがインデックススキャンする際にどう関係するのかを定義する少数のメソッドを実装することだけです。
つまり、<acronym>BRIN</acronym>は一般性、コードの再利用性、整理されたインタフェースと拡張性を同時に実現しています。
 </para>

 <para>
<!--
  There are four methods that an operator class for <acronym>BRIN</acronym>
  must provide:
-->
<acronym>BRIN</acronym>用の演算子クラスは、4つのメソッドを提供する必要があります。

  <variablelist>
   <varlistentry>
    <term><function>BrinOpcInfo *opcInfo(Oid type_oid)</function></term>
    <listitem>
     <para>
<!--
      Returns internal information about the indexed columns' summary data.
      The return value must point to a palloc'd <structname>BrinOpcInfo</structname>,
      which has this definition:
-->
インデックスが貼られた列の要約データに関する内部情報を返します。
返却値はpallocされた<structname>BrinOpcInfo</structname>へのポインタでなければなりません。
BrinOpcInfoは以下の定義を持ちます。
<programlisting>
typedef struct BrinOpcInfo
{
    /* Number of columns stored in an index column of this opclass */
    uint16      oi_nstored;

    /* Opaque pointer for the opclass' private use */
    void       *oi_opaque;

    /* Type cache entries of the stored columns */
    TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;
</programlisting>
<!--
      <structname>BrinOpcInfo</structname>.<structfield>oi_opaque</structfield> can be used by the
      operator class routines to pass information between support functions
      during an index scan.
-->
<structname>BrinOpcInfo</structname>.<structfield>oi_opaque</structfield>は、演算子クラスのルーチンが、インデックススキャン中にサポート関数同士で情報のやり取りをするために使うことができます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>bool consistent(BrinDesc *bdesc, BrinValues *column,
       ScanKey *keys, int nkeys)</function></term>
    <listitem>
     <para>
<!--
      Returns whether all the ScanKey entries are consistent with the given
      indexed values for a range.
      The attribute number to use is passed as part of the scan key.
      Multiple scan keys for the same attribute may be passed at once; the
      number of entries is determined by the <literal>nkeys</literal> parameter.
-->
ある範囲について、すべてのScanKeyエントリが指定されたインデックス値と一致するかどうかを返します。
使用する属性の数はスキャンキーの一部として渡されます。
同じ属性の複数のスキャンキーを一度に渡すこともできます。
エントリの数は<literal>nkeys</literal>パラメータによって決定されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>bool consistent(BrinDesc *bdesc, BrinValues *column,
       ScanKey key)</function></term>
    <listitem>
     <para>
<!--
      Returns whether the ScanKey is consistent with the given indexed
      values for a range.
      The attribute number to use is passed as part of the scan key.
      This is an older backward-compatible variant of the consistent function.
-->
ScanKeyがある範囲のインデックス値と一致しているかどうかを返します。
属性の数はスキャンキーの一部として渡されます。
これはconsistent関数の古い後方互換のための派生型です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>bool addValue(BrinDesc *bdesc, BrinValues *column,
       Datum newval, bool isnull)</function></term>
    <listitem>
     <para>
<!--
      Given an index tuple and an indexed value, modifies the indicated
      attribute of the tuple so that it additionally represents the new value.
      If any modification was done to the tuple, <literal>true</literal> is
      returned.
-->
追加された新しい値をインデックスが表現できるように、与えられたインデックスタプルとインデックス値にしたがい、タプルの指定アトリビュートを変更します。
タプルの更新が行われれば、<literal>true</literal>が返却されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>bool unionTuples(BrinDesc *bdesc, BrinValues *a,
       BrinValues *b)</function></term>
    <listitem>
     <para>
<!--
      Consolidates two index tuples. Given two index tuples, modifies the
      indicated attribute of the first of them so that it represents both tuples.
      The second tuple is not modified.
-->
2つのインデックスタプルを統合します。
与えられた2つのインデックスタプルのうち、最初のインデックスタプルを変更して、両方のタプルを表現できるようにします。
2番目のタプルは変更されません。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--
  An operator class for <acronym>BRIN</acronym> can optionally specify the
  following method:
-->
省略可能ですが、<acronym>BRIN</acronym>に対する演算子クラスは以下のメソッドを指定できます。

  <variablelist>
    <varlistentry>
     <term><function>void options(local_relopts *relopts)</function></term>
     <listitem>
      <para>
<!--
       Defines a set of user-visible parameters that control operator class
       behavior.
-->
演算子クラスの振舞いを制御するユーザに可視のパラメータの集合を定義します。
      </para>

      <para>
<!--
       The <function>options</function> function is passed a pointer to a
       <structname>local_relopts</structname> struct, which needs to be
       filled with a set of operator class specific options.  The options
       can be accessed from other support functions using the
       <literal>PG_HAS_OPCLASS_OPTIONS()</literal> and
       <literal>PG_GET_OPCLASS_OPTIONS()</literal> macros.
-->
<function>options</function>関数には<structname>local_relopts</structname>構造体へのポインタが渡されますが、構造体を演算子クラスに固有のオプションの集合で満たすことが必要です。
オプションはマクロ<literal>PG_HAS_OPCLASS_OPTIONS()</literal>と<literal>PG_GET_OPCLASS_OPTIONS()</literal>を使って他のサポート関数からアクセスできます。
      </para>

      <para>
<!--
       Since both key extraction of indexed values and representation of the
       key in <acronym>BRIN</acronym> are flexible, they may depend on
       user-specified parameters.
-->
インデックス付けされた値からのキーの抽出にも<acronym>BRIN</acronym>でのキーの表現にも柔軟性がありますので、ユーザに固有のパラメータに依存するかもしれません。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>

<!--
  The core distribution includes support for four types of operator classes:
  minmax, minmax-multi, inclusion and bloom.  Operator class definitions
  using them are shipped for in-core data types as appropriate.  Additional
  operator classes can be defined by the user for other data types using
  equivalent definitions, without having to write any source code;
  appropriate catalog entries being declared is enough.  Note that
  assumptions about the semantics of operator strategies are embedded in the
  support functions' source code.
-->
コア配布物には、4種類の演算子クラスが含まれます。すなわち、minmax、inclusion、minmax-multiとbloomです。
それらを使った演算子クラスの定義がコア配布物に必要に応じて含まれます。
同じ定義を使って、ユーザは他のデータ型のために演算子クラスを定義することができます。
そのためにソースコードを書く必要はありません。適切なシステムカタログの定義があれば十分です。
演算子ストラテジのセマンティクスは、サポート関数のソースコード中に埋め込まれていることに注意してください。
 </para>

 <para>
<!--
  Operator classes that implement completely different semantics are also
  possible, provided implementations of the four main support functions
  described above are written.  Note that backwards compatibility across major
  releases is not guaranteed: for example, additional support functions might
  be required in later releases.
-->
前述の4つの主要なサポート関数を実装することにより、まったく異なるセマンティクスを実装する演算子クラスも可能です。
なお、メジャーリリース間では下位互換性は保証されていません。
たとえば、新しいリリースでは、サポート関数が追加で必要になるかもしれません。
 </para>

 <para>
<!--
  To write an operator class for a data type that implements a totally
  ordered set, it is possible to use the minmax support functions
  alongside the corresponding operators, as shown in
  <xref linkend="brin-extensibility-minmax-table"/>.
  All operator class members (functions and operators) are mandatory.
-->
<xref linkend="brin-extensibility-minmax-table"/>で示すように、全順序集合を実装するデータ型のための演算子クラスを書くために、関連する演算子とともにminmaxサポート関数を使うことができます。
演算子クラスのメンバ(関数と演算子)はすべて必須です。
 </para>

 <table id="brin-extensibility-minmax-table">
<!--
  <title>Function and Support Numbers for Minmax Operator Classes</title>
-->
  <title>Minmax演算子クラスの関数とサポート番号</title>
  <tgroup cols="2">
   <colspec colname="col1" colwidth="1*"/>
   <colspec colname="col2" colwidth="2*"/>
   <thead>
    <row>
<!--
     <entry>Operator class member</entry>
     <entry>Object</entry>
-->
     <entry>演算子クラスメンバ</entry>
     <entry>オブジェクト</entry>
    </row>
   </thead>
   <tbody>
    <row>
<!--
     <entry>Support Function 1</entry>
     <entry>internal function <function>brin_minmax_opcinfo()</function></entry>
-->
     <entry>サポート関数 1</entry>
     <entry>内部関数<function>brin_minmax_opcinfo()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Function 2</entry>
     <entry>internal function <function>brin_minmax_add_value()</function></entry>
-->
     <entry>サポート関数 2</entry>
     <entry>内部関数<function>brin_minmax_add_value()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Function 3</entry>
     <entry>internal function <function>brin_minmax_consistent()</function></entry>
-->
     <entry>サポート関数 3</entry>
     <entry>内部関数<function>brin_minmax_consistent()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Function 4</entry>
     <entry>internal function <function>brin_minmax_union()</function></entry>
-->
     <entry>サポート関数 4</entry>
     <entry>内部関数<function>brin_minmax_union()</function></entry>
    </row>
    <row>
     <entry>Operator Strategy 1</entry>
     <entry>operator less-than</entry>
    </row>
    <row>
     <entry>Operator Strategy 2</entry>
     <entry>operator less-than-or-equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 3</entry>
     <entry>operator equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 4</entry>
     <entry>operator greater-than-or-equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 5</entry>
     <entry>operator greater-than</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
<!--
  To write an operator class for a complex data type which has values
  included within another type, it's possible to use the inclusion support
  functions alongside the corresponding operators, as shown
  in <xref linkend="brin-extensibility-inclusion-table"/>.  It requires
  only a single additional function, which can be written in any language.
  More functions can be defined for additional functionality.  All operators
  are optional.  Some operators require other operators, as shown as
  dependencies on the table.
-->
<xref linkend="brin-extensibility-inclusion-table"/>で示すように、他のデータ型の値を含む複合データ型の演算子クラスを書くには、関連する演算子とともに、inclusionサポート関数を使うことができます。
任意の言語で書かれたたったひとつの関数を追加するだけです。
機能を追加するために関数を追加できます。
すべての演算子はオプションです。
表の中依存性の項目で示されているように、ある種の演算子は他の演算子を必要とすることもあります。
 </para>

 <table id="brin-extensibility-inclusion-table">
<!--
  <title>Function and Support Numbers for Inclusion Operator Classes</title>
-->
  <title>Inclusion演算子クラスの関数とサポート番号</title>
  <tgroup cols="3">
   <colspec colname="col1" colwidth="1*"/>
   <colspec colname="col2" colwidth="2*"/>
   <colspec colname="col3" colwidth="1*"/>
   <thead>
    <row>
<!--
     <entry>Operator class member</entry>
     <entry>Object</entry>
     <entry>Dependency</entry>
-->
     <entry>演算子クラスメンバ</entry>
     <entry>オブジェクト</entry>
     <entry>依存性</entry>
    </row>
   </thead>
   <tbody>
    <row>
<!--
     <entry>Support Function 1</entry>
     <entry>internal function <function>brin_inclusion_opcinfo()</function></entry>
-->
     <entry>サポート関数 1</entry>
     <entry>内部関数<function>brin_inclusion_opcinfo()</function></entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 2</entry>
     <entry>internal function <function>brin_inclusion_add_value()</function></entry>
-->
     <entry>サポート関数 2</entry>
     <entry>内部関数<function>brin_inclusion_add_value()</function></entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 3</entry>
     <entry>internal function <function>brin_inclusion_consistent()</function></entry>
-->
     <entry>サポート関数 3</entry>
     <entry>内部関数<function>brin_inclusion_consistent()</function></entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 4</entry>
     <entry>internal function <function>brin_inclusion_union()</function></entry>
-->
     <entry>サポート関数 4</entry>
     <entry>内部関数<function>brin_inclusion_union()</function></entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 11</entry>
     <entry>function to merge two elements</entry>
-->
     <entry>サポート関数 11</entry>
     <entry>2つの要素をマージする関数</entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 12</entry>
     <entry>optional function to check whether two elements are mergeable</entry>
-->
     <entry>サポート関数 12</entry>
     <entry>2つの要素がマージ可能かどうか確認するオプションの関数</entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 13</entry>
     <entry>optional function to check if an element is contained within another</entry>
-->
     <entry>サポート関数 13</entry>
     <entry>要素が他の要素に含まれるかどうかを確認するオプションの関数</entry>
     <entry></entry>
    </row>
    <row>
<!--
     <entry>Support Function 14</entry>
     <entry>optional function to check whether an element is empty</entry>
-->
     <entry>サポート関数 14</entry>
     <entry>要素が空かどうかを確認するオプションの関数</entry>
     <entry></entry>
    </row>
    <row>
     <entry>Operator Strategy 1</entry>
     <entry>operator left-of</entry>
     <entry>Operator Strategy 4</entry>
    </row>
    <row>
     <entry>Operator Strategy 2</entry>
     <entry>operator does-not-extend-to-the-right-of</entry>
     <entry>Operator Strategy 5</entry>
    </row>
    <row>
     <entry>Operator Strategy 3</entry>
     <entry>operator overlaps</entry>
     <entry></entry>
    </row>
    <row>
     <entry>Operator Strategy 4</entry>
     <entry>operator does-not-extend-to-the-left-of</entry>
     <entry>Operator Strategy 1</entry>
    </row>
    <row>
     <entry>Operator Strategy 5</entry>
     <entry>operator right-of</entry>
     <entry>Operator Strategy 2</entry>
    </row>
    <row>
     <entry>Operator Strategy 6, 18</entry>
     <entry>operator same-as-or-equal-to</entry>
     <entry>Operator Strategy 7</entry>
    </row>
    <row>
     <entry>Operator Strategy 7, 16, 24, 25</entry>
     <entry>operator contains-or-equal-to</entry>
     <entry></entry>
    </row>
    <row>
     <entry>Operator Strategy 8, 26, 27</entry>
     <entry>operator is-contained-by-or-equal-to</entry>
     <entry>Operator Strategy 3</entry>
    </row>
    <row>
     <entry>Operator Strategy 9</entry>
     <entry>operator does-not-extend-above</entry>
     <entry>Operator Strategy 11</entry>
    </row>
    <row>
     <entry>Operator Strategy 10</entry>
     <entry>operator is-below</entry>
     <entry>Operator Strategy 12</entry>
    </row>
    <row>
     <entry>Operator Strategy 11</entry>
     <entry>operator is-above</entry>
     <entry>Operator Strategy 9</entry>
    </row>
    <row>
     <entry>Operator Strategy 12</entry>
     <entry>operator does-not-extend-below</entry>
     <entry>Operator Strategy 10</entry>
    </row>
    <row>
     <entry>Operator Strategy 20</entry>
     <entry>operator less-than</entry>
     <entry>Operator Strategy 5</entry>
    </row>
    <row>
     <entry>Operator Strategy 21</entry>
     <entry>operator less-than-or-equal-to</entry>
     <entry>Operator Strategy 5</entry>
    </row>
    <row>
     <entry>Operator Strategy 22</entry>
     <entry>operator greater-than</entry>
     <entry>Operator Strategy 1</entry>
    </row>
    <row>
     <entry>Operator Strategy 23</entry>
     <entry>operator greater-than-or-equal-to</entry>
     <entry>Operator Strategy 1</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
<!--
    Support function numbers 1 through 10 are reserved for the BRIN internal
    functions, so the SQL level functions start with number 11.  Support
    function number 11 is the main function required to build the index.
    It should accept two arguments with the same data type as the operator class,
    and return the union of them.  The inclusion operator class can store union
    values with different data types if it is defined with the
    <literal>STORAGE</literal> parameter.  The return value of the union
    function should match the <literal>STORAGE</literal> data type.
-->
サポート関数番号1から10は、BRINの内部関数用に予約されており、SQLレベルの関数は番号11から始まります。
サポート関数11は、インデックスを構築するのに必要なメイン関数です。
その関数は演算子クラスと同じデータ型を持つ2つの引数を受け取り、それらの和を返します。
もし<literal>STORAGE</literal>パラメータで定義されていれば、inclusion 演算子クラスは異なるデータ型の和を格納できます。
和関数の返り値は、<literal>STORAGE</literal>データ型と一致していなければなりません。
 </para>

 <para>
<!--
    Support function numbers 12 and 14 are provided to support
    irregularities of built-in data types.  Function number 12
    is used to support network addresses from different families which
    are not mergeable.  Function number 14 is used to support
    empty ranges.  Function number 13 is an optional but
    recommended one, which allows the new value to be checked before
    it is passed to the union function.  As the BRIN framework can shortcut
    some operations when the union is not changed, using this
    function can improve index performance.
-->
サポート関数番号12と14は、組み込みデータ型の例外事象をサポートするために提供されます。
サポート関数番号12は、マージできない異なるファミリーのネットワークアドレスをサポートするために使用されます。
サポート関数番号14は、空のレンジをサポートするために使用されます。
サポート関数番号13はオプションですが、和関数に渡される前に新しい値のチェックを行うためのものとして推奨されます。
BRINフレームワークは和が変化しない時に操作を省略することができるため、この関数を使うことによってインデックスの性能が向上する可能性があります。
 </para>

 <para>
<!--
  To write an operator class for a data type that implements only an equality
  operator and supports hashing, it is possible to use the bloom support procedures
  alongside the corresponding operators, as shown in
  <xref linkend="brin-extensibility-bloom-table"/>.
  All operator class members (procedures and operators) are mandatory.
-->
<xref linkend="brin-extensibility-bloom-table"/>で示すように、等号演算子のみを実装しハッシュをサポートするデータ型の演算子クラスを書くために、関連する演算子とともにbloomがサポートするプロシージャを使うことができます。
演算子クラスのメンバ(プロシージャと演算子)はすべて必須です。
 </para>

 <table id="brin-extensibility-bloom-table">
<!--
  <title>Procedure and Support Numbers for Bloom Operator Classes</title>
-->
  <title>Bloom演算子クラスのプロシージャとサポート番号</title>
  <tgroup cols="2">
   <thead>
    <row>
<!--
     <entry>Operator class member</entry>
     <entry>Object</entry>
-->
     <entry>演算子クラスメンバ</entry>
     <entry>オブジェクト</entry>
    </row>
   </thead>
   <tbody>
    <row>
<!--
     <entry>Support Procedure 1</entry>
     <entry>internal function <function>brin_bloom_opcinfo()</function></entry>
-->
     <entry>サポートプロシージャ 1</entry>
     <entry>内部関数<function>brin_bloom_opcinfo()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 2</entry>
     <entry>internal function <function>brin_bloom_add_value()</function></entry>
-->
     <entry>サポートプロシージャ 2</entry>
     <entry>内部関数<function>brin_bloom_add_value()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 3</entry>
     <entry>internal function <function>brin_bloom_consistent()</function></entry>
-->
     <entry>サポートプロシージャ 3</entry>
     <entry>内部関数<function>brin_bloom_consistent()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 4</entry>
     <entry>internal function <function>brin_bloom_union()</function></entry>
-->
     <entry>サポートプロシージャ 4</entry>
     <entry>内部関数<function>brin_bloom_union()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 5</entry>
     <entry>internal function <function>brin_bloom_options()</function></entry>
-->
     <entry>サポートプロシージャ 5</entry>
     <entry>内部関数<function>brin_bloom_options()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 11</entry>
     <entry>function to compute hash of an element</entry>
-->
     <entry>サポートプロシージャ 11</entry>
     <entry>要素のハッシュを計算する関数</entry>
    </row>
    <row>
     <entry>Operator Strategy 1</entry>
     <entry>operator equal-to</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
<!--
    Support procedure numbers 1-10 are reserved for the BRIN internal
    functions, so the SQL level functions start with number 11.  Support
    function number 11 is the main function required to build the index.
    It should accept one argument with the same data type as the operator class,
    and return a hash of the value.
-->
サポートプロシージャ番号1から10は、BRINの内部関数として予約されており、SQLレベルの関数は11番から始まります。
サポート関数11は、インデックスを構築するのに必要なメイン関数です。
演算子クラスと同じデータ型の引数を1つ受け取り、その値のハッシュを返す必要があります。
 </para>

 <para>
<!--
  The minmax-multi operator class is also intended for data types implementing
  a totally ordered set, and may be seen as a simple extension of the minmax
  operator class. While minmax operator class summarizes values from each block
  range into a single contiguous interval, minmax-multi allows summarization
  into multiple smaller intervals to improve handling of outlier values.
  It is possible to use the minmax-multi support procedures alongside the
  corresponding operators, as shown in
  <xref linkend="brin-extensibility-minmax-multi-table"/>.
  All operator class members (procedures and operators) are mandatory.
-->
minmax-multi演算子クラスもまた、全順序集合を実装するデータ型を対象としており、minmax演算子クラスの単純な拡張と見なすことができます。
minmax演算子クラスは各ブロックの範囲を一つの連続した区間にまとめますが、minmax-multiはより小さな複数の区間にまとめることで、外れ値の扱いを改善します。
<xref linkend="brin-extensibility-minmax-multi-table"/>で示すように、関連する演算子とともにminmax-multiがサポートするプロシージャを使うことができます。
演算子クラスのメンバ(プロシージャと演算子)はすべて必須です。
 </para>

 <table id="brin-extensibility-minmax-multi-table">
<!--
  <title>Procedure and Support Numbers for minmax-multi Operator Classes</title>
-->
  <title>minmax-multi演算子クラスのプロシージャとサポート番号</title>
  <tgroup cols="2">
   <thead>
    <row>
<!--
     <entry>Operator class member</entry>
     <entry>Object</entry>
-->
     <entry>演算子クラスメンバ</entry>
     <entry>オブジェクト</entry>
    </row>
   </thead>
   <tbody>
    <row>
<!--
     <entry>Support Procedure 1</entry>
     <entry>internal function <function>brin_minmax_multi_opcinfo()</function></entry>
-->
     <entry>サポートプロシージャ 1</entry>
     <entry>内部関数<function>brin_minmax_multi_opcinfo()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 2</entry>
     <entry>internal function <function>brin_minmax_multi_add_value()</function></entry>
-->
     <entry>サポートプロシージャ 2</entry>
     <entry>内部関数<function>brin_minmax_multi_add_value()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 3</entry>
     <entry>internal function <function>brin_minmax_multi_consistent()</function></entry>
-->
     <entry>サポートプロシージャ 3</entry>
     <entry>内部関数<function>brin_minmax_multi_consistent()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 4</entry>
     <entry>internal function <function>brin_minmax_multi_union()</function></entry>
-->
     <entry>サポートプロシージャ 4</entry>
     <entry>内部関数<function>brin_minmax_multi_union()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 5</entry>
     <entry>internal function <function>brin_minmax_multi_options()</function></entry>
-->
     <entry>サポートプロシージャ 5</entry>
     <entry>内部関数<function>brin_minmax_multi_options()</function></entry>
    </row>
    <row>
<!--
     <entry>Support Procedure 11</entry>
     <entry>function to compute distance between two values (length of a range)</entry>
-->
     <entry>サポートプロシージャ 11</entry>
     <entry>2つの値の間の距離(範囲の長さ)を計算する関数</entry>
    </row>
    <row>
     <entry>Operator Strategy 1</entry>
     <entry>operator less-than</entry>
    </row>
    <row>
     <entry>Operator Strategy 2</entry>
     <entry>operator less-than-or-equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 3</entry>
     <entry>operator equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 4</entry>
     <entry>operator greater-than-or-equal-to</entry>
    </row>
    <row>
     <entry>Operator Strategy 5</entry>
     <entry>operator greater-than</entry>
    </row>
   </tbody>
  </tgroup>
 </table>

 <para>
<!--
    Both minmax and inclusion operator classes support cross-data-type
    operators, though with these the dependencies become more complicated.
    The minmax operator class requires a full set of operators to be
    defined with both arguments having the same data type.  It allows
    additional data types to be supported by defining extra sets
    of operators.  Inclusion operator class operator strategies are dependent
    on another operator strategy as shown in
    <xref linkend="brin-extensibility-inclusion-table"/>, or the same
    operator strategy as themselves.  They require the dependency
    operator to be defined with the <literal>STORAGE</literal> data type as the
    left-hand-side argument and the other supported data type to be the
    right-hand-side argument of the supported operator.  See
    <literal>float4_minmax_ops</literal> as an example of minmax, and
    <literal>box_inclusion_ops</literal> as an example of inclusion.
-->
minmaxとinclusion演算子クラスは、データ型をまたがる演算子をサポートします。
しかし、これらを使用すると依存関係はより複雑になります。
minmax演算子クラスは、両方の引数がデータ型が同じ型である完全な演算子のセットが必要になります。
追加の演算子の組を定義することにより、追加のデータ型をサポートすることができます。
<xref linkend="brin-extensibility-inclusion-table"/>で示すように、inclusion演算子クラスのストラテジは、他の演算子クラスのストラテジに依存するか、自分自身の演算子クラスのストラテジに依存します。
演算子クラスは、依存演算子が<literal>STORAGE</literal>データ型とともにサポートするデータ型の左辺引数、他のサポートするデータ型をサポートする演算子の右辺引数として定義される必要があります。
minmaxの例として<literal>float4_minmax_ops</literal>、inclusionの例として<literal>box_inclusion_ops</literal>を参照してください。
 </para>
</sect2>
</sect1>
