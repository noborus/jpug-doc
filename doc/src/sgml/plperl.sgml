<!-- doc/src/sgml/plperl.sgml -->

 <chapter id="plperl">
<!--
  <title>PL/Perl &mdash; Perl Procedural Language</title>
-->
  <title>PL/Perl &mdash; Perl手続き言語</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <para>
<!--
   PL/Perl is a loadable procedural language that enables you to write
   <productname>PostgreSQL</productname> functions and procedures in the
   <ulink url="https://www.perl.org">Perl programming language</ulink>.
-->
PL/Perlは<ulink url="https://www.perl.org">Perlプログラミング言語</ulink>を使用して<productname>PostgreSQL</productname>関数とプロシージャを作成することができる、ロード可能な手続き言語です。
  </para>

  <para>
<!--
   The main advantage to using PL/Perl is that this allows use,
   within stored functions and procedures, of the manyfold <quote>string
   munging</quote> operators and functions available for Perl.  Parsing
   complex strings might be easier using Perl than it is with the
   string functions and control structures provided in PL/pgSQL.
-->
PL/Perlを使用する主たる利点は、ストアド関数やプロシージャの中で、Perlで使用可能なさまざまな<quote>文字列操作</quote>や関数を使用できるという点です。
複雑な文字列解析は、PL/pgSQLで提供される文字列関数や制御構造体を使用するよりPerlを使用する方が簡単に行うことができます。
  </para>

  <para>
<!--
   To install PL/Perl in a particular database, use
   <literal>CREATE EXTENSION plperl</literal>.
-->
PL/Perlを特定のデータベースにインストールするには、<literal>CREATE EXTENSION plperl</literal>を使用してください。
  </para>

  <tip>
   <para>
<!--
    If a language is installed into <literal>template1</literal>, all subsequently
    created databases will have the language installed automatically.
-->
言語を<literal>template1</literal>にインストールすると、その後に作成されるデータベース全てにその言語は自動的にインストールされます。
   </para>
  </tip>

  <note>
   <para>
<!--
    Users of source packages must specially enable the build of
    PL/Perl during the installation process.  (Refer to <xref
    linkend="installation"/> for more information.)  Users of
    binary packages might find PL/Perl in a separate subpackage.
-->
ソースパッケージを使用するユーザは、インストール作業時にPL/Perlを特別に使用可能にする必要があります。
（詳細については、<xref linkend="installation"/>を参照してください。）
バイナリパッケージを使用する場合は、別個のサブパッケージにPL/Perlが入っている可能性があります。
   </para>
  </note>

 <sect1 id="plperl-funcs">
<!--
  <title>PL/Perl Functions and Arguments</title>
-->
<title>PL/Perl関数と引数</title>

  <para>
<!--
   To create a function in the PL/Perl language, use the standard
   <xref linkend="sql-createfunction"/>
   syntax:

-->
PL/Perl言語で関数を作成するには、以下の標準的な<xref linkend="sql-createfunction"/>構文を使用してください。
<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable>
<!--
&#45;- function attributes can go here
-->
-- 関数の属性はここに来る
AS $$
<!--
    # PL/Perl function body goes here
-->
    # PL/Perl関数本体はここに来る
$$ LANGUAGE plperl;
</programlisting>

<!--
   The body of the function is ordinary Perl code. In fact, the PL/Perl
   glue code wraps it inside a Perl subroutine.  A PL/Perl function is
   called in a scalar context, so it can't return a list.  You can return
   non-scalar values (arrays, records, and sets) by returning a reference,
   as discussed below.
-->
関数本体は通常のPerlのコードです。
実際、PL/Perlの糊付けコードは、これをPerlのサブルーチンの内部に格納します。
PL/Perl関数はスカラコンテキストとして呼び出されます。このためリストを返すことはできません。
後述の通り、参照を返すことによりスカラ以外の値（配列、レコード、集合）を返すことができます。
  </para>

  <para>
<!--
   In a PL/Perl procedure, any return value from the Perl code is ignored.
-->
PL/Perlプロシージャでは、Perlコードからのあらゆる戻り値は無視されます。
  </para>

  <para>
<!--
   PL/Perl also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:
-->
またPL/Perlは<xref linkend="sql-do"/>文で呼び出される匿名コードブロックをサポートします。

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

<!--
   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
-->
匿名コードブロックは引数を取りません。
また何らかの値を返したとしても破棄されます。
その他は関数と同様に動作します。
  </para>

  <note>
   <para>
<!--
    The use of named nested subroutines is dangerous in Perl, especially if
    they refer to lexical variables in the enclosing scope. Because a PL/Perl
    function is wrapped in a subroutine, any named subroutine you place inside
    one will be nested. In general, it is far safer to create anonymous
    subroutines which you call via a coderef. For more information, see the
    entries for <literal>Variable "%s" will not stay shared</literal> and
    <literal>Variable "%s" is not available</literal> in the
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man page, or
    search the Internet for <quote>perl nested named subroutine</quote>.
-->
Perl、特にその閉ざされたスコープで局所変数を参照するような場合では、名前付きの入れ子状サブルーチンの使用は危険です。
PL/Perl関数はサブルーチン内に格納されますので、内部に記述した名前付きのサブルーチンはすべて入れ子にされます。
一般的に、コード参照を介して呼び出す匿名サブルーチンを作成する方がかなり安全です。
詳細は<citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>マニュアルページ内の<literal>Variable "%s" will not stay shared</literal>および<literal>Variable "%s" is not available</literal>を参照してください。
またはインターネットで<quote>perl nested named subroutine</quote>を検索してください。
   </para>
  </note>

  <para>
<!--
   The syntax of the <command>CREATE FUNCTION</command> command requires
   the function body to be written as a string constant.  It is usually
   most convenient to use dollar quoting (see <xref
   linkend="sql-syntax-dollar-quoting"/>) for the string constant.
   If you choose to use escape string syntax <literal>E''</literal>,
   you must double any single quote marks (<literal>'</literal>) and backslashes
   (<literal>\</literal>) used in the body of the function
   (see <xref linkend="sql-syntax-strings"/>).
-->
<command>CREATE FUNCTION</command>コマンドの構文では、関数本体は文字列定数として記述されることを必須としています。
通常、文字列定数にはドル引用符付け（<xref linkend="sql-syntax-dollar-quoting"/>を参照）を使用することが最も便利です。
エスケープ文字列構文<literal>E''</literal>を使用することを選択した場合、関数本体で使用される単一引用符（<literal>'</literal>）とバックスラッシュ（<literal>\</literal>）をすべて二重にしなければなりません（<xref linkend="sql-syntax-strings"/>を参照）。
  </para>

  <para>
<!--
   Arguments and results are handled as in any other Perl subroutine:
   arguments are passed in <varname>@_</varname>, and a result value
   is returned with <literal>return</literal> or as the last expression
   evaluated in the function.
-->
引数と結果は他のPerlサブルーチンと同様に扱われます。
引数は<varname>@_</varname>の中に渡され、結果値は<literal>return</literal>、または、その関数で最後に評価された式として返されます。
  </para>

  <para>
<!--
   For example, a function returning the greater of two integer values
   could be defined as:
-->
例えば、2つの整数のうち大きな方を返す関数は以下のように定義できます。

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <note>
    <para>
<!--
      Arguments will be converted from the database's encoding to UTF-8
      for use inside PL/Perl, and then converted from UTF-8 back to the
      database encoding upon return.
-->
PL/Perl内部での使用のため、引数はデータベースの符号化方式からUTF-8に変換され、返されるときにUTF-8からデータベースの符号化方式に戻されます。
    </para>
  </note>

  <para>
<!--
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Perl">in PL/Perl</secondary></indexterm> is passed to a function,
   the argument value will appear as <quote>undefined</quote> in Perl.  The
   above function definition will not behave very nicely with null
   inputs (in fact, it will act as though they are zeroes).  We could
   add <literal>STRICT</literal> to the function definition to make
   <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically.  Alternatively,
   we could check for undefined inputs in the function body.  For
   example, suppose that we wanted <function>perl_max</function> with
   one null and one nonnull argument to return the nonnull argument,
   rather than a null value:
-->
SQLのNULL値が関数に渡された場合、その引数値はPerlにおける<quote>未定義</quote>として現れます。
<indexterm><primary>NULL値</primary><secondary sortas="PL/Perl">PL/Perlにおける</secondary></indexterm>
上の関数定義では、NULL値が入力された場合うまく動作しないでしょう（実際はそれがゼロであるかのように動作するでしょう）。
<literal>STRICT</literal>を関数定義に加えることで、<productname>PostgreSQL</productname>の動作をより合理的にすることができます。
NULL値が渡された場合、関数はまったく呼び出されず、単にNULLという結果が自動的に返されます。
他の方法として、関数本体で未定義な入力を検査することもできます。
例えば、<function>perl_max</function>の引数の片方がNULL、もう片方が非NULLの場合に、NULL値ではなく非NULLの引数を返すようにするとします。

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
<!--
   As shown above, to return an SQL null value from a PL/Perl
   function, return an undefined value.  This can be done whether the
   function is strict or not.
-->
上で示した通り、PL/Perl関数からSQLのNULL値を返すためには、未定義値を返すようにしてください。
これは、関数が厳密かどうかに関係なく、実行することができます。
  </para>

  <para>
<!--
   Anything in a function argument that is not a reference is
   a string, which is in the standard <productname>PostgreSQL</productname>
   external text representation for the relevant data type. In the case of
   ordinary numeric or text types, Perl will just do the right thing and
   the programmer will normally not have to worry about it. However, in
   other cases the argument will need to be converted into a form that is
   more usable in Perl. For example, the <function>decode_bytea</function>
   function can be used to convert an argument of
   type <type>bytea</type> into unescaped binary.
-->
関数引数の内で参照ではないものは、対応するデータ型向けの<productname>PostgreSQL</productname>の標準的な外部テキスト表現で表された文字列です。
通常の数値やテキスト型では、Perlは正確に処理を行いますので、通常プログラマは心配することはありません。
しかし、この他の場合では、引数をPerlでより使用しやすいように変換する必要があります。
例えば、<function>decode_bytea</function>関数は<type>bytea</type>型の引数をエスケープしないバイナリに変換するために使用することができます。
  </para>

  <para>
<!--
   Similarly, values passed back to <productname>PostgreSQL</productname>
   must be in the external text representation format. For example, the
   <function>encode_bytea</function> function can be used to
   escape binary data for a return value of type <type>bytea</type>.
-->
同様に、<productname>PostgreSQL</productname>に戻される値を外部テキスト表現書式で表さなければなりません。
例えば、<type>bytea</type>型の戻り値をバイナリデータにエスケープするために<function>encode_bytea</function>を使用することができます。
  </para>

  <para>
<!--
   One case that is particularly important is boolean values.  As just
   stated, the default behavior for <type>bool</type> values is that they
   are passed to Perl as text, thus either <literal>'t'</literal>
   or <literal>'f'</literal>.  This is problematic, since Perl will not
   treat <literal>'f'</literal> as false!  It is possible to improve matters
   by using a <quote>transform</quote> (see
   <xref linkend="sql-createtransform"/>).  Suitable transforms are provided
   by the <filename>bool_plperl</filename> extension.  To use it, install
   the extension:
-->
特に重要な場合の1つは真偽値です。
つい先ほど述べたように、<type>bool</type>値のデフォルトの振舞いはPerlにテキストとして、すなわち<literal>'t'</literal>または<literal>'f'</literal>で渡されるというものです。
Perlは<literal>'f'</literal>を偽とは扱いませんので、これは問題をはらんでいます。
<quote>変換</quote>(<xref linkend="sql-createtransform"/>を参照してください)を使って問題を改善することができます。
適切な変換が<filename>bool_plperl</filename>拡張で提供されています。
使うには、拡張をインストールします。
<programlisting>
<!--
CREATE EXTENSION bool_plperl;  &#45;- or bool_plperlu for PL/PerlU
-->
CREATE EXTENSION bool_plperl;  -- PL/PerlUに対してはbool_plperlu
</programlisting>
<!--
   Then use the <literal>TRANSFORM</literal> function attribute for a
   PL/Perl function that takes or returns <type>bool</type>, for example:
-->
次に<type>bool</type>を受け取ったり返したりするPL/Perl関数に対して<literal>TRANSFORM</literal>関数属性を使います。例えば以下の通りです。
<programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
</programlisting>
<!--
   When this transform is applied, <type>bool</type> arguments will be seen
   by Perl as being <literal>1</literal> or empty, thus properly true or
   false.  If the function result is type <type>bool</type>, it will be true
   or false according to whether Perl would evaluate the returned value as
   true.
   Similar transformations are also performed for boolean query arguments
   and results of SPI queries performed inside the function
   (<xref linkend="plperl-database"/>).
-->
この変換が適用されると、<type>bool</type>引数はPerlからは<literal>1</literal>もしくは空、すなわち正しく真または偽と見えます。
関数の結果が型<type>bool</type>なら、Perlが戻り値を真と評価したかどうかに従って真または偽となります。
同様の変換は、関数の内部で行われる真偽値の問い合わせ引数やSPI問い合わせの結果(<xref linkend="plperl-database"/>)でも実行されます。
  </para>

  <para>
<!--
   Perl can return <productname>PostgreSQL</productname> arrays as
   references to Perl arrays.  Here is an example:
-->
Perlは、<productname>PostgreSQL</productname>の配列をPerl配列への参照として返すことができます。
以下に例を示します。

<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>

  <para>
<!--
   Perl passes <productname>PostgreSQL</productname> arrays as a blessed
   <type>PostgreSQL::InServer::ARRAY</type> object. This object may be treated as an array
   reference or a string, allowing for backward compatibility with Perl
   code written for <productname>PostgreSQL</productname> versions below 9.1 to
   run.  For example:
-->
Perlは<productname>PostgreSQL</productname>の配列をblessされた<type>PostgreSQL::InServer::ARRAY</type>オブジェクトとして渡します。
9.1より過去の<productname>PostgreSQL</productname>で作成されたPerlコードを実行させるための後方互換性のため、このオブジェクトは配列への参照または文字列として扱うことができます。
以下に例を示します。

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

<!--
    # as an array reference
-->
    # 配列への参照として
    for (@$arg) {
        $result .= $_;
    }

<!--
    # also works as a string
-->
    # 文字列としても働く
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
<!--
    Multidimensional arrays are represented as references to
    lower-dimensional arrays of references in a way common to every Perl
    programmer.
-->
Perlプログラマの常識のように、多次元配列は低次元配列の参照への参照として表現されます。
   </para>
  </note>
  </para>

  <para>
<!--
   Composite-type arguments are passed to the function as references
   to hashes.  The keys of the hash are the attribute names of the
   composite type.  Here is an example:
-->
複合型の引数はハッシュへの参照として関数に渡されます。
ハッシュのキーは複合型の属性名です。
以下に例を示します。

<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>

  <para>
<!--
   A PL/Perl function can return a composite-type result using the same
   approach: return a reference to a hash that has the required attributes.
   For example:
-->
必要な属性を持つハッシュの参照を返すという同じ方法で、PL/Perl関数は複合型の結果を返すことができます。
以下に例を示します。

<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>

<!--
   Any columns in the declared result data type that are not present in the
   hash will be returned as null values.
-->
宣言された結果データ型の任意の列の内、ハッシュ内に存在しないものはNULL値として返されます。
  </para>

  <para>
<!--
   Similarly, output arguments of procedures can be returned as a hash
   reference:
-->
同様に、プロシージャの出力引数はハッシュ参照で返すことができます。

<programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
</programlisting>
  </para>

  <para>
<!--
    PL/Perl functions can also return sets of either scalar or
    composite types.  Usually you'll want to return rows one at a
    time, both to speed up startup time and to keep from queuing up
    the entire result set in memory.  You can do this with
    <function>return_next</function> as illustrated below.  Note that
    after the last <function>return_next</function>, you must put
    either <literal>return</literal> or (better) <literal>return
    undef</literal>.
-->
また、PL/Perl関数はスカラ型の配列や複合型の配列を返すこともできます。
通常ならば、起動処理の高速化とメモリ内の結果セット全体を待ち行列に保持できることから、1度に1行を返す方がよいでしょう。
以下に示す<function>return_next</function>を使用して、これを行うことができます。
最後の<function>return_next</function>の後で、<literal>return</literal>または<literal>return undef</literal>（推奨）を記述しなければならないことに注意してください。

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

<!--
    For small result sets, you can return a reference to an array that
    contains either scalars, references to arrays, or references to
    hashes for simple types, array types, and composite types,
    respectively.  Here are some simple examples of returning the entire
    result set as an array reference:
-->
小規模な結果セットでは、それぞれ単純な型、配列型、複合型に対応する、スカラ、配列への参照、ハッシュへの参照を含む配列への参照を返すことができます。
以下に、配列への参照として結果セット全体を返す単純な例をいくつか示します。

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>

  <para>
<!--
   If you wish to use the <literal>strict</literal> pragma with your code you
   have a few options. For temporary global use you can <command>SET</command>
   <literal>plperl.use_strict</literal> to true.
   This will affect subsequent compilations of <application>PL/Perl</application>
   functions, but not functions already compiled in the current session.
   For permanent global use you can set <literal>plperl.use_strict</literal>
   to true in the <filename>postgresql.conf</filename> file.
-->
コード内で<literal>strict</literal>プラグマを使用したいのであればいくつか選択肢があります。
一時的に大域的に使用するために、<command>SET</command> <literal>plperl.use_strict</literal>を真にすることができます。
このパラメータは、その後の<application>PL/Perl</application>関数のコンパイルに影響しますが、現在のセッションでコンパイル済みの関数には影響しません。
永続的に大域的に使用するためには、<filename>postgresql.conf</filename>ファイル内で<literal>plperl.use_strict</literal>を真に設定します。
  </para>

  <para>
<!--
   For permanent use in specific functions you can simply put:
-->
特定の関数で永続的に使用するためには単純に以下を関数本体の先頭に記載してください。
<programlisting>
use strict;
</programlisting>
<!--
   at the top of the function body.
-->
  </para>

  <para>
<!--
  The <literal>feature</literal> pragma is also available to <function>use</function> if your Perl is version 5.10.0 or higher.
-->
また、Perlのバージョンが5.10.0以上であれば<function>use</function>で<literal>feature</literal>プラグマが利用可能です。
  </para>

 </sect1>

 <sect1 id="plperl-data">
<!--
  <title>Data Values in PL/Perl</title>
-->
  <title>PL/Perlにおけるデータ値</title>

  <para>
<!--
   The argument values supplied to a PL/Perl function's code are
   simply the input arguments converted to text form (just as if they
   had been displayed by a <command>SELECT</command> statement).
   Conversely, the <function>return</function> and <function>return_next</function>
   commands will accept any string that is acceptable input format
   for the function's declared return type.
-->
PL/Perl関数のコードに渡される引数値は、単に(<command>SELECT</command>文で表示される場合と同様の)テキスト形式に変換された入力引数です。
反対に<function>return</function>および<function>return_next</function>コマンドは、関数の宣言された戻り値の型で受け付け可能な入力書式で表された任意の文字列を受け付けます。
  </para>

  <para>
<!--
   If this behavior is inconvenient for a particular case, it can be
   improved by using a transform, as already illustrated
   for <type>bool</type> values.  Several examples of transform modules
   are included in the <productname>PostgreSQL</productname> distribution.
-->
この動作が特定の場合には不都合であるなら、前に<type>bool</type>値の例で説明したように、変換を使って改善できます。
変換モジュールの例がいくつか<productname>PostgreSQL</productname>の配布物に含まれています。
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
<!--
  <title>Built-in Functions</title>
-->
  <title>組み込み関数</title>

 <sect2 id="plperl-database">
<!--
  <title>Database Access from PL/Perl</title>
-->
<title>PL/Perlからのデータベースアクセス</title>

  <para>
<!--
   Access to the database itself from your Perl function can be done
   via the following functions:
-->
Perl関数からデータベースそのものにアクセスするには以下の関数で行います。
  </para>

   <variablelist>
    <varlistentry>
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       <literal>spi_exec_query</literal> executes an SQL command and
returns the entire row set as a reference to an array of hash
references.  <emphasis>You should only use this command when you know
that the result set will be relatively small.</emphasis>  Here is an
example of a query (<command>SELECT</command> command) with the
optional maximum number of rows:
-->
<literal>spi_exec_query</literal>はSQLコマンドを実行し、行セット全体をハッシュへの参照を要素とする配列への参照として返します。
<emphasis>結果が相対的に小規模であることが分かっている場合にのみこのコマンドを使用してください。</emphasis>
以下に最大行数オプションを持った問い合わせ（<command>SELECT</command>コマンド）の例を示します。

<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
<!--
        This returns up to 5 rows from the table
        <literal>my_table</literal>.  If <literal>my_table</literal>
        has a column <literal>my_column</literal>, you can get that
        value from row <literal>$i</literal> of the result like this:
-->
これは<literal>my_table</literal>テーブルから5行までを返します。
<literal>my_table</literal>に<literal>my_column</literal>列がある場合、結果の第<literal>$i</literal>行の列値を以下のように取り出すことができます。
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
<!--
       The total number of rows returned from a <command>SELECT</command>
       query can be accessed like this:
-->
<command>SELECT</command>問い合わせから返される行の総数は以下のようにアクセスできます。
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>

      <para>
<!--
       Here is an example using a different command type:
-->
以下は他の種類のコマンドを使用する例です。
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
<!--
       You can then access the command status (e.g.,
       <literal>SPI_OK_INSERT</literal>) like this:
-->
この後、以下のようにコマンドステータス（例えば<literal>SPI_OK_INSERT</literal>）にアクセスすることができます。
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
<!--
       To get the number of rows affected, do:
-->
影響を受けた行数を取り出すには以下を行います。
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>

      <para>
<!--
       Here is a complete example:
-->
以下に複雑な例を示します。
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>

    <listitem>
    <para>
<!--
    <literal>spi_query</literal> and <literal>spi_fetchrow</literal>
    work together as a pair for row sets which might be large, or for cases
    where you wish to return rows as they arrive.
    <literal>spi_fetchrow</literal> works <emphasis>only</emphasis> with
    <literal>spi_query</literal>. The following example illustrates how
    you use them together:
-->
<literal>spi_query</literal>および<literal>spi_fetchrow</literal>は、大規模になる可能性がある行セット用、または、行を順番通りに返したい場合向けに組み合わせて動作します。
<literal>spi_fetchrow</literal>は<literal>spi_query</literal>と一緒で<emphasis>なければ</emphasis>動作しません。
組み合わせて使用する方法について、以下の例で示します。

<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

    <para>
<!--
     Normally, <function>spi_fetchrow</function> should be repeated until it
     returns <literal>undef</literal>, indicating that there are no more
     rows to read.  The cursor returned by <literal>spi_query</literal>
     is automatically freed when
     <function>spi_fetchrow</function> returns <literal>undef</literal>.
     If you do not wish to read all the rows, instead call
     <function>spi_cursor_close</function> to free the cursor.
     Failure to do so will result in memory leaks.
-->
通常<function>spi_fetchrow</function>は、読み取る行がなくなったことを示す<literal>undef</literal>が返されるまで繰り返されるはずです。
<function>spi_fetchrow</function>が<literal>undef</literal>を返すと<literal>spi_query</literal>で返されるカーソルは自動的に解放されます。
すべての行を読み取りたくない場合は代わりに<function>spi_cursor_close</function>を呼び出してカーソルを解放してください。
これに失敗するとメモリリークという結果になります。
    </para>

    </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>

    <listitem>
    <para>
<!--
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>,
    and <literal>spi_freeplan</literal> implement the same functionality but for prepared queries.
    <literal>spi_prepare</literal> accepts a query string with numbered argument placeholders ($1, $2, etc.)
    and a string list of argument types:
-->
<literal>spi_prepare</literal>、<literal>spi_query_prepared</literal>、<literal>spi_exec_prepared</literal>、<literal>spi_freeplan</literal>は、プリペアド問い合わせ用に同様の機能を実装します。
<literal>spi_prepare</literal>は番号付き引数プレースホルダ($1、$2など)を持つ問い合わせ文字列と引数の型を表す文字列リストを受け付けます。
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
<!--
    Once a query plan is prepared by a call to <literal>spi_prepare</literal>, the plan can be used instead
    of the string query, either in <literal>spi_exec_prepared</literal>, where the result is the same as returned
    by <literal>spi_exec_query</literal>, or in <literal>spi_query_prepared</literal> which returns a cursor
    exactly as <literal>spi_query</literal> does, which can be later passed to <literal>spi_fetchrow</literal>.
    The optional second parameter to <literal>spi_exec_prepared</literal> is a hash reference of attributes;
    the only attribute currently supported is <literal>limit</literal>, which sets the maximum number of rows returned by a query.
-->
<literal>spi_prepare</literal>を呼び出すことで問い合わせ計画が準備されると、<literal>spi_exec_query</literal>により返されるものと同様の結果となる<literal>spi_exec_prepared</literal>や<literal>spi_query</literal>とまったく同じカーソルが返される<literal>spi_query_prepared</literal>(このカーソルは後で<literal>spi_fetchrow</literal>に渡すことができます)の中で、その計画を問い合わせ文字列の代わりに使用することができます。
<literal>spi_exec_prepared</literal>の省略可能な第二パラメータは属性のハッシュ参照です。
現在サポートされる唯一の属性は、問い合わせで返される最大行数を設定する<literal>limit</literal>です。
    </para>

    <para>
<!--
    The advantage of prepared queries is that is it possible to use one prepared plan for more
    than one query execution. After the plan is not needed anymore, it can be freed with
    <literal>spi_freeplan</literal>:
-->
プリペアド問い合わせの利点は、1つの準備された計画を複数回使用して問い合わせを実行することができるという点です。
計画が不要になった後、<literal>spi_freeplan</literal>を使用して、計画を解放することができます。
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
<!--
    Note that the parameter subscript in <literal>spi_prepare</literal> is defined via
    $1, $2, $3, etc., so avoid declaring query strings in double quotes that might easily
    lead to hard-to-catch bugs.
-->
<literal>spi_prepare</literal>内のパラメータ添字が$1、$2、$3などを介して定義されることに注意してください。
そのため、検出困難な不具合が簡単に発生することになる二重引用符内での問い合わせ文字列宣言はやめてください。
    </para>

    <para>
<!--
    Another example illustrates usage of an optional parameter in <literal>spi_exec_prepared</literal>:
-->
他の例は、<literal>spi_exec_prepared</literal>における省略可能なパラメータの使用について示しています。
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Commit or roll back the current transaction.  This can only be called
       in a procedure or anonymous code block (<command>DO</command> command)
       called from the top level.  (Note that it is not possible to run the
       SQL commands <command>COMMIT</command> or <command>ROLLBACK</command>
       via <function>spi_exec_query</function> or similar.  It has to be done
       using these functions.)  After a transaction is ended, a new
       transaction is automatically started, so there is no separate function
       for that.
-->
現在のトランザクションをコミットあるいはロールバックします。
これはプロシージャ、あるいはトップレベルから呼ばれた無名コードブロック（<command>DO</command>コマンド）の中からのみ呼び出すことができます。
（SQLコマンドの<command>COMMIT</command>や<command>ROLLBACK</command>を<function>spi_exec_query</function>などを通して実行することはできない点に注意してください。前述の関数を使って行う必要があります。）
トランザクションが終了した後、新たなトランザクションが自動的に開始されますので、開始するための別途の関数はありません。
      </para>

      <para>
<!--
       Here is an example:
-->
以下に例を示します。
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
<!--
  <title>Utility Functions in PL/Perl</title>
-->
  <title>PL/Perlのユーティリティ関数</title>

   <variablelist>
    <varlistentry>
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>elog</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Emit a log or error message. Possible levels are
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>ERROR</literal>.
       <literal>ERROR</literal>
        raises an error condition; if this is not trapped by the surrounding
        Perl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Perl <literal>die</literal> command.
        The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"/> and
        <xref linkend="guc-client-min-messages"/> configuration
        variables. See <xref linkend="runtime-config"/> for more
        information.
-->
ログまたはエラーメッセージを発行します。
使用できるレベルは、<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>、<literal>WARNING</literal>、および<literal>ERROR</literal>です。
<literal>ERROR</literal>はエラー状態を発生します。
その上位のPerlコードでこのエラーを捕捉しない場合、エラーは問い合わせの呼び出し元まで伝播し、その結果、現在のトランザクションもしくはサブトランザクションはアボートします。
これは実質Perlの<literal>die</literal>コマンドと同じです。
他のレベルは、異なる重要度のメッセージを生成するだけです。
<xref linkend="guc-log-min-messages"/>と<xref linkend="guc-client-min-messages"/>設定パラメータは、特定の重要度のメッセージをクライアントに報告するか、サーバのログに書き出すか、あるいはその両方かを制御します。
詳細は<xref linkend="runtime-config"/>を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string. Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns undef on undef input; if the argument
        might be undef, <function>quote_nullable</function> is often more suitable.
-->
与えられた文字列を、SQL文の文字列内で文字列リテラルとして使用するために適切に引用符付けして返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
<function>quote_literal</function>は入力がundefならばundefを返すことに注意してください。
引数がundefの可能性があるのであれば、<function>quote_nullable</function>の方が適しています。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string; or, if the argument is undef, return the unquoted string "NULL".
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた文字列を、SQL文の文字列内で文字列リテラルとして使用するために適切に引用符付けして返します。
引数がundefの場合引用符付けされない文字列"NULL"を返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Return the given string suitably quoted to be used as an identifier in
        an SQL statement string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
-->
与えられた文字列を、SQL文の文字列内で識別子として使用するために適切に引用符付けして返します。
必要な場合(つまり文字列に識別子用ではない文字列が含まれる、または、大文字小文字を保持する場合)のみ引用符が付けられます。
埋め込まれた引用符は適切に二重化されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Return the unescaped binary data represented by the contents of the given string,
        which should be <type>bytea</type> encoded.
-->
与えられた文字列の内容を表す、エスケープのないバイナリデータを返します。
これは<type>bytea</type>符号化でなければなりません。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Return the <type>bytea</type> encoded form of the binary data contents of the given string.
-->
与えられた文字列の内容をバイナリデータ形式で符号化した<type>bytea</type>を返します。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal>
     </term>
     <listitem>
      <para>
<!--
        Returns the contents of the referenced array as a string in array literal format
        (see <xref linkend="arrays-input"/>).
        Returns the argument value unaltered if it's not a reference to an array.
        The delimiter used between elements of the array literal defaults to "<literal>, </literal>"
        if a delimiter is not specified or is undef.
-->
参照先の配列の内容を、配列リテラル書式で表した文字列として返します(<xref linkend="arrays-input"/>参照)。
配列への参照でない場合は引数の値は変更されません。
配列リテラルの要素間の区切り文字は指定がない、または、undefの場合、デフォルトで"<literal>, </literal>"です。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
      <listitem>
       <para>
<!--
         Converts a Perl variable to the value of the data type passed as a
         second argument and returns a string representation of this value.
         Correctly handles nested arrays and values of composite types.
-->
Perl変数を2番目の引数として渡されたデータ型の値に変換し、その値の文字列表現を返します。
入れ子状の配列や複合型の値を正しく扱います。
       </para>
      </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Returns the contents of the referenced array as a string in array constructor format
        (see <xref linkend="sql-syntax-array-constructors"/>).
        Individual values are quoted using <function>quote_nullable</function>.
        Returns the argument value, quoted using <function>quote_nullable</function>,
        if it's not a reference to an array.
-->
参照先の配列の内容を配列生成書式で表した文字列として返します(<xref linkend="sql-syntax-array-constructors"/>参照)。
個々の値は<function>quote_nullable</function>を使用して引用符付けされます。
配列への参照でない場合は、<function>quote_nullable</function>を使用して引用符付けされた引数の値が返されます。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Returns a true value if the content of the given string looks like a
        number, according to Perl, returns false otherwise.
        Returns undef if the argument is undef.  Leading and trailing space is
        ignored. <literal>Inf</literal> and <literal>Infinity</literal> are regarded as numbers.
-->
与えられた文字列の内容がPerlの流儀で数値でありそうな場合に真値を、さもなくば偽を返します。
引数がundefならばundefを返します。
先頭の空白、末尾の空白は無視されます。
<literal>Inf</literal>および<literal>Infinity</literal>は数値とみなします。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>PL/Perlにおける</secondary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
        Returns a true value if the given argument may be treated as an
        array reference, that is, if ref of the argument is <literal>ARRAY</literal> or
        <literal>PostgreSQL::InServer::ARRAY</literal>.  Returns false otherwise.
-->
指定された引数が配列参照として扱うことができる場合、つまり、引数のrefが<literal>ARRAY</literal>または<literal>PostgreSQL::InServer::ARRAY</literal>の場合、真を返します。
さもなくば偽を返します。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="plperl-global">
<!--
  <title>Global Values in PL/Perl</title>
-->
  <title>PL/Perlにおけるグローバルな値</title>

  <para>
<!--
    You can use the global hash <varname>%_SHARED</varname> to store
    data, including code references, between function calls for the
    lifetime of the current session.
-->
現在のセッションの有効期間中の関数呼び出し間でデータ（コード参照を含む）を受け渡しするためにグローバルな<varname>%_SHARED</varname>ハッシュを使用することができます。
  </para>

  <para>
<!--
    Here is a simple example for shared data:
-->
データの共有について簡単な例を以下に示します。
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>

  <para>
<!--
   Here is a slightly more complicated example using a code reference:
-->
以下は、コード参照を使用した、多少複雑な例です。

<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

<!--
SELECT myfuncs(); /* initializes the function */
-->
SELECT myfuncs(); /* 関数の初期化 */

<!--
/* Set up a function that uses the quote function */
-->
/* 引用符関数を使用する関数を作成 */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>

<!--
   (You could have replaced the above with the one-liner
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
   at the expense of readability.)
-->
（可読性を犠牲にすると、上は<literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>という1行のみで置き換えることができます。）
  </para>

  <para>
<!--
   For security reasons, PL/Perl executes functions called by any one SQL role
   in a separate Perl interpreter for that role.  This prevents accidental or
   malicious interference by one user with the behavior of another user's
   PL/Perl functions.  Each such interpreter has its own value of the
   <varname>%_SHARED</varname> variable and other global state.  Thus, two
   PL/Perl functions will share the same value of <varname>%_SHARED</varname>
   if and only if they are executed by the same SQL role.  In an application
   wherein a single session executes code under multiple SQL roles (via
   <literal>SECURITY DEFINER</literal> functions, use of <command>SET ROLE</command>, etc.)
   you may need to take explicit steps to ensure that PL/Perl functions can
   share data via <varname>%_SHARED</varname>.  To do that, make sure that
   functions that should communicate are owned by the same user, and mark
   them <literal>SECURITY DEFINER</literal>.  You must of course take care that
   such functions can't be used to do anything unintended.
-->
セキュリティ上の理由により、PL/Perlは、あるロールで呼び出された関数をそのロール用に独立したPerlインタプリタ内で実行します。
これにより、あるユーザの事故または悪意によって他のユーザのPL/Perl関数の動作が干渉されてしまうことを防ぎます。
こうしたインタプリタはそれぞれ独自の<varname>%_SHARED</varname>などのグローバル状態を持ちます。
したがって、同一のSQLロールによって実行された場合のみ、２つのPL/Perl関数は同じ<varname>%_SHARED</varname>値を共有します。
１つのセッション内で複数のSQLロールの元でコードを（<literal>SECURITY DEFINER</literal>経由、<command>SET ROLE</command>の使用など）実行するアプリケーションでは、確実にPL/Perl関数が<varname>%_SHARED</varname>を介してデータを共有することができるように、明示的な処理を行う必要があります。
このためには、通信しなければならない関数が同じユーザによって所有されること、および<literal>SECURITY DEFINER</literal>と印付けられていることを確実にしなければなりません。
当然ながらこうした関数が意図していないことを行うために使用することができないように注意しなければなりません。
  </para>
 </sect1>

 <sect1 id="plperl-trusted">
<!--
  <title>Trusted and Untrusted PL/Perl</title>
-->
  <title>信頼されたPL/Perlおよび信頼されないPL/Perl</title>

  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>
  <indexterm zone="plperl-trusted">
   <primary>信頼</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <para>
<!--
   Normally, PL/Perl is installed as a <quote>trusted</quote> programming
   language named <literal>plperl</literal>.  In this setup, certain Perl
   operations are disabled to preserve security.  In general, the
   operations that are restricted are those that interact with the
   environment. This includes file handle operations,
   <literal>require</literal>, and <literal>use</literal> (for
   external modules).  There is no way to access internals of the
   database server process or to gain OS-level access with the
   permissions of the server process,
   as a C function can do.  Thus, any unprivileged database user can
   be permitted to use this language.
-->
通常、PL/Perlは<literal>plperl</literal>という名前で<quote>信頼された</quote>プログラミング言語としてインストールされます。
この設定では、セキュリティを確保するためにPerlの特定の操作は無効にされます。
一般的には、制限される操作は環境に作用するものです。
これには、ファイルハンドル操作や<literal>require</literal>、<literal>use</literal>（外部モジュール用）が含まれます。
C関数では可能ですが、Perlでは、データベースサーバ内部にアクセスする方法や、サーバプロセスの権限によるOSレベルのアクセスを行う方法はありません。
この結果、データベースの全ての非特権ユーザはこの言語を使用することができます。
  </para>

  <para>
<!--
   Here is an example of a function that will not work because file
   system operations are not allowed for security reasons:
-->
セキュリティ上の理由により許されていないファイルシステム操作を行うため、うまく動作しない関数の例を以下に示します。
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
<!--
    The creation of this function will fail as its use of a forbidden
    operation will be caught by the validator.
-->
許されていない操作の使用が検証機能によって検出されますので、この関数の作成は失敗します。
  </para>

  <para>
<!--
   Sometimes it is desirable to write Perl functions that are not
   restricted.  For example, one might want a Perl function that sends
   mail.  To handle these cases, PL/Perl can also be installed as an
   <quote>untrusted</quote> language (usually called
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>).
   In this case the full Perl language is available.  When installing the
   language, the language name <literal>plperlu</literal> will select
   the untrusted PL/Perl variant.
-->
制限のないPerl関数の作成が望ましい場合があります。
例えば、Perl 関数を使用してメールを送信するような場合です。
このような場合を扱うために、PL/Perlを<quote>信頼されない</quote>言語（通常<application>PL/PerlU</application>と呼ばれます）としてインストールすることもできます。<indexterm><primary>PL/PerlU</primary></indexterm>
この場合は完全なPerl言語を使用することができます。
言語がインストールされた場合、<literal>plperlu</literal>という言語名によって、信頼されないPL/Perlの亜種が選択されます。
  </para>

  <para>
<!--
   The writer of a <application>PL/PerlU</application> function must take care that the function
   cannot be used to do anything unwanted, since it will be able to do
   anything that could be done by a user logged in as the database
   administrator.  Note that the database system allows only database
   superusers to create functions in untrusted languages.
-->
<application>PL/PerlU</application>関数の作成者は、その関数を不必要なことに使用できないように注意する必要があります。
この関数は、データベース管理者としてログインしたユーザが実行できることを全て実行できるからです。
データベースシステムはデータベースのスーパーユーザにのみ信頼されない言語による関数作成を許可していることに注意してください。
  </para>

  <para>
<!--
   If the above function was created by a superuser using the language
   <literal>plperlu</literal>, execution would succeed.
-->
上記の関数が、スーパーユーザによって<literal>plperlu</literal>言語を使用して作成された場合、実行は可能となります。
  </para>

  <para>
<!--
   In the same way, anonymous code blocks written in Perl can use
   restricted operations if the language is specified as
   <literal>plperlu</literal> rather than <literal>plperl</literal>, but the caller
   must be a superuser.
-->
同じ方法で、言語を<literal>plperl</literal>ではなく<literal>plperlu</literal>と指定することで、Perl内に作成された匿名コードブロックは制限された操作を使用することができます。
ただし呼び出し元はスーパーユーザでなければなりません。
  </para>

  <note>
   <para>
<!--
    While <application>PL/Perl</application> functions run in a separate Perl
    interpreter for each SQL role, all <application>PL/PerlU</application> functions
    executed in a given session run in a single Perl interpreter (which is
    not any of the ones used for <application>PL/Perl</application> functions).
    This allows <application>PL/PerlU</application> functions to share data freely,
    but no communication can occur between <application>PL/Perl</application> and
    <application>PL/PerlU</application> functions.
-->
<application>PL/Perl</application>関数はSQLロール毎に別々のPerlインタプリタ内で実行されますが、あるセッションで実行される<application>PL/PerlU</application>関数はすべて、単一のPerlインタプリタ（<application>PL/Perl</application>関数用に使用されるインタプリタのいずれかではありません）内で実行されます。
これにより<application>PL/PerlU</application>関数はデータを自由に共有することができます。
しかし<application>PL/Perl</application>関数と<application>PL/PerlU</application>関数の間で通信することはできません。
   </para>
  </note>

  <note>
   <para>
<!--
    Perl cannot support multiple interpreters within one process unless
    it was built with the appropriate flags, namely either
    <literal>usemultiplicity</literal> or <literal>useithreads</literal>.
    (<literal>usemultiplicity</literal> is preferred unless you actually need
    to use threads.  For more details, see the
    <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.)
    If <application>PL/Perl</application> is used with a copy of Perl that was not built
    this way, then it is only possible to have one Perl interpreter per
    session, and so any one session can only execute either
    <application>PL/PerlU</application> functions, or <application>PL/Perl</application> functions
    that are all called by the same SQL role.
-->
Perlは適切なフラグ、すなわち<literal>usemultiplicity</literal>または<literal>useithreads</literal>を付けて構築していない限り、１つのプロセス内で複数のインタプリタをサポートすることはできません。
（実際にスレッドの使用が必要でなければ<literal>usemultiplicity</literal>を勧めます。
詳細は<citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>マニュアルページを参照してください。）
<application>PL/Perl</application>がこの方法で構築されていないPerlのコピーを使用する場合、１つのセッション内で１つのPerlインタプリタしか持つことができません。
このため、１つのセッションでは、<application>PL/PerlU</application>関数、もしくは、すべて同一のSQLロールで呼び出される<application>PL/Perl</application>関数のいずれかのみを実行することができます。
   </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
<!--
  <title>PL/Perl Triggers</title>
-->
  <title>PL/Perlトリガ</title>

  <para>
<!--
   PL/Perl can be used to write trigger functions.  In a trigger function,
   the hash reference <varname>$_TD</varname> contains information about the
   current trigger event. <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.
   The fields of the <varname>$_TD</varname> hash reference are:
-->
PL/Perlを使用してトリガ関数を作成することができます。
トリガ関数では、<varname>$_TD</varname>というハッシュへの参照に、現在のトリガイベントに関する情報が含まれています。
<varname>$_TD</varname>は大域変数であり、各トリガ呼び出しに対して局所的な値を別々に取り出します。
以下に<varname>$_TD</varname>というハッシュへの参照のフィールドを示します。

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
<!--
       <literal>NEW</literal> value of column <literal>foo</literal>
-->
<literal>NEW</literal>の<literal>foo</literal>列値。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
<!--
       <literal>OLD</literal> value of column <literal>foo</literal>
-->
<literal>OLD</literal>の<literal>foo</literal>列値。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
<!--
       Name of the trigger being called
-->
呼び出されたトリガの名前。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
<!--
       Trigger event: <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>, or <literal>UNKNOWN</literal>
-->
トリガイベント。
<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</literal>、もしくは<literal>UNKNOWN</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
<!--
       When the trigger was called: <literal>BEFORE</literal>,
       <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, or
       <literal>UNKNOWN</literal>
-->
トリガがいつ呼び出されたか。
<literal>BEFORE</literal>、<literal>AFTER</literal>、<literal>INSTEAD OF</literal>もしくは<literal>UNKNOWN</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
<!--
       The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>
-->
トリガレベル。
<literal>ROW</literal>、<literal>STATEMENT</literal>、もしくは<literal>UNKNOWN</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
<!--
       OID of the table on which the trigger fired
-->
トリガの発行元テーブルのOID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
<!--
       Name of the table on which the trigger fired
-->
トリガの発行元テーブルの名前。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
<!--
       Name of the table on which the trigger fired. This has been deprecated,
       and could be removed in a future release.
       Please use $_TD-&gt;{table_name} instead.
-->
トリガの発行元テーブルの名前。
これは廃止予定で、将来のリリースで削除される可能性があります。
代わりに$_TD-&gt;{table_name}を使用してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
<!--
       Name of the schema in which the table on which the trigger fired, is
-->
トリガの発行元テーブルが存在するスキーマの名前。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
<!--
       Number of arguments of the trigger function
-->
トリガ関数の引数の数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
<!--
       Arguments of the trigger function.  Does not exist if <literal>$_TD-&gt;{argc}</literal> is 0.
-->
トリガ関数の引数。
<literal>$_TD-&gt;{argc}</literal>が0の場合は存在しません。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <para>
<!--
   Row-level triggers can return one of the following:
-->
行レベルトリガは以下のいずれかを返すことができます。

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
<!--
       Execute the operation
-->
操作を実行します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
<!--
       Don't execute the operation
-->
操作を実行しません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
<!--
       Indicates that the <literal>NEW</literal> row was modified by
       the trigger function
-->
トリガ関数によって<literal>NEW</literal>行が変更されたことを示します。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   Here is an example of a trigger function, illustrating some of the
   above:
-->
以下はトリガ関数の例で、ここまでの説明の一部を例証するものです。
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
<!--
        return "SKIP";    # skip INSERT/UPDATE command
-->
        return "SKIP";    # INSERT/UPDATEコマンドを取消します。
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
<!--
        return "MODIFY";  # modify row and execute INSERT/UPDATE command
-->
        return "MODIFY";  # 行を変更し、INSERT/UPDATEコマンドを実行します。
    } else {
<!--
        return;           # execute INSERT/UPDATE command
-->
        return;           # INSERT/UPDATEコマンドを実行します。
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();
</programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-event-triggers">
<!--
  <title>PL/Perl Event Triggers</title>
-->
  <title>PL/Perlイベントトリガ</title>

  <para>
<!--
   PL/Perl can be used to write event trigger functions.  In an event trigger
   function, the hash reference <varname>$_TD</varname> contains information
   about the current trigger event.  <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.  The
   fields of the <varname>$_TD</varname> hash reference are:
-->
PL/Perlを使用してイベントトリガ関数を作成することができます。
イベントトリガ関数では、<varname>$_TD</varname>というハッシュへの参照に、現在のトリガイベントに関する情報が含まれています。
<varname>$_TD</varname>はグローバル変数であり、各トリガ呼び出しに対してローカルな値を別々に取り出します。
以下に<varname>$_TD</varname>というハッシュへの参照のフィールドを示します。

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
<!--
       The name of the event the trigger is fired for.
-->
イベントトリガ名が発行された
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
<!--
       The command tag for which the trigger is fired.
-->
トリガの発行元コマンドタグ
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   The return value of the trigger function is ignored.
-->
トリガ関数の戻り値は無視されます
  </para>

  <para>
<!--
   Here is an example of an event trigger function, illustrating some of the
   above:
-->
以下はトリガ関数の例で、ここまでの説明の一部を例証するものです。
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
</programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
<!--
  <title>PL/Perl Under the Hood</title>
-->
  <title>PL/Perlの内部</title>

 <sect2 id="plperl-config">
<!--
  <title>Configuration</title>
-->
  <title>設定</title>

  <para>
<!--
  This section lists configuration parameters that affect <application>PL/Perl</application>.
-->
本節では<application>PL/Perl</application>に影響する設定パラメータを列挙します。
  </para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
      <term>
       <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>plperl.on_init</varname> configuration parameter</primary>
      </indexterm>
      <indexterm>
       <primary><varname>plperl.on_init</varname>設定パラメータ</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
<!--
        Specifies Perl code to be executed when a Perl interpreter is first
        initialized, before it is specialized for use by <literal>plperl</literal> or
        <literal>plperlu</literal>.
        The SPI functions are not available when this code is executed.
        If the code fails with an error it will abort the initialization of
        the interpreter and propagate out to the calling query, causing the
        current transaction or subtransaction to be aborted.
-->
Perlインタプリタが最初に初期化され、<literal>plperl</literal>または<literal>plperlu</literal>での使用のための準備がなされる前に実行されるperlコードを指定します。
このコードが実行される時にはSPI関数を利用できません。
このコードがエラーで失敗した場合、インタプリタの初期化は中断され、呼び出し元の問い合わせに伝わり、現在のトランザクションまたはサブトランザクションがアボートすることになります。
       </para>
       <para>
<!--
       The Perl code is limited to a single string. Longer code can be placed
       into a module and loaded by the <literal>on_init</literal> string.
       Examples:
-->
このPerlコードは単一文字列に制限されます。
長いコードをモジュール化し、<literal>on_init</literal>文字列でロードすることができます。
以下に例を示します。
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
       <para>
<!--
       Any modules loaded by <literal>plperl.on_init</literal>, either directly or
       indirectly, will be available for use by <literal>plperl</literal>.  This may
       create a security risk. To see what modules have been loaded you can use:
-->
<literal>plperl.on_init</literal>により直接または間接的に読み込まれるモジュールはすべて、<literal>plperl</literal>により使用可能になります。
これはセキュリティの危険性が発生する可能性があります。
どんなモジュールが読み込まれたかを確認するためには以下を使用します。
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
       <para>
<!--
        Initialization will happen in the postmaster if the <literal>plperl</literal> library is
        included in <xref linkend="guc-shared-preload-libraries"/>, in which
        case extra consideration should be given to the risk of destabilizing
        the postmaster.  The principal reason for making use of this feature
        is that Perl modules loaded by <literal>plperl.on_init</literal> need be
        loaded only at postmaster start, and will be instantly available
        without loading overhead in individual database sessions.  However,
        keep in mind that the overhead is avoided only for the first Perl
        interpreter used by a database session &mdash; either PL/PerlU, or
        PL/Perl for the first SQL role that calls a PL/Perl function.  Any
        additional Perl interpreters created in a database session will have
        to execute <literal>plperl.on_init</literal> afresh.  Also, on Windows there
        will be no savings whatsoever from preloading, since the Perl
        interpreter created in the postmaster process does not propagate to
        child processes.
-->
<literal>plperl</literal>ライブラリが<xref linkend="guc-shared-preload-libraries"/>に含まれている場合、初期化はpostmaster内部で起こります。
この場合、postmasterが不安定になる危険が出てくるため、一層の考慮が必要です。
この機能を使用できるようにした大きな理由は、<literal>plperl.on_init</literal>でロードされるPerlモジュールはpostmaster起動時点のみでロードされなければならないためです。
このため個々のデータベースセッション内にロードというオーバーヘッドをもたらすことなく即座に利用できるようになります。
しかし、データベースセッションで最初に使用されるPerlインタプリタ（PL/PerlUまたはPL/Perl関数を呼び出す最初のSQLロール用のPL/Perl）に対してのみ、このオーバーヘッドを防ぐことができる点に注意してください。
データベースセッション内でその後に作成されるPerlインタプリタはすべて、新たに<literal>plperl.on_init</literal>を実行する必要があります。
また、postmasterプロセス内で作成されるPerlインタプリタは子プロセスに伝播されませんので、Windowsにおける事前ロードには何かを節約することはまったくありません。
       </para>
       <para>
<!--
       This parameter can only be set in the <filename>postgresql.conf</filename> file or on the server command line.
-->
このパラメータは<filename>postgresql.conf</filename>ファイルまたはサーバのコマンドラインでのみ設定可能です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
      <term>
       <varname>plperl.on_plperl_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname> configuration parameter</primary>
       </indexterm>
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname>設定パラメータ</primary>
       </indexterm>
      </term>
      <term>
       <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname> configuration parameter</primary>
       </indexterm>
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname>設定パラメータ</primary>
       </indexterm>
      </term>
      <listitem>
       <para>
<!--
        These parameters specify Perl code to be executed when a Perl
        interpreter is specialized for <literal>plperl</literal> or
        <literal>plperlu</literal> respectively.  This will happen when a PL/Perl or
        PL/PerlU function is first executed in a database session, or when
        an additional interpreter has to be created because the other language
        is called or a PL/Perl function is called by a new SQL role.  This
        follows any initialization done by <literal>plperl.on_init</literal>.
        The SPI functions are not available when this code is executed.
        The Perl code in <literal>plperl.on_plperl_init</literal> is executed after
        <quote>locking down</quote> the interpreter, and thus it can only perform
        trusted operations.
-->
これらのパラメータはそれぞれ、<literal>plperl</literal>または<literal>plperlu</literal>用にPerlインタプリタを特化する時に実行されるPerlコードを指定します。
これは、データベースセッション内でPL/PerlまたはPL/PerlU関数が最初に実行される時、または、他の言語が呼び出されたため、あるいは新しいSQLロールでPL/Perl関数が呼び出されたために追加のインタプリタを呼び出す必要があった時に起こります。
この後に<literal>plperl.on_init</literal>による初期化が行われます。
このコードを実行する時にはSPI関数は利用できません。
<literal>plperl.on_plperl_init</literal>内のPerlコードはインタプリタを<quote>権限で制限した</quote>後に実行されます。
このためPerlコードは信頼できる操作のみを行うことができます。
       </para>
       <para>
<!--
        If the code fails with an error it will abort the initialization and
        propagate out to the calling query, causing the current transaction or
        subtransaction to be aborted.  Any actions already done within Perl
        won't be undone; however, that interpreter won't be used again.
        If the language is used again the initialization will be attempted
        again within a fresh Perl interpreter.
-->
コードがエラーで失敗した場合、初期化は中断され、呼び出し元にエラーが伝わります。
その結果現在のトランザクションまたはサブトランザクションはアボートします。
Perl内ですでに行われた処理は取り消されません。
言語が再度使用される時、初期化は新しいインタプリタの中で再度試行されます。
       </para>
       <para>
<!--
        Only superusers can change these settings.  Although these settings
        can be changed within a session, such changes will not affect Perl
        interpreters that have already been used to execute functions.
-->
スーパーユーザのみがこれらの設定を変更することができます。
これらの設定はセッション内で変更することができますが、このような変更は関数を実行するためにすでに使用されたPerlインタプリタには影響を与えません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
      <term>
       <varname>plperl.use_strict</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>plperl.use_strict</varname> configuration parameter</primary>
       </indexterm>
       <indexterm>
        <primary><varname>plperl.use_strict</varname>設定パラメータ</primary>
       </indexterm>
      </term>
      <listitem>
       <para>
<!--
        When set true subsequent compilations of PL/Perl functions will have
        the <literal>strict</literal> pragma enabled.  This parameter does not affect
        functions already compiled in the current session.
-->
真の場合、その後のPL/Perl関数のコンパイルは<literal>strict</literal>プラグマが有効になります。
このパラメータは現在のセッションでコンパイル済みの関数には影響しません。
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
<!--
  <title>Limitations and Missing Features</title>
-->
<title>制限および存在しない機能</title>

  <para>
<!--
   The following features are currently missing from PL/Perl, but they
   would make welcome contributions.
-->
現時点では、以下の機能はPL/Perlにありません。
各機能の寄稿を歓迎します。

   <itemizedlist>
    <listitem>
     <para>
<!--
      PL/Perl functions cannot call each other directly.
-->
PL/Perl関数は互いに直接呼び出すことができません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      SPI is not yet fully implemented.
-->
SPIはまだ完全に実装されていません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      If you are fetching very large data sets using
      <literal>spi_exec_query</literal>, you should be aware that
      these will all go into memory.  You can avoid this by using
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> as
      illustrated earlier.
-->
<literal>spi_exec_query</literal>を使用して、非常に大規模なデータセットを取り出そうとする場合、これらがすべてメモリ内に保存されることに注意しなければなりません。
上で示した通り、<literal>spi_query</literal>/<literal>spi_fetchrow</literal>を使用することで、これを避けることができます。
     </para>
     <para>
<!--
        A similar problem occurs if a set-returning function passes a
        large set of rows back to PostgreSQL via <literal>return</literal>. You
        can avoid this problem too by instead using
        <literal>return_next</literal> for each row returned, as shown
        previously.
-->
集合を返す関数が大規模な行セットを<literal>return</literal>を介してPostgreSQLに返す場合、同様の問題が起こります。
前述の通り、この問題も<literal>return_next</literal>を使用して行毎に返すことで避けることができます。
     </para>
    </listitem>

     <listitem>
      <para>
<!--
        When a session ends normally, not due to a fatal error, any
        <literal>END</literal> blocks that have been defined are executed.
        Currently no other actions are performed. Specifically,
        file handles are not automatically flushed and objects are
        not automatically destroyed.
-->
セッションが正常に終了した時、致命的なエラーによるものでなければ、定義された任意の<literal>END</literal>ブロックが実行されます。
現在、その他の動作は行われません。
特にファイルハンドルは自動的に吐き出されません。
またオブジェクトも自動的に破棄されません。
      </para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>

 </sect1>

</chapter>
